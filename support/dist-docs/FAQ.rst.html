<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>FAQ.rst (Open vSwitch 2.6.90)</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="frequently-asked-questions">
<h1 class="title">Frequently Asked Questions</h1>

<!-- Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations
under the License.

Convention for heading levels in Open vSwitch documentation:

=======  Heading 0 (reserved for the title in a document)
- - - - - - -  Heading 1
~~~~~~~  Heading 2
+++++++  Heading 3
'''''''  Heading 4

Avoid deeper levels because they do not render well. -->
<div class="section" id="general">
<h1>General</h1>
<p>Q: What is Open vSwitch?</p>
<blockquote>
<p>A: Open vSwitch is a production quality open source software switch
designed to be used as a vswitch in virtualized server environments.  A
vswitch forwards traffic between different VMs on the same physical host
and also forwards traffic between VMs and the physical network.  Open
vSwitch supports standard management interfaces (e.g. sFlow, NetFlow,
IPFIX, RSPAN, CLI), and is open to programmatic extension and control using
OpenFlow and the OVSDB management protocol.</p>
<p>Open vSwitch as designed to be compatible with modern switching chipsets.
This means that it can be ported to existing high-fanout switches allowing
the same flexible control of the physical infrastructure as the virtual
infrastructure.  It also means that Open vSwitch will be able to take
advantage of on-NIC switching chipsets as their functionality matures.</p>
</blockquote>
<p>Q: What virtualization platforms can use Open vSwitch?</p>
<blockquote>
A: Open vSwitch can currently run on any Linux-based virtualization
platform (kernel 3.10 and newer), including: KVM, VirtualBox, Xen, Xen
Cloud Platform, XenServer. As of Linux 3.3 it is part of the mainline
kernel.  The bulk of the code is written in platform- independent C and is
easily ported to other environments.  We welcome inquires about integrating
Open vSwitch with other virtualization platforms.</blockquote>
<p>Q: How can I try Open vSwitch?</p>
<blockquote>
<p>A: The Open vSwitch source code can be built on a Linux system.  You can
build and experiment with Open vSwitch on any Linux machine.  Packages for
various Linux distributions are available on many platforms, including:
Debian, Ubuntu, Fedora.</p>
<p>You may also download and run a virtualization platform that already has
Open vSwitch integrated.  For example, download a recent ISO for XenServer
or Xen Cloud Platform.  Be aware that the version integrated with a
particular platform may not be the most recent Open vSwitch release.</p>
</blockquote>
<p>Q: Does Open vSwitch only work on Linux?</p>
<blockquote>
<p>A: No, Open vSwitch has been ported to a number of different operating
systems and hardware platforms.  Most of the development work occurs on
Linux, but the code should be portable to any POSIX system.  We've seen
Open vSwitch ported to a number of different platforms, including FreeBSD,
Windows, and even non-POSIX embedded systems.</p>
<p>By definition, the Open vSwitch Linux kernel module only works on Linux and
will provide the highest performance.  However, a userspace datapath is
available that should be very portable.</p>
</blockquote>
<p>Q: What's involved with porting Open vSwitch to a new platform or switching ASIC?</p>
<blockquote>
A: The <a class="reference external" href="PORTING.rst">porting document</a> describes how one would go about
porting Open vSwitch to a new operating system or hardware platform.</blockquote>
<p>Q: Why would I use Open vSwitch instead of the Linux bridge?</p>
<blockquote>
A: Open vSwitch is specially designed to make it easier to manage VM
network configuration and monitor state spread across many physical hosts
in dynamic virtualized environments.  Refer to <a class="reference external" href="WHY-OVS.rst">WHY-OVS</a>
for a more detailed description of how Open vSwitch relates to the Linux
Bridge.</blockquote>
<p>Q: How is Open vSwitch related to distributed virtual switches like the VMware
vNetwork distributed switch or the Cisco Nexus 1000V?</p>
<blockquote>
<p>A: Distributed vswitch applications (e.g., VMware vNetwork distributed
switch, Cisco Nexus 1000V) provide a centralized way to configure and
monitor the network state of VMs that are spread across many physical
hosts.  Open vSwitch is not a distributed vswitch itself, rather it runs on
each physical host and supports remote management in a way that makes it
easier for developers of virtualization/cloud management platforms to offer
distributed vswitch capabilities.</p>
<p>To aid in distribution, Open vSwitch provides two open protocols that are
specially designed for remote management in virtualized network
environments: OpenFlow, which exposes flow-based forwarding state, and the
OVSDB management protocol, which exposes switch port state.  In addition to
the switch implementation itself, Open vSwitch includes tools (ovs-ofctl,
ovs-vsctl) that developers can script and extend to provide distributed
vswitch capabilities that are closely integrated with their virtualization
management platform.</p>
</blockquote>
<p>Q: Why doesn't Open vSwitch support distribution?</p>
<blockquote>
A: Open vSwitch is intended to be a useful component for building flexible
network infrastructure. There are many different approaches to distribution
which balance trade-offs between simplicity, scalability, hardware
compatibility, convergence times, logical forwarding model, etc. The goal
of Open vSwitch is to be able to support all as a primitive building block
rather than choose a particular point in the distributed design space.</blockquote>
<p>Q: How can I contribute to the Open vSwitch Community?</p>
<blockquote>
A: You can start by joining the mailing lists and helping to answer
questions.  You can also suggest improvements to documentation.  If you
have a feature or bug you would like to work on, send a mail to <a class="reference external" href="http://openvswitch.org/mlists/">one of the
mailing lists</a>.</blockquote>
<p>Q: Why can I no longer connect to my OpenFlow controller or OVSDB manager?</p>
<blockquote>
A: Starting in OVS 2.4, we switched the default ports to the IANA-specified
port numbers for OpenFlow (6633-&gt;6653) and OVSDB (6632-&gt;6640).  We
recommend using these port numbers, but if you cannot, all the programs
allow overriding the default port.  See the appropriate man page.</blockquote>
</div>
<div class="section" id="releases">
<h1>Releases</h1>
<p>Q: What does it mean for an Open vSwitch release to be LTS (long-term support)?</p>
<blockquote>
<p>A: All official releases have been through a comprehensive testing process
and are suitable for production use.  Planned releases occur twice a year.
If a significant bug is identified in an LTS release, we will provide an
updated release that includes the fix.  Releases that are not LTS may not
be fixed and may just be supplanted by the next major release.  The current
LTS release is 2.3.x.</p>
<p>For more information on the Open vSwitch release process, refer to <a class="reference external" href="Documentation/release-process.rst">release
process</a>.</p>
</blockquote>
<p>Q: What Linux kernel versions does each Open vSwitch release work with?</p>
<blockquote>
<p>A: The following table lists the Linux kernel versions against which the
given versions of the Open vSwitch kernel module will successfully build.
The Linux kernel versions are upstream kernel versions, so Linux kernels
modified from the upstream sources may not build in some cases even if they
are based on a supported version.  This is most notably true of Red Hat
Enterprise Linux (RHEL) kernels, which are extensively modified from
upstream.</p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Open vSwitch</th>
<th class="head">Linux kernel</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1.4.x</td>
<td>2.6.18 to 3.2</td>
</tr>
<tr><td>1.5.x</td>
<td>2.6.18 to 3.2</td>
</tr>
<tr><td>1.6.x</td>
<td>2.6.18 to 3.2</td>
</tr>
<tr><td>1.7.x</td>
<td>2.6.18 to 3.3</td>
</tr>
<tr><td>1.8.x</td>
<td>2.6.18 to 3.4</td>
</tr>
<tr><td>1.9.x</td>
<td>2.6.18 to 3.8</td>
</tr>
<tr><td>1.10.x</td>
<td>2.6.18 to 3.8</td>
</tr>
<tr><td>1.11.x</td>
<td>2.6.18 to 3.8</td>
</tr>
<tr><td>2.0.x</td>
<td>2.6.32 to 3.10</td>
</tr>
<tr><td>2.1.x</td>
<td>2.6.32 to 3.11</td>
</tr>
<tr><td>2.3.x</td>
<td>2.6.32 to 3.14</td>
</tr>
<tr><td>2.4.x</td>
<td>2.6.32 to 4.0</td>
</tr>
<tr><td>2.5.x</td>
<td>2.6.32 to 4.3</td>
</tr>
<tr><td>2.6.x</td>
<td>3.10 to 4.7</td>
</tr>
</tbody>
</table>
<p>Open vSwitch userspace should also work with the Linux kernel module built
into Linux 3.3 and later.</p>
<p>Open vSwitch userspace is not sensitive to the Linux kernel version.  It
should build against almost any kernel, certainly against 2.6.32 and later.</p>
</blockquote>
<p>Q: Are all features available with all datapaths?</p>
<blockquote>
<p>A: Open vSwitch supports different datapaths on different platforms.  Each
datapath has a different feature set: the following tables try to summarize
the status.</p>
<p>Supported datapaths:</p>
<dl class="docutils">
<dt>Linux upstream</dt>
<dd>The datapath implemented by the kernel module shipped with Linux
upstream.  Since features have been gradually introduced into the kernel,
the table mentions the first Linux release whose OVS module supports the
feature.</dd>
<dt>Linux OVS tree</dt>
<dd>The datapath implemented by the Linux kernel module distributed with the
OVS source tree.</dd>
<dt>Userspace</dt>
<dd>Also known as DPDK, dpif-netdev or dummy datapath. It is the only
datapath that works on NetBSD, FreeBSD and Mac OSX.</dd>
<dt>Hyper-V</dt>
<dd>Also known as the Windows datapath.</dd>
</dl>
<p>The following table lists the datapath supported features from an Open
vSwitch user's perspective.</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="22%" />
<col width="22%" />
<col width="14%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Feature</th>
<th class="head">Linux upstream</th>
<th class="head">Linux OVS tree</th>
<th class="head">Userspace</th>
<th class="head">Hyper-V</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>NAT</td>
<td>4.6</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr><td>Connection tracking</td>
<td>4.3</td>
<td>YES</td>
<td>PARTIAL</td>
<td>PARTIAL</td>
</tr>
<tr><td>Tunnel - LISP</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr><td>Tunnel - STT</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr><td>Tunnel - GRE</td>
<td>3.11</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr><td>Tunnel - VXLAN</td>
<td>3.12</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr><td>Tunnel - Geneve</td>
<td>3.18</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr><td>Tunnel - GRE-IPv6</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr><td>Tunnel - VXLAN-IPv6</td>
<td>4.3</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr><td>Tunnel - Geneve-IPv6</td>
<td>4.4</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr><td>QoS - Policing</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr><td>QoS - Shaping</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr><td>sFlow</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr><td>IPFIX</td>
<td>3.10</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr><td>Set action</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>PARTIAL</td>
</tr>
<tr><td>NIC Bonding</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr><td>Multiple VTEPs</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
</tbody>
</table>
<p>Do note, however:</p>
<ul class="simple">
<li>Only a limited set of flow fields is modifiable via the set action by the
Hyper-V datapath.</li>
<li>The Hyper-V datapath only supports one physical NIC per datapath. This is
why bonding is not supported.</li>
<li>The Hyper-V datapath can have at most one IP address configured as a
tunnel endpoint.</li>
</ul>
<p>The following table lists features that do not <em>directly</em> impact an Open
vSwitch user, e.g. because their absence can be hidden by the ofproto layer
(usually this comes with a performance penalty).</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="22%" />
<col width="22%" />
<col width="14%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Feature</th>
<th class="head">Linux upstream</th>
<th class="head">Linux OVS tree</th>
<th class="head">Userspace</th>
<th class="head">Hyper-V</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>SCTP flows</td>
<td>3.12</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr><td>MPLS</td>
<td>3.19</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr><td>UFID</td>
<td>4.0</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr><td>Megaflows</td>
<td>3.12</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr><td>Masked set action</td>
<td>4.0</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr><td>Recirculation</td>
<td>3.19</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr><td>TCP flags matching</td>
<td>3.13</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr><td>Validate flow actions</td>
<td>YES</td>
<td>YES</td>
<td>N/A</td>
<td>NO</td>
</tr>
<tr><td>Multiple datapaths</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr><td>Tunnel TSO - STT</td>
<td>N/A</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
</tr>
</tbody>
</table>
</blockquote>
<p>Q: What DPDK version does each Open vSwitch release work with?</p>
<blockquote>
<p>A: The following table lists the DPDK version against which the given
versions of Open vSwitch will successfully build.</p>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Open vSwitch</th>
<th class="head">DPDK</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>2.2.x</td>
<td>1.6</td>
</tr>
<tr><td>2.3.x</td>
<td>1.6</td>
</tr>
<tr><td>2.4.x</td>
<td>2.0</td>
</tr>
<tr><td>2.5.x</td>
<td>2.2</td>
</tr>
<tr><td>2.6.x</td>
<td>16.07</td>
</tr>
</tbody>
</table>
</blockquote>
<p>Q: I get an error like this when I configure Open vSwitch:</p>
<pre class="literal-block">
configure: error: Linux kernel in &lt;dir&gt; is version &lt;x&gt;, but
version newer than &lt;y&gt; is not supported (please refer to the
FAQ for advice)
</pre>
<p>What should I do?</p>
<blockquote>
<p>A: You have the following options:</p>
<ul class="simple">
<li>Use the Linux kernel module supplied with the kernel that you are using.
(See also the following FAQ.)</li>
<li>If there is a newer released version of Open vSwitch, consider building
that one, because it may support the kernel that you are building
against.  (To find out, consult the table in the previous FAQ.)</li>
<li>The Open vSwitch &quot;master&quot; branch may support the kernel that you are
using, so consider building the kernel module from &quot;master&quot;.</li>
</ul>
<p>All versions of Open vSwitch userspace are compatible with all versions of
the Open vSwitch kernel module, so you do not have to use the kernel module
from one source along with the userspace programs from the same source.</p>
</blockquote>
<p>Q: What features are not available in the Open vSwitch kernel datapath that
ships as part of the upstream Linux kernel?</p>
<blockquote>
<p>A: The kernel module in upstream Linux does not include support for LISP.
Work is in progress to add support for LISP to the upstream Linux version
of the Open vSwitch kernel module. For now, if you need this feature, use
the kernel module from the Open vSwitch distribution instead of the
upstream Linux kernel module.</p>
<p>Certain features require kernel support to function or to have reasonable
performance. If the ovs-vswitchd log file indicates that a feature is not
supported, consider upgrading to a newer upstream Linux release or using
the kernel module paired with the userspace distribution.</p>
</blockquote>
<p>Q: Why do tunnels not work when using a kernel module other than the one
packaged with Open vSwitch?</p>
<blockquote>
<p>A: Support for tunnels was added to the upstream Linux kernel module after
the rest of Open vSwitch. As a result, some kernels may contain support for
Open vSwitch but not tunnels. The minimum kernel version that supports each
tunnel protocol is:</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Protocol</th>
<th class="head">Linux Kernel</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>GRE</td>
<td>3.11</td>
</tr>
<tr><td>VXLAN</td>
<td>3.12</td>
</tr>
<tr><td>Geneve</td>
<td>3.18</td>
</tr>
<tr><td>LISP</td>
<td>not upstream</td>
</tr>
<tr><td>STT</td>
<td>not upstream</td>
</tr>
</tbody>
</table>
<p>If you are using a version of the kernel that is older than the one listed
above, it is still possible to use that tunnel protocol. However, you must
compile and install the kernel module included with the Open vSwitch
distribution rather than the one on your machine. If problems persist after
doing this, check to make sure that the module that is loaded is the one
you expect.</p>
</blockquote>
<p>Q: Why are UDP tunnel checksums not computed for VXLAN or Geneve?</p>
<blockquote>
A: Generating outer UDP checksums requires kernel support that was not part
of the initial implementation of these protocols. If using the upstream
Linux Open vSwitch module, you must use kernel 4.0 or newer. The
out-of-tree modules from Open vSwitch release 2.4 and later support UDP
checksums.</blockquote>
<p>Q: What features are not available when using the userspace datapath?</p>
<blockquote>
A: Tunnel virtual ports are not supported, as described in the previous
answer.  It is also not possible to use queue-related actions.  On Linux
kernels before 2.6.39, maximum-sized VLAN packets may not be transmitted.</blockquote>
<p>Q: Should userspace or kernel be upgraded first to minimize downtime?</p>
<blockquote>
A. In general, the Open vSwitch userspace should be used with the kernel
version included in the same release or with the version from upstream
Linux.  However, when upgrading between two releases of Open vSwitch it is
best to migrate userspace first to reduce the possibility of
incompatibilities.</blockquote>
<p>Q: What happened to the bridge compatibility feature?</p>
<blockquote>
<p>A: Bridge compatibility was a feature of Open vSwitch 1.9 and earlier.
When it was enabled, Open vSwitch imitated the interface of the Linux
kernel &quot;bridge&quot; module.  This allowed users to drop Open vSwitch into
environments designed to use the Linux kernel bridge module without
adapting the environment to use Open vSwitch.</p>
<p>Open vSwitch 1.10 and later do not support bridge compatibility.  The
feature was dropped because version 1.10 adopted a new internal
architecture that made bridge compatibility difficult to maintain.  Now
that many environments use OVS directly, it would be rarely useful in any
case.</p>
<p>To use bridge compatibility, install OVS 1.9 or earlier, including the
accompanying kernel modules (both the main and bridge compatibility
modules), following the instructions that come with the release.  Be sure
to start the ovs-brcompatd daemon.</p>
</blockquote>
</div>
<div class="section" id="terminology">
<h1>Terminology</h1>
<p>Q: I thought Open vSwitch was a virtual Ethernet switch, but the documentation
keeps talking about bridges.  What's a bridge?</p>
<blockquote>
A: In networking, the terms &quot;bridge&quot; and &quot;switch&quot; are synonyms.  Open
vSwitch implements an Ethernet switch, which means that it is also an
Ethernet bridge.</blockquote>
<p>Q: What's a VLAN?</p>
<blockquote>
A: See the &quot;VLAN&quot; section below.</blockquote>
</div>
<div class="section" id="basic-configuration">
<h1>Basic Configuration</h1>
<p>Q: How do I configure a port as an access port?</p>
<blockquote>
<p>A. Add <tt class="docutils literal">tag=VLAN</tt> to your <tt class="docutils literal"><span class="pre">ovs-vsctl</span> <span class="pre">add-port</span></tt> command. For example,
the following commands configure br0 with eth0 as a trunk port (the
default) and tap0 as an access port for VLAN 9:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl add-port br0 eth0
$ ovs-vsctl add-port br0 tap0 tag=9
</pre>
<p>If you want to configure an already added port as an access port, use
<tt class="docutils literal"><span class="pre">ovs-vsctl</span> set</tt>, e.g.:</p>
<pre class="literal-block">
$ ovs-vsctl set port tap0 tag=9
</pre>
</blockquote>
<p>Q: How do I configure a port as a SPAN port, that is, enable mirroring of all
traffic to that port?</p>
<blockquote>
<p>A. The following commands configure br0 with eth0 and tap0 as trunk ports.
All traffic coming in or going out on eth0 or tap0 is also mirrored to
tap1; any traffic arriving on tap1 is dropped:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl add-port br0 eth0
$ ovs-vsctl add-port br0 tap0
$ ovs-vsctl add-port br0 tap1 \
    -- --id=&#64;p get port tap1 \
    -- --id=&#64;m create mirror name=m0 select-all=true output-port=&#64;p \
    -- set bridge br0 mirrors=&#64;m
</pre>
<p>To later disable mirroring, run:</p>
<pre class="literal-block">
$ ovs-vsctl clear bridge br0 mirrors
</pre>
</blockquote>
<p>Q: Does Open vSwitch support configuring a port in promiscuous mode?</p>
<blockquote>
<p>A: Yes.  How you configure it depends on what you mean by &quot;promiscuous
mode&quot;:</p>
<ul>
<li><p class="first">Conventionally, &quot;promiscuous mode&quot; is a feature of a network interface
card.  Ordinarily, a NIC passes to the CPU only the packets actually
destined to its host machine.  It discards the rest to avoid wasting
memory and CPU cycles.  When promiscuous mode is enabled, however, it
passes every packet to the CPU.  On an old-style shared-media or
hub-based network, this allows the host to spy on all packets on the
network.  But in the switched networks that are almost everywhere these
days, promiscuous mode doesn't have much effect, because few packets not
destined to a host are delivered to the host's NIC.</p>
<p>This form of promiscuous mode is configured in the guest OS of the VMs on
your bridge, e.g. with &quot;ifconfig&quot;.</p>
</li>
<li><p class="first">The VMware vSwitch uses a different definition of &quot;promiscuous mode&quot;.
When you configure promiscuous mode on a VMware vNIC, the vSwitch sends a
copy of every packet received by the vSwitch to that vNIC.  That has a
much bigger effect than just enabling promiscuous mode in a guest OS.
Rather than getting a few stray packets for which the switch does not yet
know the correct destination, the vNIC gets every packet.  The effect is
similar to replacing the vSwitch by a virtual hub.</p>
<p>This &quot;promiscuous mode&quot; is what switches normally call &quot;port mirroring&quot;
or &quot;SPAN&quot;.  For information on how to configure SPAN, see &quot;How do I
configure a port as a SPAN port, that is, enable mirroring of all traffic
to that port?&quot;</p>
</li>
</ul>
</blockquote>
<p>Q: How do I configure a DPDK port as an access port?</p>
<blockquote>
<p>A: Firstly, you must have a DPDK-enabled version of Open vSwitch.</p>
<p>If your version is DPDK-enabled it will support the other-config:dpdk-init
configuration in the database and will display lines with &quot;EAL:...&quot; during
startup when other_config:dpdk-init is set to 'true'.</p>
<p>Secondly, when adding a DPDK port, unlike a system port, the type for the
interface must be specified. For example:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl add-port br0 dpdk0 -- set Interface dpdk0 type=dpdk
</pre>
<p>Finally, it is required that DPDK port names begin with <tt class="docutils literal">dpdk</tt>.</p>
<p>See <a class="reference external" href="INSTALL.DPDK.rst">INSTALL.DPDK</a> for more information on enabling
and using DPDK with Open vSwitch.</p>
</blockquote>
<p>Q: How do I configure a VLAN as an RSPAN VLAN, that is, enable mirroring of all
traffic to that VLAN?</p>
<blockquote>
<p>A: The following commands configure br0 with eth0 as a trunk port and tap0
as an access port for VLAN 10.  All traffic coming in or going out on tap0,
as well as traffic coming in or going out on eth0 in VLAN 10, is also
mirrored to VLAN 15 on eth0.  The original tag for VLAN 10, in cases where
one is present, is dropped as part of mirroring:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl add-port br0 eth0
$ ovs-vsctl add-port br0 tap0 tag=10
$ ovs-vsctl \
    -- --id=&#64;m create mirror name=m0 select-all=true select-vlan=10 \
       output-vlan=15 \
    -- set bridge br0 mirrors=&#64;m
</pre>
<p>To later disable mirroring, run:</p>
<pre class="literal-block">
$ ovs-vsctl clear bridge br0 mirrors
</pre>
<p>Mirroring to a VLAN can disrupt a network that contains unmanaged switches.
See ovs-vswitchd.conf.db(5) for details. Mirroring to a GRE tunnel has
fewer caveats than mirroring to a VLAN and should generally be preferred.</p>
</blockquote>
<p>Q: Can I mirror more than one input VLAN to an RSPAN VLAN?</p>
<blockquote>
<p>A: Yes, but mirroring to a VLAN strips the original VLAN tag in favor of
the specified output-vlan.  This loss of information may make the mirrored
traffic too hard to interpret.</p>
<p>To mirror multiple VLANs, use the commands above, but specify a
comma-separated list of VLANs as the value for select-vlan.  To mirror
every VLAN, use the commands above, but omit select-vlan and its value
entirely.</p>
<p>When a packet arrives on a VLAN that is used as a mirror output VLAN, the
mirror is disregarded.  Instead, in standalone mode, OVS floods the packet
across all the ports for which the mirror output VLAN is configured.  (If
an OpenFlow controller is in use, then it can override this behavior
through the flow table.)  If OVS is used as an intermediate switch, rather
than an edge switch, this ensures that the RSPAN traffic is distributed
through the network.</p>
<p>Mirroring to a VLAN can disrupt a network that contains unmanaged switches.
See ovs-vswitchd.conf.db(5) for details.  Mirroring to a GRE tunnel has
fewer caveats than mirroring to a VLAN and should generally be preferred.</p>
</blockquote>
<p>Q: How do I configure mirroring of all traffic to a GRE tunnel?</p>
<blockquote>
<p>A: The following commands configure br0 with eth0 and tap0 as trunk ports.
All traffic coming in or going out on eth0 or tap0 is also mirrored to
gre0, a GRE tunnel to the remote host 192.168.1.10; any traffic arriving on
gre0 is dropped:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl add-port br0 eth0
$ ovs-vsctl add-port br0 tap0
$ ovs-vsctl add-port br0 gre0 \
     -- set interface gre0 type=gre options:remote_ip=192.168.1.10 \
     -- --id=&#64;p get port gre0 \
     -- --id=&#64;m create mirror name=m0 select-all=true output-port=&#64;p \
     -- set bridge br0 mirrors=&#64;m
</pre>
<p>To later disable mirroring and destroy the GRE tunnel:</p>
<pre class="literal-block">
$ ovs-vsctl clear bridge br0 mirrors
$ ovs-vsctl del-port br0 gre0
</pre>
</blockquote>
<p>Q: Does Open vSwitch support ERSPAN?</p>
<blockquote>
A: No.  As an alternative, Open vSwitch supports mirroring to a GRE tunnel
(see above).</blockquote>
<p>Q: How do I connect two bridges?</p>
<blockquote>
<p>A: First, why do you want to do this?  Two connected bridges are not much
different from a single bridge, so you might as well just have a single
bridge with all your ports on it.</p>
<p>If you still want to connect two bridges, you can use a pair of patch
ports.  The following example creates bridges br0 and br1, adds eth0 and
tap0 to br0, adds tap1 to br1, and then connects br0 and br1 with a pair of
patch ports.</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl add-port br0 eth0
$ ovs-vsctl add-port br0 tap0
$ ovs-vsctl add-br br1
$ ovs-vsctl add-port br1 tap1
$ ovs-vsctl \
    -- add-port br0 patch0 \
    -- set interface patch0 type=patch options:peer=patch1 \
    -- add-port br1 patch1 \
    -- set interface patch1 type=patch options:peer=patch0
</pre>
<p>Bridges connected with patch ports are much like a single bridge. For
instance, if the example above also added eth1 to br1, and both eth0 and
eth1 happened to be connected to the same next-hop switch, then you could
loop your network just as you would if you added eth0 and eth1 to the same
bridge (see the &quot;Configuration Problems&quot; section below for more
information).</p>
<p>If you are using Open vSwitch 1.9 or an earlier version, then you need to
be using the kernel module bundled with Open vSwitch rather than the one
that is integrated into Linux 3.3 and later, because Open vSwitch 1.9 and
earlier versions need kernel support for patch ports. This also means that
in Open vSwitch 1.9 and earlier, patch ports will not work with the
userspace datapath, only with the kernel module.</p>
</blockquote>
<p>Q: How do I configure a bridge without an OpenFlow local port?  (Local port in
the sense of OFPP_LOCAL)</p>
<blockquote>
A: Open vSwitch does not support such a configuration.  Bridges always have
their local ports.</blockquote>
</div>
<div class="section" id="implementation-details">
<h1>Implementation Details</h1>
<p>Q: I hear OVS has a couple of kinds of flows.  Can you tell me about them?</p>
<blockquote>
<p>A: Open vSwitch uses different kinds of flows for different purposes:</p>
<ul>
<li><p class="first">OpenFlow flows are the most important kind of flow.  OpenFlow controllers
use these flows to define a switch's policy.  OpenFlow flows support
wildcards, priorities, and multiple tables.</p>
<p>When in-band control is in use, Open vSwitch sets up a few &quot;hidden&quot;
flows, with priority higher than a controller or the user can configure,
that are not visible via OpenFlow.  (See the &quot;Controller&quot; section of the
FAQ for more information about hidden flows.)</p>
</li>
<li><p class="first">The Open vSwitch software switch implementation uses a second kind of
flow internally.  These flows, called &quot;datapath&quot; or &quot;kernel&quot; flows, do
not support priorities and comprise only a single table, which makes them
suitable for caching.  (Like OpenFlow flows, datapath flows do support
wildcarding, in Open vSwitch 1.11 and later.)  OpenFlow flows and
datapath flows also support different actions and number ports
differently.</p>
<p>Datapath flows are an implementation detail that is subject to change in
future versions of Open vSwitch.  Even with the current version of Open
vSwitch, hardware switch implementations do not necessarily use this
architecture.</p>
</li>
</ul>
</blockquote>
<p>Users and controllers directly control only the OpenFlow flow table.  Open
vSwitch manages the datapath flow table itself, so users should not normally be
concerned with it.</p>
<p>Q: Why are there so many different ways to dump flows?</p>
<blockquote>
<p>A: Open vSwitch has two kinds of flows (see the previous question), so it
has commands with different purposes for dumping each kind of flow:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ovs-ofctl</span> <span class="pre">dump-flows</span> &lt;br&gt;</tt> dumps OpenFlow flows, excluding hidden
flows.  This is the most commonly useful form of flow dump.  (Unlike the
other commands, this should work with any OpenFlow switch, not just Open
vSwitch.)</li>
<li><tt class="docutils literal"><span class="pre">ovs-appctl</span> <span class="pre">bridge/dump-flows</span> &lt;br&gt;</tt> dumps OpenFlow flows, including
hidden flows.  This is occasionally useful for troubleshooting suspected
issues with in-band control.</li>
<li><tt class="docutils literal"><span class="pre">ovs-dpctl</span> <span class="pre">dump-flows</span> [dp]</tt> dumps the datapath flow table entries for a
Linux kernel-based datapath.  In Open vSwitch 1.10 and later,
ovs-vswitchd merges multiple switches into a single datapath, so it will
show all the flows on all your kernel-based switches.  This command can
occasionally be useful for debugging.</li>
<li><tt class="docutils literal"><span class="pre">ovs-appctl</span> <span class="pre">dpif/dump-flows</span> &lt;br&gt;</tt>, new in Open vSwitch 1.10, dumps
datapath flows for only the specified bridge, regardless of the type.</li>
</ul>
</blockquote>
<p>Q: How does multicast snooping works with VLANs?</p>
<blockquote>
A: Open vSwitch maintains snooping tables for each VLAN.</blockquote>
<p>Q: Can OVS populate the kernel flow table in advance instead of in reaction to
packets?</p>
<blockquote>
<p>A: No.  There are several reasons:</p>
<ul class="simple">
<li>Kernel flows are not as sophisticated as OpenFlow flows, which means that
some OpenFlow policies could require a large number of kernel flows.  The
&quot;conjunctive match&quot; feature is an extreme example: the number of kernel
flows it requires is the product of the number of flows in each
dimension.</li>
<li>With multiple OpenFlow flow tables and simple sets of actions, the number
of kernel flows required can be as large as the product of the number of
flows in each dimension.  With more sophisticated actions, the number of
kernel flows could be even larger.</li>
<li>Open vSwitch is designed so that any version of OVS userspace
interoperates with any version of the OVS kernel module.  This forward
and backward compatibility requires that userspace observe how the kernel
module parses received packets.  This is only possible in a
straightforward way when userspace adds kernel flows in reaction to
received packets.</li>
</ul>
<p>For more relevant information on the architecture of Open vSwitch, please
read &quot;The Design and Implementation of Open vSwitch&quot;, published in USENIX
NSDI 2015.</p>
</blockquote>
</div>
<div class="section" id="performance">
<h1>Performance</h1>
<p>Q: I just upgraded and I see a performance drop.  Why?</p>
<blockquote>
<p>A: The OVS kernel datapath may have been updated to a newer version than
the OVS userspace components.  Sometimes new versions of OVS kernel module
add functionality that is backwards compatible with older userspace
components but may cause a drop in performance with them.  Especially, if a
kernel module from OVS 2.1 or newer is paired with OVS userspace 1.10 or
older, there will be a performance drop for TCP traffic.</p>
<p>Updating the OVS userspace components to the latest released version should
fix the performance degradation.</p>
</blockquote>
<p>To get the best possible performance and functionality, it is recommended to
pair the same versions of the kernel module and OVS userspace.</p>
</div>
<div class="section" id="configuration-problems">
<h1>Configuration Problems</h1>
<p>Q: I created a bridge and added my Ethernet port to it, using commands like
these:</p>
<pre class="literal-block">
ovs-vsctl add-br br0
ovs-vsctl add-port br0 eth0
</pre>
<p>and as soon as I ran the &quot;add-port&quot; command I lost all connectivity through
eth0.  Help!</p>
<blockquote>
<p>A: A physical Ethernet device that is part of an Open vSwitch bridge should
not have an IP address.  If one does, then that IP address will not be
fully functional.</p>
<p>You can restore functionality by moving the IP address to an Open vSwitch
&quot;internal&quot; device, such as the network device named after the bridge
itself.  For example, assuming that eth0's IP address is 192.168.128.5, you
could run the commands below to fix up the situation:</p>
<pre class="literal-block">
$ ifconfig eth0 0.0.0.0
$ ifconfig br0 192.168.128.5
</pre>
<p>(If your only connection to the machine running OVS is through the IP
address in question, then you would want to run all of these commands on a
single command line, or put them into a script.)  If there were any
additional routes assigned to eth0, then you would also want to use
commands to adjust these routes to go through br0.</p>
<p>If you use DHCP to obtain an IP address, then you should kill the DHCP
client that was listening on the physical Ethernet interface (e.g. eth0)
and start one listening on the internal interface (e.g. br0).  You might
still need to manually clear the IP address from the physical interface
(e.g. with &quot;ifconfig eth0 0.0.0.0&quot;).</p>
<p>There is no compelling reason why Open vSwitch must work this way.
However, this is the way that the Linux kernel bridge module has always
worked, so it's a model that those accustomed to Linux bridging are already
used to.  Also, the model that most people expect is not implementable
without kernel changes on all the versions of Linux that Open vSwitch
supports.</p>
<p>By the way, this issue is not specific to physical Ethernet devices.  It
applies to all network devices except Open vSwitch &quot;internal&quot; devices.</p>
</blockquote>
<p>Q: I created a bridge and added a couple of Ethernet ports to it, using
commands like these:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl add-port br0 eth0
$ ovs-vsctl add-port br0 eth1
</pre>
<p>and now my network seems to have melted: connectivity is unreliable (even
connectivity that doesn't go through Open vSwitch), all the LEDs on my physical
switches are blinking, wireshark shows duplicated packets, and CPU usage is
very high.</p>
<blockquote>
<p>A: More than likely, you've looped your network.  Probably, eth0 and eth1
are connected to the same physical Ethernet switch.  This yields a scenario
where OVS receives a broadcast packet on eth0 and sends it out on eth1,
then the physical switch connected to eth1 sends the packet back on eth0,
and so on forever.  More complicated scenarios, involving a loop through
multiple switches, are possible too.</p>
<p>The solution depends on what you are trying to do:</p>
<ul>
<li><p class="first">If you added eth0 and eth1 to get higher bandwidth or higher reliability
between OVS and your physical Ethernet switch, use a bond.  The following
commands create br0 and then add eth0 and eth1 as a bond:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl add-bond br0 bond0 eth0 eth1
</pre>
<p>Bonds have tons of configuration options.  Please read the documentation
on the Port table in ovs-vswitchd.conf.db(5) for all the details.</p>
<p>Configuration for DPDK-enabled interfaces is slightly less
straightforward: see <a class="reference external" href="INSTALL.DPDK.rst">INSTALL.DPDK</a>.</p>
</li>
<li><p class="first">Perhaps you don't actually need eth0 and eth1 to be on the same bridge.
For example, if you simply want to be able to connect each of them to
virtual machines, then you can put each of them on a bridge of its own:</p>
<blockquote>
<p>$ ovs-vsctl add-br br0
$ ovs-vsctl add-port br0 eth0</p>
<p>$ ovs-vsctl add-br br1
$ ovs-vsctl add-port br1 eth1</p>
</blockquote>
<p>and then connect VMs to br0 and br1.  (A potential disadvantage is that
traffic cannot directly pass between br0 and br1.  Instead, it will go
out eth0 and come back in eth1, or vice versa.)</p>
</li>
<li><p class="first">If you have a redundant or complex network topology and you want to
prevent loops, turn on spanning tree protocol (STP).  The following
commands create br0, enable STP, and add eth0 and eth1 to the bridge.
The order is important because you don't want have to have a loop in your
network even transiently:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl set bridge br0 stp_enable=true
$ ovs-vsctl add-port br0 eth0
$ ovs-vsctl add-port br0 eth1
</pre>
<p>The Open vSwitch implementation of STP is not well tested.  Report any
bugs you observe, but if you'd rather avoid acting as a beta tester then
another option might be your best shot.</p>
</li>
</ul>
</blockquote>
<p>Q: I can't seem to use Open vSwitch in a wireless network.</p>
<blockquote>
<p>A: Wireless base stations generally only allow packets with the source MAC
address of NIC that completed the initial handshake.  Therefore, without
MAC rewriting, only a single device can communicate over a single wireless
link.</p>
<p>This isn't specific to Open vSwitch, it's enforced by the access point, so
the same problems will show up with the Linux bridge or any other way to do
bridging.</p>
</blockquote>
<p>Q: I can't seem to add my PPP interface to an Open vSwitch bridge.</p>
<blockquote>
A: PPP most commonly carries IP packets, but Open vSwitch works only with
Ethernet frames.  The correct way to interface PPP to an Ethernet network
is usually to use routing instead of switching.</blockquote>
<p>Q: Is there any documentation on the database tables and fields?</p>
<blockquote>
A: Yes.  ovs-vswitchd.conf.db(5) is a comprehensive reference.</blockquote>
<p>Q: When I run ovs-dpctl I no longer see the bridges I created.  Instead, I only
see a datapath called &quot;ovs-system&quot;.  How can I see datapath information about a
particular bridge?</p>
<blockquote>
A: In version 1.9.0, OVS switched to using a single datapath that is shared
by all bridges of that type.  The <tt class="docutils literal"><span class="pre">ovs-appctl</span> dpif/*</tt> commands provide
similar functionality that is scoped by the bridge.</blockquote>
<p>Q: I created a GRE port using ovs-vsctl so why can't I send traffic or see the
port in the datapath?</p>
<blockquote>
A: On Linux kernels before 3.11, the OVS GRE module and Linux GRE module
cannot be loaded at the same time. It is likely that on your system the
Linux GRE module is already loaded and blocking OVS (to confirm, check
dmesg for errors regarding GRE registration). To fix this, unload all GRE
modules that appear in lsmod as well as the OVS kernel module. You can then
reload the OVS module following the directions in the <a class="reference external" href="INSTALL.rst">installation guide</a>, which will ensure that dependencies are satisfied.</blockquote>
<p>Q: Open vSwitch does not seem to obey my packet filter rules.</p>
<blockquote>
<p>A: It depends on mechanisms and configurations you want to use.</p>
<p>You cannot usefully use typical packet filters, like iptables, on physical
Ethernet ports that you add to an Open vSwitch bridge.  This is because
Open vSwitch captures packets from the interface at a layer lower below
where typical packet-filter implementations install their hooks.  (This
actually applies to any interface of type &quot;system&quot; that you might add to an
Open vSwitch bridge.)</p>
<p>You can usefully use typical packet filters on Open vSwitch internal ports
as they are mostly ordinary interfaces from the point of view of packet
filters.</p>
<p>For example, suppose you create a bridge br0 and add Ethernet port eth0 to
it.  Then you can usefully add iptables rules to affect the internal
interface br0, but not the physical interface eth0.  (br0 is also where you
would add an IP address, as discussed elsewhere in the FAQ.)</p>
<p>For simple filtering rules, it might be possible to achieve similar results
by installing appropriate OpenFlow flows instead.  The OVS conntrack
feature (see the &quot;ct&quot; action in ovs-ofctl(8)) can implement a stateful
firewall.</p>
<p>If the use of a particular packet filter setup is essential, Open vSwitch
might not be the best choice for you.  On Linux, you might want to consider
using the Linux Bridge.  (This is the only choice if you want to use
ebtables rules.)  On NetBSD, you might want to consider using the bridge(4)
with BRIDGE_IPF option.</p>
</blockquote>
<p>Q: It seems that Open vSwitch does nothing when I removed a port and then
immediately put it back.  For example, consider that p1 is a port of
<tt class="docutils literal">type=internal</tt>:</p>
<pre class="literal-block">
 $ ovs-vsctl del-port br0 p1 -- \
     add-port br0 p1 -- \
     set interface p1 type=internal

A: It's an expected behaviour.

If del-port and add-port happen in a single OVSDB transaction as your
example, Open vSwitch always &quot;skips&quot; the intermediate steps.  Even if they
are done in multiple transactions, it's still allowed for Open vSwitch to
skip the intermediate steps and just implement the overall effect.  In both
cases, your example would be turned into a no-op.

If you want to make Open vSwitch actually destroy and then re-create the
port for some side effects like resetting kernel setting for the
corresponding interface, you need to separate operations into multiple
OVSDB transactions and ensure that at least the first one does not have
``--no-wait``.  In the following example, the first ovs-vsctl will block
until Open vSwitch reloads the new configuration and removes the port::

    $ ovs-vsctl del-port br0 p1
    $ ovs-vsctl add-port br0 p1 -- \
        set interface p1 type=internal
</pre>
<p>Q: I want to add thousands of ports to an Open vSwitch bridge, but it takes too
long (minutes or hours) to do it with ovs-vsctl.  How can I do it faster?</p>
<blockquote>
<p>A: If you add them one at a time with ovs-vsctl, it can take a long time to
add thousands of ports to an Open vSwitch bridge.  This is because every
invocation of ovs-vsctl first reads the current configuration from OVSDB.
As the number of ports grows, this starts to take an appreciable amount of
time, and when it is repeated thousands of times the total time becomes
significant.</p>
<p>The solution is to add the ports in one invocation of ovs-vsctl (or a small
number of them).  For example, using bash:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ cmds=; for i in {1..5000}; do cmds+=&quot; -- add-port br0 p$i&quot;; done
$ ovs-vsctl $cmds
</pre>
<p>takes seconds, not minutes or hours, in the OVS sandbox environment.</p>
</blockquote>
<p>Q: I created a bridge named br0.  My bridge shows up in &quot;ovs-vsctl show&quot;, but
&quot;ovs-ofctl show br0&quot; just prints &quot;br0 is not a bridge or a socket&quot;.</p>
<blockquote>
<p>A: Open vSwitch wasn't able to create the bridge.  Check the ovs-vswitchd
log for details (Debian and Red Hat packaging for Open vSwitch put it in
/var/log/openvswitch/ovs-vswitchd.log).</p>
<p>In general, the Open vSwitch database reflects the desired configuration
state.  ovs-vswitchd monitors the database and, when it changes,
reconfigures the system to reflect the new desired state.  This normally
happens very quickly.  Thus, a discrepancy between the database and the
actual state indicates that ovs-vswitchd could not implement the
configuration, and so one should check the log to find out why.  (Another
possible cause is that ovs-vswitchd is not running.  This will make
ovs-vsctl commands hang, if they change the configuration, unless one
specifies <tt class="docutils literal"><span class="pre">--no-wait</span></tt>.)</p>
</blockquote>
<p>Q: I have a bridge br0.  I added a new port vif1.0, and it shows up in
&quot;ovs-vsctl show&quot;, but &quot;ovs-vsctl list port&quot; says that it has OpenFlow port
(&quot;ofport&quot;) -1, and &quot;ovs-ofctl show br0&quot; doesn't show vif1.0 at all.</p>
<blockquote>
<p>A: Open vSwitch wasn't able to create the port.  Check the ovs-vswitchd log
for details (Debian and Red Hat packaging for Open vSwitch put it in
/var/log/openvswitch/ovs-vswitchd.log).  Please see the previous question
for more information.</p>
<p>You may want to upgrade to Open vSwitch 2.3 (or later), in which ovs-vsctl
will immediately report when there is an issue creating a port.</p>
</blockquote>
<p>Q: I created a tap device tap0, configured an IP address on it, and added it to
a bridge, like this:</p>
<pre class="literal-block">
$ tunctl -t tap0
$ ifconfig tap0 192.168.0.123
$ ovs-vsctl add-br br0
$ ovs-vsctl add-port br0 tap0
</pre>
<p>I expected that I could then use this IP address to contact other hosts on the
network, but it doesn't work.  Why not?</p>
<blockquote>
<p>A: The short answer is that this is a misuse of a &quot;tap&quot; device.  Use an
&quot;internal&quot; device implemented by Open vSwitch, which works differently and
is designed for this use.  To solve this problem with an internal device,
instead run:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl add-port br0 int0 -- set Interface int0 type=internal
$ ifconfig int0 192.168.0.123
</pre>
<p>Even more simply, you can take advantage of the internal port that every
bridge has under the name of the bridge:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ifconfig br0 192.168.0.123
</pre>
<p>In more detail, a &quot;tap&quot; device is an interface between the Linux (or BSD)
network stack and a user program that opens it as a socket.  When the &quot;tap&quot;
device transmits a packet, it appears in the socket opened by the userspace
program.  Conversely, when the userspace program writes to the &quot;tap&quot;
socket, the kernel TCP/IP stack processes the packet as if it had been
received by the &quot;tap&quot; device.</p>
<p>Consider the configuration above.  Given this configuration, if you &quot;ping&quot;
an IP address in the 192.168.0.x subnet, the Linux kernel routing stack
will transmit an ARP on the tap0 device.  Open vSwitch userspace treats
&quot;tap&quot; devices just like any other network device; that is, it doesn't open
them as &quot;tap&quot; sockets.  That means that the ARP packet will simply get
dropped.</p>
<p>You might wonder why the Open vSwitch kernel module doesn't intercept the
ARP packet and bridge it.  After all, Open vSwitch intercepts packets on
other devices.  The answer is that Open vSwitch only intercepts <em>received</em>
packets, but this is a packet being transmitted.  The same thing happens
for all other types of network devices, except for Open vSwitch &quot;internal&quot;
ports.  If you, for example, add a physical Ethernet port to an OVS bridge,
configure an IP address on a physical Ethernet port, and then issue a
&quot;ping&quot; to an address in that subnet, the same thing happens: an ARP gets
transmitted on the physical Ethernet port and Open vSwitch never sees it.
(You should not do that, as documented at the beginning of this section.)</p>
<p>It can make sense to add a &quot;tap&quot; device to an Open vSwitch bridge, if some
userspace program (other than Open vSwitch) has opened the tap socket.
This is the case, for example, if the &quot;tap&quot; device was created by KVM (or
QEMU) to simulate a virtual NIC.  In such a case, when OVS bridges a packet
to the &quot;tap&quot; device, the kernel forwards that packet to KVM in userspace,
which passes it along to the VM, and in the other direction, when the VM
sends a packet, KVM writes it to the &quot;tap&quot; socket, which causes OVS to
receive it and bridge it to the other OVS ports.  Please note that in such
a case no IP address is configured on the &quot;tap&quot; device (there is normally
an IP address configured in the virtual NIC inside the VM, but this is not
visible to the host Linux kernel or to Open vSwitch).</p>
<p>There is one special case in which Open vSwitch does directly read and
write &quot;tap&quot; sockets.  This is an implementation detail of the Open vSwitch
userspace switch, which implements its &quot;internal&quot; ports as Linux (or BSD)
&quot;tap&quot; sockets.  In such a userspace switch, OVS receives packets sent on
the &quot;tap&quot; device used to implement an &quot;internal&quot; port by reading the
associated &quot;tap&quot; socket, and bridges them to the rest of the switch.  In
the other direction, OVS transmits packets bridged to the &quot;internal&quot; port
by writing them to the &quot;tap&quot; socket, causing them to be processed by the
kernel TCP/IP stack as if they had been received on the &quot;tap&quot; device.
Users should not need to be concerned with this implementation detail.</p>
<p>Open vSwitch has a network device type called &quot;tap&quot;.  This is intended only
for implementing &quot;internal&quot; ports in the OVS userspace switch and should
not be used otherwise.  In particular, users should not configure KVM &quot;tap&quot;
devices as type &quot;tap&quot; (use type &quot;system&quot;, the default, instead).</p>
</blockquote>
<p>Q: I observe packet loss at the beginning of RFC2544 tests on a server running
few hundred container apps bridged to OVS with traffic generated by HW traffic
generator.  How can I fix this?</p>
<blockquote>
<p>A: This is expected behavior on virtual switches.  RFC2544 tests were
designed for hardware switches, which don't have caches on the fastpath
that need to be heated.  Traffic generators in order to prime the switch
use learning phase to heat the caches before sending the actual traffic in
test phase.  In case of OVS the cache is flushed quickly and to accommodate
the traffic generator's delay between learning and test phase, the max-idle
timeout settings should be changed to 50000 ms.:</p>
<pre class="literal-block">
$ ovs-vsctl --no-wait set Open_vSwitch . other_config:max-idle=50000
</pre>
</blockquote>
<p>Q: How can I configure the bridge internal interface MTU? Why does Open vSwitch
keep changing internal ports MTU?</p>
<blockquote>
<p>A: By default Open vSwitch overrides the internal interfaces (e.g. br0)
MTU.  If you have just an internal interface (e.g. br0) and a physical
interface (e.g. eth0), then every change in MTU to eth0 will be reflected
to br0.  Any manual MTU configuration using <cite>ip</cite> or <cite>ifconfig</cite> on internal
interfaces is going to be overridden by Open vSwitch to match the current
bridge minimum.</p>
<p>Sometimes this behavior is not desirable, for example with tunnels.  The
MTU of an internal interface can be explicitly set using the following
command:</p>
<pre class="literal-block">
$ ovs-vsctl set int br0 mtu_request=1450
</pre>
<p>After this, Open vSwitch will configure br0 MTU to 1450.  Since this
setting is in the database it will be persistent (compared to what happens
with <cite>ip</cite> or <cite>ifconfig</cite>).</p>
<p>The MTU configuration can be removed to restore the default behavior
with:</p>
<pre class="literal-block">
$ ovs-vsctl set int br0 mtu_request=[]
</pre>
<p>The mtu_request column can be used to configure MTU even for physical
interfaces (e.g. eth0).</p>
</blockquote>
</div>
<div class="section" id="qos">
<h1>QOS</h1>
<p>Q: Does OVS support Quality of Service (QoS)?</p>
<blockquote>
<p>A: Yes.  For traffic that egresses from a switch, OVS supports traffic
shaping; for traffic that ingresses into a switch, OVS support policing.
Policing is a simple form of quality-of-service that simply drops packets
received in excess of the configured rate.  Due to its simplicity, policing
is usually less accurate and less effective than egress traffic shaping,
which queues packets.</p>
<p>Keep in mind that ingress and egress are from the perspective of the
switch.  That means that egress shaping limits the rate at which traffic is
allowed to transmit from a physical interface, but not the rate at which
traffic will be received on a virtual machine's VIF.  For ingress policing,
the behavior is the opposite.</p>
</blockquote>
<p>Q: How do I configure egress traffic shaping?</p>
<blockquote>
<p>A: Suppose that you want to set up bridge br0 connected to physical
Ethernet port eth0 (a 1 Gbps device) and virtual machine interfaces vif1.0
and vif2.0, and that you want to limit traffic from vif1.0 to eth0 to 10
Mbps and from vif2.0 to eth0 to 20 Mbps.  Then, you could configure the
bridge this way:</p>
<pre class="literal-block">
$ ovs-vsctl -- \
  add-br br0 -- \
  add-port br0 eth0 -- \
  add-port br0 vif1.0 -- set interface vif1.0 ofport_request=5 -- \
  add-port br0 vif2.0 -- set interface vif2.0 ofport_request=6 -- \
  set port eth0 qos=&#64;newqos -- \
  --id=&#64;newqos create qos type=linux-htb \
      other-config:max-rate=1000000000 \
      queues:123=&#64;vif10queue \
      queues:234=&#64;vif20queue -- \
  --id=&#64;vif10queue create queue other-config:max-rate=10000000 -- \
  --id=&#64;vif20queue create queue other-config:max-rate=20000000
</pre>
<p>At this point, bridge br0 is configured with the ports and eth0 is
configured with the queues that you need for QoS, but nothing is actually
directing packets from vif1.0 or vif2.0 to the queues that we have set up
for them.  That means that all of the packets to eth0 are going to the
&quot;default queue&quot;, which is not what we want.</p>
<p>We use OpenFlow to direct packets from vif1.0 and vif2.0 to the queues
reserved for them:</p>
<pre class="literal-block">
$ ovs-ofctl add-flow br0 in_port=5,actions=set_queue:123,normal
$ ovs-ofctl add-flow br0 in_port=6,actions=set_queue:234,normal
</pre>
<p>Each of the above flows matches on the input port, sets up the appropriate
queue (123 for vif1.0, 234 for vif2.0), and then executes the &quot;normal&quot;
action, which performs the same switching that Open vSwitch would have done
without any OpenFlow flows being present.  (We know that vif1.0 and vif2.0
have OpenFlow port numbers 5 and 6, respectively, because we set their
ofport_request columns above.  If we had not done that, then we would have
needed to find out their port numbers before setting up these flows.)</p>
<p>Now traffic going from vif1.0 or vif2.0 to eth0 should be rate-limited.</p>
<p>By the way, if you delete the bridge created by the above commands, with:</p>
<pre class="literal-block">
$ ovs-vsctl del-br br0
</pre>
<p>then that will leave one unreferenced QoS record and two unreferenced Queue
records in the Open vSwich database.  One way to clear them out, assuming
you don't have other QoS or Queue records that you want to keep, is:</p>
<pre class="literal-block">
$ ovs-vsctl -- --all destroy QoS -- --all destroy Queue
</pre>
<p>If you do want to keep some QoS or Queue records, or the Open vSwitch you
are using is older than version 1.8 (which added the <tt class="docutils literal"><span class="pre">--all</span></tt> option),
then you will have to destroy QoS and Queue records individually.</p>
</blockquote>
<p>Q: How do I configure ingress policing?</p>
<blockquote>
<p>A: A policing policy can be configured on an interface to drop packets that
arrive at a higher rate than the configured value.  For example, the
following commands will rate-limit traffic that vif1.0 may generate to
10Mbps:</p>
<blockquote>
$ ovs-vsctl set interface vif1.0 ingress_policing_rate=10000
$ ovs-vsctl set interface vif1.0 ingress_policing_burst=8000</blockquote>
<p>Traffic policing can interact poorly with some network protocols and can
have surprising results.  The &quot;Ingress Policing&quot; section of
ovs-vswitchd.conf.db(5) discusses the issues in greater detail.</p>
</blockquote>
<p>Q: I configured Quality of Service (QoS) in my OpenFlow network by adding
records to the QoS and Queue table, but the results aren't what I expect.</p>
<blockquote>
<p>A: Did you install OpenFlow flows that use your queues?  This is the
primary way to tell Open vSwitch which queues you want to use.  If you
don't do this, then the default queue will be used, which will probably not
have the effect you want.</p>
<p>Refer to the previous question for an example.</p>
</blockquote>
<p>Q: I'd like to take advantage of some QoS feature that Open vSwitch doesn't yet
support.  How do I do that?</p>
<blockquote>
A: Open vSwitch does not implement QoS itself.  Instead, it can configure
some, but not all, of the QoS features built into the Linux kernel.  If you
need some QoS feature that OVS cannot configure itself, then the first step
is to figure out whether Linux QoS supports that feature.  If it does, then
you can submit a patch to support Open vSwitch configuration for that
feature, or you can use &quot;tc&quot; directly to configure the feature in Linux.
(If Linux QoS doesn't support the feature you want, then first you have to
add that support to Linux.)</blockquote>
<p>Q: I configured QoS, correctly, but my measurements show that it isn't working
as well as I expect.</p>
<blockquote>
<p>A: With the Linux kernel, the Open vSwitch implementation of QoS has two
aspects:</p>
<ul>
<li><p class="first">Open vSwitch configures a subset of Linux kernel QoS features, according
to what is in OVSDB.  It is possible that this code has bugs.  If you
believe that this is so, then you can configure the Linux traffic control
(QoS) stack directly with the &quot;tc&quot; program.  If you get better results
that way, you can send a detailed bug report to <a class="reference external" href="mailto:bugs&#64;openvswitch.org">bugs&#64;openvswitch.org</a>.</p>
<p>It is certain that Open vSwitch cannot configure every Linux kernel QoS
feature.  If you need some feature that OVS cannot configure, then you
can also use &quot;tc&quot; directly (or add that feature to OVS).</p>
</li>
<li><p class="first">The Open vSwitch implementation of OpenFlow allows flows to be directed
to particular queues.  This is pretty simple and unlikely to have serious
bugs at this point.</p>
</li>
</ul>
<p>However, most problems with QoS on Linux are not bugs in Open vSwitch at
all.  They tend to be either configuration errors (please see the earlier
questions in this section) or issues with the traffic control (QoS) stack
in Linux.  The Open vSwitch developers are not experts on Linux traffic
control.  We suggest that, if you believe you are encountering a problem
with Linux traffic control, that you consult the tc manpages (e.g. tc(8),
tc-htb(8), tc-hfsc(8)), web resources (e.g. <a class="reference external" href="http://lartc.org/">http://lartc.org/</a>), or mailing
lists (e.g. <a class="reference external" href="http://vger.kernel.org/vger-lists.html#netdev">http://vger.kernel.org/vger-lists.html#netdev</a>).</p>
</blockquote>
<p>Q: Does Open vSwitch support OpenFlow meters?</p>
<blockquote>
A: Since version 2.0, Open vSwitch has OpenFlow protocol support for
OpenFlow meters.  There is no implementation of meters in the Open vSwitch
software switch (neither the kernel-based nor userspace switches).</blockquote>
</div>
<div class="section" id="vlans">
<h1>VLANs</h1>
<p>Q: What's a VLAN?</p>
<blockquote>
<p>A: At the simplest level, a VLAN (short for &quot;virtual LAN&quot;) is a way to
partition a single switch into multiple switches.  Suppose, for example,
that you have two groups of machines, group A and group B.  You want the
machines in group A to be able to talk to each other, and you want the
machine in group B to be able to talk to each other, but you don't want the
machines in group A to be able to talk to the machines in group B.  You can
do this with two switches, by plugging the machines in group A into one
switch and the machines in group B into the other switch.</p>
<p>If you only have one switch, then you can use VLANs to do the same thing,
by configuring the ports for machines in group A as VLAN &quot;access ports&quot; for
one VLAN and the ports for group B as &quot;access ports&quot; for a different VLAN.
The switch will only forward packets between ports that are assigned to the
same VLAN, so this effectively subdivides your single switch into two
independent switches, one for each group of machines.</p>
<p>So far we haven't said anything about VLAN headers.  With access ports,
like we've described so far, no VLAN header is present in the Ethernet
frame.  This means that the machines (or switches) connected to access
ports need not be aware that VLANs are involved, just like in the case
where we use two different physical switches.</p>
<p>Now suppose that you have a whole bunch of switches in your network,
instead of just one, and that some machines in group A are connected
directly to both switches 1 and 2.  To allow these machines to talk to each
other, you could add an access port for group A's VLAN to switch 1 and
another to switch 2, and then connect an Ethernet cable between those
ports.  That works fine, but it doesn't scale well as the number of
switches and the number of VLANs increases, because you use up a lot of
valuable switch ports just connecting together your VLANs.</p>
<p>This is where VLAN headers come in.  Instead of using one cable and two
ports per VLAN to connect a pair of switches, we configure a port on each
switch as a VLAN &quot;trunk port&quot;.  Packets sent and received on a trunk port
carry a VLAN header that says what VLAN the packet belongs to, so that only
two ports total are required to connect the switches, regardless of the
number of VLANs in use.  Normally, only switches (either physical or
virtual) are connected to a trunk port, not individual hosts, because
individual hosts don't expect to see a VLAN header in the traffic that they
receive.</p>
<p>None of the above discussion says anything about particular VLAN numbers.
This is because VLAN numbers are completely arbitrary.  One must only
ensure that a given VLAN is numbered consistently throughout a network and
that different VLANs are given different numbers.  (That said, VLAN 0 is
usually synonymous with a packet that has no VLAN header, and VLAN 4095 is
reserved.)</p>
</blockquote>
<p>Q: VLANs don't work.</p>
<blockquote>
<p>A: Many drivers in Linux kernels before version 3.3 had VLAN-related bugs.
If you are having problems with VLANs that you suspect to be driver
related, then you have several options:</p>
<ul>
<li><p class="first">Upgrade to Linux 3.3 or later.</p>
</li>
<li><p class="first">Build and install a fixed version of the particular driver that is
causing trouble, if one is available.</p>
</li>
<li><p class="first">Use a NIC whose driver does not have VLAN problems.</p>
</li>
<li><p class="first">Use &quot;VLAN splinters&quot;, a feature in Open vSwitch 1.4 upto 2.5 that works
around bugs in kernel drivers.  To enable VLAN splinters on interface
eth0, use the command:</p>
<pre class="literal-block">
$ ovs-vsctl set interface eth0 other-config:enable-vlan-splinters=true
</pre>
<p>For VLAN splinters to be effective, Open vSwitch must know which VLANs
are in use.  See the &quot;VLAN splinters&quot; section in the Interface table in
ovs-vswitchd.conf.db(5) for details on how Open vSwitch infers in-use
VLANs.</p>
<p>VLAN splinters increase memory use and reduce performance, so use them
only if needed.</p>
</li>
<li><p class="first">Apply the &quot;vlan workaround&quot; patch from the XenServer kernel patch queue,
build Open vSwitch against this patched kernel, and then use
ovs-vlan-bug-workaround(8) to enable the VLAN workaround for each
interface whose driver is buggy.</p>
<p>(This is a nontrivial exercise, so this option is included only for
completeness.)</p>
</li>
</ul>
<p>It is not always easy to tell whether a Linux kernel driver has buggy VLAN
support.  The ovs-vlan-test(8) and ovs-test(8) utilities can help you test.
See their manpages for details.  Of the two utilities, ovs-test(8) is newer
and more thorough, but ovs-vlan-test(8) may be easier to use.</p>
</blockquote>
<p>Q: VLANs still don't work.  I've tested the driver so I know that it's OK.</p>
<blockquote>
A: Do you have VLANs enabled on the physical switch that OVS is attached
to?  Make sure that the port is configured to trunk the VLAN or VLANs that
you are using with OVS.</blockquote>
<p>Q: Outgoing VLAN-tagged traffic goes through OVS to my physical switch
and to its destination host, but OVS seems to drop incoming return
traffic.</p>
<blockquote>
<p>A: It's possible that you have the VLAN configured on your physical switch
as the &quot;native&quot; VLAN.  In this mode, the switch treats incoming packets
either tagged with the native VLAN or untagged as part of the native VLAN.
It may also send outgoing packets in the native VLAN without a VLAN tag.</p>
<p>If this is the case, you have two choices:</p>
<ul>
<li><p class="first">Change the physical switch port configuration to tag packets it forwards
to OVS with the native VLAN instead of forwarding them untagged.</p>
</li>
<li><p class="first">Change the OVS configuration for the physical port to a native VLAN mode.
For example, the following sets up a bridge with port eth0 in
&quot;native-tagged&quot; mode in VLAN 9:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0 $ ovs-vsctl add-port br0 eth0 tag=9
vlan_mode=native-tagged
</pre>
<p>In this situation, &quot;native-untagged&quot; mode will probably work equally
well.  Refer to the documentation for the Port table in
ovs-vswitchd.conf.db(5) for more information.</p>
</li>
</ul>
</blockquote>
<p>Q: I added a pair of VMs on different VLANs, like this:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl add-port br0 eth0
$ ovs-vsctl add-port br0 tap0 tag=9
$ ovs-vsctl add-port br0 tap1 tag=10
</pre>
<p>but the VMs can't access each other, the external network, or the Internet.</p>
<blockquote>
<p>A: It is to be expected that the VMs can't access each other.  VLANs are a
means to partition a network.  When you configured tap0 and tap1 as access
ports for different VLANs, you indicated that they should be isolated from
each other.</p>
<p>As for the external network and the Internet, it seems likely that the
machines you are trying to access are not on VLAN 9 (or 10) and that the
Internet is not available on VLAN 9 (or 10).</p>
</blockquote>
<p>Q: I added a pair of VMs on the same VLAN, like this:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl add-port br0 eth0
$ ovs-vsctl add-port br0 tap0 tag=9
$ ovs-vsctl add-port br0 tap1 tag=9
</pre>
<p>The VMs can access each other, but not the external network or the Internet.</p>
<blockquote>
A: It seems likely that the machines you are trying to access in the
external network are not on VLAN 9 and that the Internet is not available
on VLAN 9.  Also, ensure VLAN 9 is set up as an allowed trunk VLAN on the
upstream switch port to which eth0 is connected.</blockquote>
<p>Q: Can I configure an IP address on a VLAN?</p>
<blockquote>
<p>A: Yes.  Use an &quot;internal port&quot; configured as an access port.  For example,
the following configures IP address 192.168.0.7 on VLAN 9.  That is, OVS
will forward packets from eth0 to 192.168.0.7 only if they have an 802.1Q
header with VLAN 9.  Conversely, traffic forwarded from 192.168.0.7 to eth0
will be tagged with an 802.1Q header with VLAN 9:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl add-port br0 eth0
$ ovs-vsctl add-port br0 vlan9 tag=9 \
    -- set interface vlan9 type=internal
$ ifconfig vlan9 192.168.0.7
</pre>
<p>See also the following question.</p>
</blockquote>
<p>Q: I configured one IP address on VLAN 0 and another on VLAN 9, like this:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl add-port br0 eth0
$ ifconfig br0 192.168.0.5
$ ovs-vsctl add-port br0 vlan9 tag=9 -- set interface vlan9 type=internal
$ ifconfig vlan9 192.168.0.9
</pre>
<p>but other hosts that are only on VLAN 0 can reach the IP address configured on
VLAN 9.  What's going on?</p>
<blockquote>
<p>A: <a class="reference external" href="https://tools.ietf.org/html/rfc1122#section-3.3.4.2">RFC 1122 section 3.3.4.2 &quot;Multihoming Requirements&quot;</a> describes two
approaches to IP address handling in Internet hosts:</p>
<ul class="simple">
<li>In the &quot;Strong ES Model&quot;, where an ES is a host (&quot;End System&quot;), an IP
address is primarily associated with a particular interface.  The host
discards packets that arrive on interface A if they are destined for an
IP address that is configured on interface B.  The host never sends
packets from interface A using a source address configured on interface
B.</li>
<li>In the &quot;Weak ES Model&quot;, an IP address is primarily associated with a
host.  The host accepts packets that arrive on any interface if they are
destined for any of the host's IP addresses, even if the address is
configured on some interface other than the one on which it arrived.  The
host does not restrict itself to sending packets from an IP address
associated with the originating interface.</li>
</ul>
<p>Linux uses the weak ES model.  That means that when packets destined to the
VLAN 9 IP address arrive on eth0 and are bridged to br0, the kernel IP
stack accepts them there for the VLAN 9 IP address, even though they were
not received on vlan9, the network device for vlan9.</p>
<p>To simulate the strong ES model on Linux, one may add iptables rule to
filter packets based on source and destination address and adjust ARP
configuration with sysctls.</p>
<p>BSD uses the strong ES model.</p>
</blockquote>
<p>Q: My OpenFlow controller doesn't see the VLANs that I expect.</p>
<blockquote>
<p>A: The configuration for VLANs in the Open vSwitch database (e.g. via
ovs-vsctl) only affects traffic that goes through Open vSwitch's
implementation of the OpenFlow &quot;normal switching&quot; action.  By default, when
Open vSwitch isn't connected to a controller and nothing has been manually
configured in the flow table, all traffic goes through the &quot;normal
switching&quot; action.  But, if you set up OpenFlow flows on your own, through
a controller or using ovs-ofctl or through other means, then you have to
implement VLAN handling yourself.</p>
<p>You can use &quot;normal switching&quot; as a component of your OpenFlow actions,
e.g. by putting &quot;normal&quot; into the lists of actions on ovs-ofctl or by
outputting to OFPP_NORMAL from an OpenFlow controller.  In situations where
this is not suitable, you can implement VLAN handling yourself, e.g.:</p>
<ul class="simple">
<li>If a packet comes in on an access port, and the flow table needs to send
it out on a trunk port, then the flow can add the appropriate VLAN tag
with the &quot;mod_vlan_vid&quot; action.</li>
<li>If a packet comes in on a trunk port, and the flow table needs to send it
out on an access port, then the flow can strip the VLAN tag with the
&quot;strip_vlan&quot; action.</li>
</ul>
</blockquote>
<p>Q: I configured ports on a bridge as access ports with different VLAN tags,
like this:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl set-controller br0 tcp:192.168.0.10:6653
$ ovs-vsctl add-port br0 eth0
$ ovs-vsctl add-port br0 tap0 tag=9
$ ovs-vsctl add-port br0 tap1 tag=10
</pre>
<p>but the VMs running behind tap0 and tap1 can still communicate, that is, they
are not isolated from each other even though they are on different VLANs.</p>
<blockquote>
A: Do you have a controller configured on br0 (as the commands above do)?
If so, then this is a variant on the previous question, &quot;My OpenFlow
controller doesn't see the VLANs that I expect,&quot; and you can refer to the
answer there for more information.</blockquote>
<p>Q: How MAC learning works with VLANs?</p>
<blockquote>
A: Open vSwitch implements Independent VLAN Learning (IVL) for
<tt class="docutils literal">OFPP_NORMAL</tt> action, e.g. it logically has separate learning tables for
each VLANs.</blockquote>
</div>
<div class="section" id="vxlans">
<h1>VXLANs</h1>
<p>Q: What's a VXLAN?</p>
<blockquote>
A: VXLAN stands for Virtual eXtensible Local Area Network, and is a means
to solve the scaling challenges of VLAN networks in a multi-tenant
environment. VXLAN is an overlay network which transports an L2 network
over an existing L3 network. For more information on VXLAN, please see <a class="reference external" href="http://tools.ietf.org/html/rfc7348">RFC
7348</a>.</blockquote>
<p>Q: How much of the VXLAN protocol does Open vSwitch currently support?</p>
<blockquote>
A: Open vSwitch currently supports the framing format for packets on the
wire. There is currently no support for the multicast aspects of VXLAN.  To
get around the lack of multicast support, it is possible to pre-provision
MAC to IP address mappings either manually or from a controller.</blockquote>
<p>Q: What destination UDP port does the VXLAN implementation in Open vSwitch
use?</p>
<blockquote>
<p>A: By default, Open vSwitch will use the assigned IANA port for VXLAN,
which is 4789. However, it is possible to configure the destination UDP
port manually on a per-VXLAN tunnel basis. An example of this configuration
is provided below.:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl add-port br0 vxlan1 -- set interface vxlan1 type=vxlan \
    options:remote_ip=192.168.1.2 options:key=flow options:dst_port=8472
</pre>
</blockquote>
</div>
<div class="section" id="using-openflow">
<h1>Using OpenFlow</h1>
<p>Q: What versions of OpenFlow does Open vSwitch support?</p>
<blockquote>
<p>A: The following table lists the versions of OpenFlow supported by each
version of Open vSwitch:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Open vSwitch</th>
<th class="head">OF1.0</th>
<th class="head">OF1.1</th>
<th class="head">OF1.2</th>
<th class="head">OF1.3</th>
<th class="head">OF1.4</th>
<th class="head">OF1.5</th>
<th class="head">OF1.6</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1.9 and earlier</td>
<td>yes</td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>---</td>
</tr>
<tr><td>1.10</td>
<td>yes</td>
<td>---</td>
<td>(*)</td>
<td>(*)</td>
<td>---</td>
<td>---</td>
<td>---</td>
</tr>
<tr><td>1.11</td>
<td>yes</td>
<td>---</td>
<td>(*)</td>
<td>(*)</td>
<td>---</td>
<td>---</td>
<td>---</td>
</tr>
<tr><td>2.0</td>
<td>yes</td>
<td>(*)</td>
<td>(*)</td>
<td>(*)</td>
<td>---</td>
<td>---</td>
<td>---</td>
</tr>
<tr><td>2.1</td>
<td>yes</td>
<td>(*)</td>
<td>(*)</td>
<td>(*)</td>
<td>---</td>
<td>---</td>
<td>---</td>
</tr>
<tr><td>2.2</td>
<td>yes</td>
<td>(*)</td>
<td>(*)</td>
<td>(*)</td>
<td>(%)</td>
<td>(*)</td>
<td>---</td>
</tr>
<tr><td>2.3</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>(*)</td>
<td>(*)</td>
<td>---</td>
</tr>
<tr><td>2.4</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>(*)</td>
<td>(*)</td>
<td>---</td>
</tr>
<tr><td>2.5</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>(*)</td>
<td>(*)</td>
<td>(*)</td>
</tr>
</tbody>
</table>
<p>(*) Supported, with one or more missing features.
(%) Experimental, unsafe implementation.</p>
<p>Open vSwitch 2.3 enables OpenFlow 1.0, 1.1, 1.2, and 1.3 by default in
ovs-vswitchd.  In Open vSwitch 1.10 through 2.2, OpenFlow 1.1, 1.2, and 1.3
must be enabled manually in ovs-vswitchd.</p>
<p>Some versions of OpenFlow are supported with missing features and therefore
not enabled by default: OpenFlow 1.4 and 1.5, in Open vSwitch 2.3 and
later, as well as OpenFlow 1.6 in Open vSwitch 2.5 and later.  Also, the
OpenFlow 1.6 specification is still under development and thus subject to
change.</p>
<p>In any case, the user may override the default:</p>
<ul>
<li><p class="first">To enable OpenFlow 1.0, 1.1, 1.2, and 1.3 on bridge br0:</p>
<pre class="literal-block">
$ ovs-vsctl set bridge br0 \
    protocols=OpenFlow10,OpenFlow11,OpenFlow12,OpenFlow13
</pre>
</li>
<li><p class="first">To enable OpenFlow 1.0, 1.1, 1.2, 1.3, 1.4, and 1.5 on bridge br0:</p>
<pre class="literal-block">
$ ovs-vsctl set bridge br0 \
    protocols=OpenFlow10,OpenFlow11,OpenFlow12,OpenFlow13,OpenFlow14,OpenFlow15
</pre>
</li>
<li><p class="first">To enable only OpenFlow 1.0 on bridge br0:</p>
<pre class="literal-block">
$ ovs-vsctl set bridge br0 protocols=OpenFlow10
</pre>
</li>
</ul>
<p>All current versions of ovs-ofctl enable only OpenFlow 1.0 by default.  Use
the -O option to enable support for later versions of OpenFlow in
ovs-ofctl.  For example:</p>
<pre class="literal-block">
$ ovs-ofctl -O OpenFlow13 dump-flows br0
</pre>
<p>(Open vSwitch 2.2 had an experimental implementation of OpenFlow 1.4 that
could cause crashes.  We don't recommend enabling it.)</p>
<p>The <a class="reference external" href="OPENFLOW.rst">OpenFlow guide</a> tracks support for OpenFlow 1.1 and
later features.  When support for OpenFlow 1.4 and 1.5 is solidly
implemented, Open vSwitch will enable those version by default.</p>
</blockquote>
<p>Q: Does Open vSwitch support MPLS?</p>
<blockquote>
<p>A: Before version 1.11, Open vSwitch did not support MPLS.  That is, these
versions can match on MPLS Ethernet types, but they cannot match, push, or
pop MPLS labels, nor can they look past MPLS labels into the encapsulated
packet.</p>
<p>Open vSwitch versions 1.11, 2.0, and 2.1 have very minimal support for
MPLS.  With the userspace datapath only, these versions can match, push, or
pop a single MPLS label, but they still cannot look past MPLS labels (even
after popping them) into the encapsulated packet.  Kernel datapath support
is unchanged from earlier versions.</p>
<p>Open vSwitch version 2.3 can match, push, or pop a single MPLS label and
look past the MPLS label into the encapsulated packet.  Both userspace and
kernel datapaths will be supported, but MPLS processing always happens in
userspace either way, so kernel datapath performance will be disappointing.</p>
<p>Open vSwitch version 2.4 can match, push, or pop up to 3 MPLS labels and
look past the MPLS label into the encapsulated packet.  It will have kernel
support for MPLS, yielding improved performance.</p>
</blockquote>
<p>Q: I'm getting &quot;error type 45250 code 0&quot;.  What's that?</p>
<blockquote>
<p>A: This is a Open vSwitch extension to OpenFlow error codes.  Open vSwitch
uses this extension when it must report an error to an OpenFlow controller
but no standard OpenFlow error code is suitable.</p>
<p>Open vSwitch logs the errors that it sends to controllers, so the easiest
thing to do is probably to look at the ovs-vswitchd log to find out what
the error was.</p>
<p>If you want to dissect the extended error message yourself, the format is
documented in include/openflow/nicira-ext.h in the Open vSwitch source
distribution.  The extended error codes are documented in
include/openvswitch/ofp-errors.h.</p>
</blockquote>
<p>Q: Some of the traffic that I'd expect my OpenFlow controller to see doesn't
actually appear through the OpenFlow connection, even though I know that it's
going through.</p>
<blockquote>
<p>A: By default, Open vSwitch assumes that OpenFlow controllers are connected
&quot;in-band&quot;, that is, that the controllers are actually part of the network
that is being controlled.  In in-band mode, Open vSwitch sets up special
&quot;hidden&quot; flows to make sure that traffic can make it back and forth between
OVS and the controllers.  These hidden flows are higher priority than any
flows that can be set up through OpenFlow, and they are not visible through
normal OpenFlow flow table dumps.</p>
<p>Usually, the hidden flows are desirable and helpful, but occasionally they
can cause unexpected behavior.  You can view the full OpenFlow flow table,
including hidden flows, on bridge br0 with the command:</p>
<pre class="literal-block">
$ ovs-appctl bridge/dump-flows br0
</pre>
<p>to help you debug.  The hidden flows are those with priorities
greater than 65535 (the maximum priority that can be set with
OpenFlow).</p>
<p>The DESIGN file at the top level of the Open vSwitch source
distribution describes the in-band model in detail.</p>
<p>If your controllers are not actually in-band (e.g. they are on
localhost via 127.0.0.1, or on a separate network), then you should
configure your controllers in &quot;out-of-band&quot; mode.  If you have one
controller on bridge br0, then you can configure out-of-band mode
on it with:</p>
<pre class="literal-block">
$ ovs-vsctl set controller br0 connection-mode=out-of-band
</pre>
</blockquote>
<p>Q: Some of the OpenFlow flows that my controller sets up don't seem to apply to
certain traffic, especially traffic between OVS and the controller itself.</p>
<blockquote>
A: See above.</blockquote>
<p>Q: I configured all my controllers for out-of-band control mode but &quot;ovs-appctl
bridge/dump-flows&quot; still shows some hidden flows.</p>
<blockquote>
<p>A: You probably have a remote manager configured (e.g. with &quot;ovs-vsctl
set-manager&quot;).  By default, Open vSwitch assumes that managers need in-band
rules set up on every bridge.  You can disable these rules on bridge br0
with:</p>
<pre class="literal-block">
$ ovs-vsctl set bridge br0 other-config:disable-in-band=true
</pre>
<p>This actually disables in-band control entirely for the bridge, as if all
the bridge's controllers were configured for out-of-band control.</p>
</blockquote>
<p>Q: My OpenFlow controller doesn't see the VLANs that I expect.</p>
<blockquote>
A: See answer under &quot;VLANs&quot;, above.</blockquote>
<p>Q: I ran <tt class="docutils literal"><span class="pre">ovs-ofctl</span> <span class="pre">add-flow</span> br0 nw_dst=192.168.0.1,actions=drop</tt> but I got a
funny message like this:</p>
<pre class="literal-block">
ofp_util|INFO|normalization changed ofp_match, details:
ofp_util|INFO| pre: nw_dst=192.168.0.1
ofp_util|INFO|post:
</pre>
<p>and when I ran <tt class="docutils literal"><span class="pre">ovs-ofctl</span> <span class="pre">dump-flows</span> br0</tt> I saw that my nw_dst match had
disappeared, so that the flow ends up matching every packet.</p>
<blockquote>
<p>A: The term &quot;normalization&quot; in the log message means that a flow cannot
match on an L3 field without saying what L3 protocol is in use.  The
&quot;ovs-ofctl&quot; command above didn't specify an L3 protocol, so the L3 field
match was dropped.</p>
<p>In this case, the L3 protocol could be IP or ARP.  A correct command for
each possibility is, respectively:</p>
<pre class="literal-block">
$ ovs-ofctl add-flow br0 ip,nw_dst=192.168.0.1,actions=drop
</pre>
<p>and:</p>
<pre class="literal-block">
$ ovs-ofctl add-flow br0 arp,nw_dst=192.168.0.1,actions=drop
</pre>
<p>Similarly, a flow cannot match on an L4 field without saying what L4
protocol is in use.  For example, the flow match <tt class="docutils literal">tp_src=1234</tt> is, by
itself, meaningless and will be ignored.  Instead, to match TCP source port
1234, write <tt class="docutils literal">tcp,tp_src=1234</tt>, or to match UDP source port 1234, write
<tt class="docutils literal">udp,tp_src=1234</tt>.</p>
</blockquote>
<p>Q: How can I figure out the OpenFlow port number for a given port?</p>
<blockquote>
<p>A: The <tt class="docutils literal">OFPT_FEATURES_REQUEST</tt> message requests an OpenFlow switch to
respond with an <tt class="docutils literal">OFPT_FEATURES_REPLY</tt> that, among other information,
includes a mapping between OpenFlow port names and numbers.  From a command
prompt, <tt class="docutils literal"><span class="pre">ovs-ofctl</span> show br0</tt> makes such a request and prints the response
for switch br0.</p>
<p>The Interface table in the Open vSwitch database also maps OpenFlow port
names to numbers.  To print the OpenFlow port number associated with
interface eth0, run:</p>
<pre class="literal-block">
$ ovs-vsctl get Interface eth0 ofport
</pre>
<p>You can print the entire mapping with:</p>
<pre class="literal-block">
$ ovs-vsctl -- --columns=name,ofport list Interface
</pre>
<p>but the output mixes together interfaces from all bridges in the database,
so it may be confusing if more than one bridge exists.</p>
<p>In the Open vSwitch database, ofport value <tt class="docutils literal"><span class="pre">-1</span></tt> means that the interface
could not be created due to an error.  (The Open vSwitch log should
indicate the reason.)  ofport value <tt class="docutils literal">[]</tt> (the empty set) means that the
interface hasn't been created yet.  The latter is normally an intermittent
condition (unless ovs-vswitchd is not running).</p>
</blockquote>
<p>Q: I added some flows with my controller or with ovs-ofctl, but when I run
&quot;ovs-dpctl dump-flows&quot; I don't see them.</p>
<blockquote>
A: ovs-dpctl queries a kernel datapath, not an OpenFlow switch.  It won't
display the information that you want.  You want to use <tt class="docutils literal"><span class="pre">ovs-ofctl</span>
<span class="pre">dump-flows</span></tt> instead.</blockquote>
<p>Q: It looks like each of the interfaces in my bonded port shows up as an
individual OpenFlow port.  Is that right?</p>
<blockquote>
<p>A: Yes, Open vSwitch makes individual bond interfaces visible as OpenFlow
ports, rather than the bond as a whole.  The interfaces are treated
together as a bond for only a few purposes:</p>
<ul class="simple">
<li>Sending a packet to the OFPP_NORMAL port.  (When an OpenFlow controller
is not configured, this happens implicitly to every packet.)</li>
<li>Mirrors configured for output to a bonded port.</li>
</ul>
<p>It would make a lot of sense for Open vSwitch to present a bond as a single
OpenFlow port.  If you want to contribute an implementation of such a
feature, please bring it up on the Open vSwitch development mailing list at
<a class="reference external" href="mailto:dev&#64;openvswitch.org">dev&#64;openvswitch.org</a>.</p>
</blockquote>
<p>Q: I have a sophisticated network setup involving Open vSwitch, VMs or multiple
hosts, and other components.  The behavior isn't what I expect.  Help!</p>
<blockquote>
<p>A: To debug network behavior problems, trace the path of a packet,
hop-by-hop, from its origin in one host to a remote host.  If that's
correct, then trace the path of the response packet back to the origin.</p>
<p>The open source tool called <tt class="docutils literal">plotnetcfg</tt> can help to understand the
relationship between the networking devices on a single host.</p>
<p>Usually a simple ICMP echo request and reply (<tt class="docutils literal">ping</tt>) packet is good
enough.  Start by initiating an ongoing <tt class="docutils literal">ping</tt> from the origin host to a
remote host.  If you are tracking down a connectivity problem, the &quot;ping&quot;
will not display any successful output, but packets are still being sent.
(In this case the packets being sent are likely ARP rather than ICMP.)</p>
<p>Tools available for tracing include the following:</p>
<ul>
<li><p class="first"><tt class="docutils literal">tcpdump</tt> and <tt class="docutils literal">wireshark</tt> for observing hops across network devices,
such as Open vSwitch internal devices and physical wires.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">ovs-appctl</span> <span class="pre">dpif/dump-flows</span> &lt;br&gt;</tt> in Open vSwitch 1.10 and later or
<tt class="docutils literal"><span class="pre">ovs-dpctl</span> <span class="pre">dump-flows</span> &lt;br&gt;</tt> in earlier versions.  These tools allow one
to observe the actions being taken on packets in ongoing flows.</p>
<p>See ovs-vswitchd(8) for <tt class="docutils literal"><span class="pre">ovs-appctl</span> <span class="pre">dpif/dump-flows</span></tt> documentation,
ovs-dpctl(8) for <tt class="docutils literal"><span class="pre">ovs-dpctl</span> <span class="pre">dump-flows</span></tt> documentation, and &quot;Why are
there so many different ways to dump flows?&quot; above for some background.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">ovs-appctl</span> ofproto/trace</tt> to observe the logic behind how ovs-vswitchd
treats packets.  See ovs-vswitchd(8) for documentation.  You can out more
details about a given flow that <tt class="docutils literal"><span class="pre">ovs-dpctl</span> <span class="pre">dump-flows</span></tt> displays, by
cutting and pasting a flow from the output into an <tt class="docutils literal"><span class="pre">ovs-appctl</span>
ofproto/trace</tt> command.</p>
</li>
<li><p class="first">SPAN, RSPAN, and ERSPAN features of physical switches, to observe what
goes on at these physical hops.</p>
</li>
</ul>
<p>Starting at the origin of a given packet, observe the packet at each hop in
turn.  For example, in one plausible scenario, you might:</p>
<ol class="arabic simple">
<li><tt class="docutils literal">tcpdump</tt> the <tt class="docutils literal">eth</tt> interface through which an ARP egresses a VM,
from inside the VM.</li>
<li><tt class="docutils literal">tcpdump</tt> the <tt class="docutils literal">vif</tt> or <tt class="docutils literal">tap</tt> interface through which the ARP
ingresses the host machine.</li>
<li>Use <tt class="docutils literal"><span class="pre">ovs-dpctl</span> <span class="pre">dump-flows</span></tt> to spot the ARP flow and observe the host
interface through which the ARP egresses the physical machine.  You may
need to use <tt class="docutils literal"><span class="pre">ovs-dpctl</span> show</tt> to interpret the port numbers.  If the
output seems surprising, you can use <tt class="docutils literal"><span class="pre">ovs-appctl</span> ofproto/trace</tt> to
observe details of how ovs-vswitchd determined the actions in the
<tt class="docutils literal"><span class="pre">ovs-dpctl</span> <span class="pre">dump-flows</span></tt> output.</li>
<li><tt class="docutils literal">tcpdump</tt> the <tt class="docutils literal">eth</tt> interface through which the ARP egresses the
physical machine.</li>
<li><tt class="docutils literal">tcpdump</tt> the <tt class="docutils literal">eth</tt> interface through which the ARP ingresses the
physical machine, at the remote host that receives the ARP.</li>
<li>Use <tt class="docutils literal"><span class="pre">ovs-dpctl</span> <span class="pre">dump-flows</span></tt> to spot the ARP flow on the remote host
remote host that receives the ARP and observe the VM <tt class="docutils literal">vif</tt> or <tt class="docutils literal">tap</tt>
interface to which the flow is directed.  Again, <tt class="docutils literal"><span class="pre">ovs-dpctl</span> show</tt> and
<tt class="docutils literal"><span class="pre">ovs-appctl</span> ofproto/trace</tt> might help.</li>
<li><tt class="docutils literal">tcpdump</tt> the <tt class="docutils literal">vif</tt> or <tt class="docutils literal">tap</tt> interface to which the ARP is
directed.</li>
<li><tt class="docutils literal">tcpdump</tt> the <tt class="docutils literal">eth</tt> interface through which the ARP ingresses a VM,
from inside the VM.</li>
</ol>
<p>It is likely that during one of these steps you will figure out the
problem.  If not, then follow the ARP reply back to the origin, in reverse.</p>
</blockquote>
<p>Q: How do I make a flow drop packets?</p>
<blockquote>
<p>A: To drop a packet is to receive it without forwarding it.  OpenFlow
explicitly specifies forwarding actions.  Thus, a flow with an empty set of
actions does not forward packets anywhere, causing them to be dropped.  You
can specify an empty set of actions with <tt class="docutils literal">actions=</tt> on the ovs-ofctl
command line.  For example:</p>
<pre class="literal-block">
$ ovs-ofctl add-flow br0 priority=65535,actions=
</pre>
<p>would cause every packet entering switch br0 to be dropped.</p>
<p>You can write &quot;drop&quot; explicitly if you like.  The effect is the same.
Thus, the following command also causes every packet entering switch br0 to
be dropped:</p>
<pre class="literal-block">
$ ovs-ofctl add-flow br0 priority=65535,actions=drop
</pre>
<p><tt class="docutils literal">drop</tt> is not an action, either in OpenFlow or Open vSwitch.  Rather, it
is only a way to say that there are no actions.</p>
</blockquote>
<p>Q: I added a flow to send packets out the ingress port, like this:</p>
<pre class="literal-block">
$ ovs-ofctl add-flow br0 in_port=2,actions=2
</pre>
<p>but OVS drops the packets instead.</p>
<blockquote>
<p>A: Yes, OpenFlow requires a switch to ignore attempts to send a packet out
its ingress port.  The rationale is that dropping these packets makes it
harder to loop the network.  Sometimes this behavior can even be
convenient, e.g. it is often the desired behavior in a flow that forwards a
packet to several ports (&quot;floods&quot; the packet).</p>
<p>Sometimes one really needs to send a packet out its ingress port
(&quot;hairpin&quot;). In this case, output to <tt class="docutils literal">OFPP_IN_PORT</tt>, which in ovs-ofctl
syntax is expressed as just <tt class="docutils literal">in_port</tt>, e.g.:</p>
<pre class="literal-block">
$ ovs-ofctl add-flow br0 in_port=2,actions=in_port
</pre>
<p>This also works in some circumstances where the flow doesn't match on the
input port.  For example, if you know that your switch has five ports
numbered 2 through 6, then the following will send every received packet
out every port, even its ingress port:</p>
<pre class="literal-block">
$ ovs-ofctl add-flow br0 actions=2,3,4,5,6,in_port
</pre>
<p>or, equivalently:</p>
<pre class="literal-block">
$ ovs-ofctl add-flow br0 actions=all,in_port
</pre>
<p>Sometimes, in complicated flow tables with multiple levels of <tt class="docutils literal">resubmit</tt>
actions, a flow needs to output to a particular port that may or may not be
the ingress port.  It's difficult to take advantage of <tt class="docutils literal">OFPP_IN_PORT</tt> in
this situation.  To help, Open vSwitch provides, as an OpenFlow extension,
the ability to modify the in_port field.  Whatever value is currently in
the in_port field is the port to which outputs will be dropped, as well as
the destination for <tt class="docutils literal">OFPP_IN_PORT</tt>.  This means that the following will
reliably output to port 2 or to ports 2 through 6, respectively:</p>
<pre class="literal-block">
$ ovs-ofctl add-flow br0 in_port=2,actions=load:0-&gt;NXM_OF_IN_PORT[],2
$ ovs-ofctl add-flow br0 actions=load:0-&gt;NXM_OF_IN_PORT[],2,3,4,5,6
</pre>
<p>If the input port is important, then one may save and restore it on the
stack:</p>
<blockquote>
<dl class="docutils">
<dt>$ ovs-ofctl add-flow br0 actions=push:NXM_OF_IN_PORT[],</dt>
<dd>load:0-&gt;NXM_OF_IN_PORT[],2,3,4,5,6,pop:NXM_OF_IN_PORT[]</dd>
</dl>
</blockquote>
</blockquote>
<p>Q: My bridge br0 has host 192.168.0.1 on port 1 and host 192.168.0.2 on port 2.
I set up flows to forward only traffic destined to the other host and drop
other traffic, like this:</p>
<pre class="literal-block">
priority=5,in_port=1,ip,nw_dst=192.168.0.2,actions=2
priority=5,in_port=2,ip,nw_dst=192.168.0.1,actions=1
priority=0,actions=drop
</pre>
<p>But it doesn't work--I don't get any connectivity when I do this.  Why?</p>
<blockquote>
<p>A: These flows drop the ARP packets that IP hosts use to establish IP
connectivity over Ethernet.  To solve the problem, add flows to allow ARP
to pass between the hosts:</p>
<pre class="literal-block">
priority=5,in_port=1,arp,actions=2
priority=5,in_port=2,arp,actions=1
</pre>
<p>This issue can manifest other ways, too.  The following flows that match on
Ethernet addresses instead of IP addresses will also drop ARP packets,
because ARP requests are broadcast instead of being directed to a specific
host:</p>
<pre class="literal-block">
priority=5,in_port=1,dl_dst=54:00:00:00:00:02,actions=2
priority=5,in_port=2,dl_dst=54:00:00:00:00:01,actions=1
priority=0,actions=drop
</pre>
<p>The solution already described above will also work in this case.  It may
be better to add flows to allow all multicast and broadcast traffic:</p>
<pre class="literal-block">
priority=5,in_port=1,dl_dst=01:00:00:00:00:00/01:00:00:00:00:00,actions=2
priority=5,in_port=2,dl_dst=01:00:00:00:00:00/01:00:00:00:00:00,actions=1
</pre>
</blockquote>
<p>Q: My bridge disconnects from my controller on add-port/del-port.</p>
<blockquote>
<p>A: Reconfiguring your bridge can change your bridge's datapath-id because
Open vSwitch generates datapath-id from the MAC address of one of its
ports.  In that case, Open vSwitch disconnects from controllers because
there's no graceful way to notify controllers about the change of
datapath-id.</p>
<p>To avoid the behaviour, you can configure datapath-id manually.:</p>
<pre class="literal-block">
$ ovs-vsctl set bridge br0 other-config:datapath-id=0123456789abcdef
</pre>
</blockquote>
<p>Q: My controller complains that OVS is not buffering packets.
What's going on?</p>
<blockquote>
A: &quot;Packet buffering&quot; is an optional OpenFlow feature, and controllers
should detect how many &quot;buffers&quot; an OpenFlow switch implements.  It was
recently noticed that OVS implementation of the buffering feature was not
compliant to OpenFlow specifications.  Rather than fix it and risk
controller incompatibility, the buffering feature is removed as of OVS 2.7.
Controllers are already expected to work properly in cases where the switch
can not buffer packets, but sends full packets in &quot;packet-in&quot; messages
instead, so this change should not affect existing users.  After the change
OVS always sends the <tt class="docutils literal">buffer_id</tt> as <tt class="docutils literal">0xffffffff</tt> in &quot;packet-in&quot;
messages and will send an error response if any other value of this field
is included in a &quot;packet-out&quot; or a &quot;flow mod&quot; sent by a controller.</blockquote>
<p>Q: How does OVS divide flows among buckets in an OpenFlow &quot;select&quot; group?</p>
<blockquote>
<p>A: In Open vSwitch 2.3 and earlier, Open vSwitch used the destination
Ethernet address to choose a bucket in a select group.</p>
<p>Open vSwitch 2.4 and later by default hashes the source and destination
Ethernet address, VLAN ID, Ethernet type, IPv4/v6 source and destination
address and protocol, and for TCP and SCTP only, the source and destination
ports.  The hash is &quot;symmetric&quot;, meaning that exchanging source and
destination addresses does not change the bucket selection.</p>
<p>Select groups in Open vSwitch 2.4 and later can be configured to use a
different hash function, using a Netronome extension to the OpenFlow 1.5+
group_mod message.  For more information, see
Documentation/group-selection-method-property.txt in the Open vSwitch
source tree.  (OpenFlow 1.5 support in Open vSwitch is still experimental.)</p>
</blockquote>
<p>Q: I added a flow to accept packets on VLAN 123 and output them on VLAN 456,
like so:</p>
<pre class="literal-block">
$ ovs-ofctl add-flow br0 dl_vlan=123,actions=output:1,mod_vlan_vid:456
</pre>
<p>but the packets are actually being output in VLAN 123.  Why?</p>
<blockquote>
<p>A: OpenFlow actions are executed in the order specified.  Thus, the actions
above first output the packet, then change its VLAN.  Since the output
occurs before changing the VLAN, the change in VLAN will have no visible
effect.</p>
<p>To solve this and similar problems, order actions so that changes to
headers happen before output, e.g.:</p>
<pre class="literal-block">
$ ovs-ofctl add-flow br0 dl_vlan=123,actions=mod_vlan_vid:456,output:1
</pre>
</blockquote>
<p>Q: The &quot;learn&quot; action can't learn the action I want, can you improve it?</p>
<blockquote>
<p>A: By itself, the &quot;learn&quot; action can only put two kinds of actions into the
flows that it creates: &quot;load&quot; and &quot;output&quot; actions.  If &quot;learn&quot; is used in
isolation, these are severe limits.</p>
<p>However, &quot;learn&quot; is not meant to be used in isolation.  It is a primitive
meant to be used together with other Open vSwitch features to accomplish a
task.  Its existing features are enough to accomplish most tasks.</p>
<p>Here is an outline of a typical pipeline structure that allows for
versatile behavior using &quot;learn&quot;:</p>
<ul class="simple">
<li>Flows in table A contain a &quot;learn&quot; action, that populates flows in table
L, that use a &quot;load&quot; action to populate register R with information about
what was learned.</li>
<li>Flows in table B contain two sequential resubmit actions: one to table L
and another one to table B+1.</li>
<li>Flows in table B+1 match on register R and act differently depending on
what the flows in table L loaded into it.</li>
</ul>
<p>This approach can be used to implement many &quot;learn&quot;-based features.  For
example:</p>
<ul class="simple">
<li>Resubmit to a table selected based on learned information, e.g. see:
<a class="reference external" href="http://openvswitch.org/pipermail/discuss/2016-June/021694.html">http://openvswitch.org/pipermail/discuss/2016-June/021694.html</a></li>
<li>MAC learning in the middle of a pipeline, as described in <a class="reference external" href="tutorial/tutorial.rst">the tutorial</a>.</li>
<li>TCP state based firewalling, by learning outgoing connections based on
SYN packets and matching them up with incoming packets.</li>
<li>At least some of the features described in T. A. Hoff, &quot;Extending Open
vSwitch to Facilitate Creation of Stateful SDN Applications&quot;.</li>
</ul>
</blockquote>
</div>
<div class="section" id="development">
<h1>Development</h1>
<p>Q: How do I implement a new OpenFlow message?</p>
<blockquote>
<p>A: Add your new message to <tt class="docutils literal">enum ofpraw</tt> and <tt class="docutils literal">enum ofptype</tt> in
<tt class="docutils literal"><span class="pre">lib/ofp-msgs.h</span></tt>, following the existing pattern.  Then recompile and fix
all of the new warnings, implementing new functionality for the new message
as needed.  (If you configure with <tt class="docutils literal"><span class="pre">--enable-Werror</span></tt>, as described in the
<a class="reference external" href="INSTALL.rst">installation guide</a>, then it is impossible to miss any
warnings.)</p>
<p>If you need to add an OpenFlow vendor extension message for a vendor that
doesn't yet have any extension messages, then you will also need to edit
<tt class="docutils literal"><span class="pre">build-aux/extract-ofp-msgs</span></tt>.</p>
</blockquote>
<p>Q: How do I add support for a new field or header?</p>
<blockquote>
<p>A: Add new members for your field to <tt class="docutils literal">struct flow</tt> in <tt class="docutils literal">lib/flow.h</tt>, and
add new enumerations for your new field to <tt class="docutils literal">enum mf_field_id</tt> in
<tt class="docutils literal"><span class="pre">lib/meta-flow.h</span></tt>, following the existing pattern.  Also, add support to
<tt class="docutils literal">miniflow_extract()</tt> in <tt class="docutils literal">lib/flow.c</tt> for extracting your new field from
a packet into struct miniflow, and to <tt class="docutils literal">nx_put_raw()</tt> in
<tt class="docutils literal"><span class="pre">lib/nx-match.c</span></tt> to output your new field in OXM matches.  Then recompile
and fix all of the new warnings, implementing new functionality for the new
field or header as needed.  (If you configure with <tt class="docutils literal"><span class="pre">--enable-Werror</span></tt>, as
described in the <a class="reference external" href="INSTALL.rst">installation guide</a>, then it is impossible
to miss any warnings.)</p>
<p>If you want kernel datapath support for your new field, you also need to
modify the kernel module for the operating systems you are interested in.
This isn't mandatory, since fields understood only by userspace work too
(with a performance penalty), so it's reasonable to start development
without it.  If you implement kernel module support for Linux, then the
Linux kernel &quot;netdev&quot; mailing list is the place to submit that support
first; please read up on the Linux kernel development process separately.
The Windows datapath kernel module support, on the other hand, is
maintained within the OVS tree, so patches for that can go directly to
ovs-dev.</p>
</blockquote>
<p>Q: How do I add support for a new OpenFlow action?</p>
<blockquote>
<p>A: Add your new action to <tt class="docutils literal">enum ofp_raw_action_type</tt> in
<tt class="docutils literal"><span class="pre">lib/ofp-actions.c</span></tt>, following the existing pattern.  Then recompile and
fix all of the new warnings, implementing new functionality for the new
action as needed.  (If you configure with <tt class="docutils literal"><span class="pre">--enable-Werror</span></tt>, as described
in the <a class="reference external" href="INSTALL.rst">installation guide</a>, then it is impossible to miss
any warnings.)</p>
<p>If you need to add an OpenFlow vendor extension action for a vendor that
doesn't yet have any extension actions, then you will also need to edit
<tt class="docutils literal"><span class="pre">build-aux/extract-ofp-actions</span></tt>.</p>
</blockquote>
</div>
</div>
</body>
</html>
