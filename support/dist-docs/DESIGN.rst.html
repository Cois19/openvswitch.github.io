<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>DESIGN.rst (Open vSwitch 2.6.90)</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="design-decisions-in-open-vswitch">
<h1 class="title">Design Decisions In Open vSwitch</h1>

<!-- Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations
under the License.

Convention for heading levels in Open vSwitch documentation:

=======  Heading 0 (reserved for the title in a document)
- - - - - - -  Heading 1
~~~~~~~  Heading 2
+++++++  Heading 3
'''''''  Heading 4

Avoid deeper levels because they do not render well. -->
<p>This document describes design decisions that went into implementing Open
vSwitch.  While we believe these to be reasonable decisions, it is impossible
to predict how Open vSwitch will be used in all environments.  Understanding
assumptions made by Open vSwitch is critical to a successful deployment.  The
end of this document contains contact information that can be used to let us
know how we can make Open vSwitch more generally useful.</p>
<div class="section" id="asynchronous-messages">
<h1>Asynchronous Messages</h1>
<p>Over time, Open vSwitch has added many knobs that control whether a given
controller receives OpenFlow asynchronous messages.  This section describes how
all of these features interact.</p>
<p>First, a service controller never receives any asynchronous messages unless it
changes its miss_send_len from the service controller default of zero in one of
the following ways:</p>
<ul class="simple">
<li>Sending an <tt class="docutils literal">OFPT_SET_CONFIG</tt> message with nonzero <tt class="docutils literal">miss_send_len</tt>.</li>
<li>Sending any <tt class="docutils literal">NXT_SET_ASYNC_CONFIG</tt> message: as a side effect, this message
changes the <tt class="docutils literal">miss_send_len</tt> to <tt class="docutils literal">OFP_DEFAULT_MISS_SEND_LEN</tt> (128) for
service controllers.</li>
</ul>
<p>Second, <tt class="docutils literal">OFPT_FLOW_REMOVED</tt> and <tt class="docutils literal">NXT_FLOW_REMOVED</tt> messages are generated
only if the flow that was removed had the <tt class="docutils literal">OFPFF_SEND_FLOW_REM</tt> flag set.</p>
<p>Third, <tt class="docutils literal">OFPT_PACKET_IN</tt> and <tt class="docutils literal">NXT_PACKET_IN</tt> messages are sent only to
OpenFlow controller connections that have the correct connection ID (see
<tt class="docutils literal">struct nx_controller_id</tt> and <tt class="docutils literal">struct nx_action_controller</tt>):</p>
<ul class="simple">
<li>For packet-in messages generated by a <tt class="docutils literal">NXAST_CONTROLLER</tt> action, the
controller ID specified in the action.</li>
<li>For other packet-in messages, controller ID zero.  (This is the default ID
when an OpenFlow controller does not configure one.)</li>
</ul>
<p>Finally, Open vSwitch consults a per-connection table indexed by the message
type, reason code, and current role.  The following table shows how this table
is initialized by default when an OpenFlow connection is made.  An entry
labeled <tt class="docutils literal">yes</tt> means that the message is sent, an entry labeled <tt class="docutils literal"><span class="pre">---</span></tt> means
that the message is suppressed.</p>
<table border="1" class="docutils">
<caption><tt class="docutils literal">OFPT_PACKET_IN</tt> / <tt class="docutils literal">NXT_PACKET_IN</tt></caption>
<colgroup>
<col width="78%" />
<col width="13%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">message and reason code</th>
<th class="head">other</th>
<th class="head">slave</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">OFPR_NO_MATCH</tt></td>
<td>yes</td>
<td>---</td>
</tr>
<tr><td><tt class="docutils literal">OFPR_ACTION</tt></td>
<td>yes</td>
<td>---</td>
</tr>
<tr><td><tt class="docutils literal">OFPR_INVALID_TTL</tt></td>
<td>---</td>
<td>---</td>
</tr>
<tr><td><tt class="docutils literal">OFPR_ACTION_SET</tt> (OF1.4+)</td>
<td>yes</td>
<td>---</td>
</tr>
<tr><td><tt class="docutils literal">OFPR_GROUP</tt> (OF1.4+)</td>
<td>yes</td>
<td>---</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<caption><tt class="docutils literal">OFPT_FLOW_REMOVED</tt> / <tt class="docutils literal">NXT_FLOW_REMOVED</tt></caption>
<colgroup>
<col width="78%" />
<col width="13%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">message and reason code</th>
<th class="head">other</th>
<th class="head">slave</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">OFPRR_IDLE_TIMEOUT</tt></td>
<td>yes</td>
<td>---</td>
</tr>
<tr><td><tt class="docutils literal">OFPRR_HARD_TIMEOUT</tt></td>
<td>yes</td>
<td>---</td>
</tr>
<tr><td><tt class="docutils literal">OFPRR_DELETE</tt></td>
<td>yes</td>
<td>---</td>
</tr>
<tr><td><tt class="docutils literal">OFPRR_GROUP_DELETE</tt> (OF1.4+)</td>
<td>yes</td>
<td>---</td>
</tr>
<tr><td><tt class="docutils literal">OFPRR_METER_DELETE</tt> (OF1.4+)</td>
<td>yes</td>
<td>---</td>
</tr>
<tr><td><tt class="docutils literal">OFPRR_EVICTION</tt> (OF1.4+)</td>
<td>yes</td>
<td>---</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<caption><tt class="docutils literal">OFPT_PORT_STATUS</tt></caption>
<colgroup>
<col width="78%" />
<col width="13%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">message and reason code</th>
<th class="head">other</th>
<th class="head">slave</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">OFPPR_ADD</tt></td>
<td>yes</td>
<td>yes</td>
</tr>
<tr><td><tt class="docutils literal">OFPPR_DELETE</tt></td>
<td>yes</td>
<td>yes</td>
</tr>
<tr><td><tt class="docutils literal">OFPPR_MODIFY</tt></td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<caption><tt class="docutils literal">OFPT_ROLE_REQUEST</tt> / <tt class="docutils literal">OFPT_ROLE_REPLY</tt> (OF1.4+)</caption>
<colgroup>
<col width="78%" />
<col width="13%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">message and reason code</th>
<th class="head">other</th>
<th class="head">slave</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">OFPCRR_MASTER_REQUEST</tt></td>
<td>---</td>
<td>---</td>
</tr>
<tr><td><tt class="docutils literal">OFPCRR_CONFIG</tt></td>
<td>---</td>
<td>---</td>
</tr>
<tr><td><tt class="docutils literal">OFPCRR_EXPERIMENTER</tt></td>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<caption><tt class="docutils literal">OFPT_TABLE_STATUS</tt> (OF1.4+)</caption>
<colgroup>
<col width="78%" />
<col width="13%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">message and reason code</th>
<th class="head">other</th>
<th class="head">slave</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">OFPTR_VACANCY_DOWN</tt></td>
<td>---</td>
<td>---</td>
</tr>
<tr><td><tt class="docutils literal">OFPTR_VACANCY_UP</tt></td>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<caption><tt class="docutils literal">OFPT_REQUESTFORWARD</tt> (OF1.4+)</caption>
<colgroup>
<col width="78%" />
<col width="13%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">message and reason code</th>
<th class="head">other</th>
<th class="head">slave</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">OFPRFR_GROUP_MOD</tt></td>
<td>---</td>
<td>---</td>
</tr>
<tr><td><tt class="docutils literal">OFPRFR_METER_MOD</tt></td>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>The <tt class="docutils literal">NXT_SET_ASYNC_CONFIG</tt> message directly sets all of the values in this
table for the current connection.  The <tt class="docutils literal">OFPC_INVALID_TTL_TO_CONTROLLER</tt> bit
in the <tt class="docutils literal">OFPT_SET_CONFIG</tt> message controls the setting for
<tt class="docutils literal">OFPR_INVALID_TTL</tt> for the &quot;master&quot; role.</p>
</div>
<div class="section" id="ofpat-enqueue">
<h1><tt class="docutils literal">OFPAT_ENQUEUE</tt></h1>
<p>The OpenFlow 1.0 specification requires the output port of the
<tt class="docutils literal">OFPAT_ENQUEUE</tt> action to &quot;refer to a valid physical port (i.e. &lt;
<tt class="docutils literal">OFPP_MAX</tt>) or <tt class="docutils literal">OFPP_IN_PORT</tt>&quot;.  Although <tt class="docutils literal">OFPP_LOCAL</tt> is not less than
<tt class="docutils literal">OFPP_MAX</tt>, it is an 'internal' port which can have QoS applied to it in
Linux.  Since we allow the <tt class="docutils literal">OFPAT_ENQUEUE</tt> to apply to 'internal' ports whose
port numbers are less than <tt class="docutils literal">OFPP_MAX</tt>, we interpret <tt class="docutils literal">OFPP_LOCAL</tt> as a
physical port and support <tt class="docutils literal">OFPAT_ENQUEUE</tt> on it as well.</p>
</div>
<div class="section" id="ofpt-flow-mod">
<h1><tt class="docutils literal">OFPT_FLOW_MOD</tt></h1>
<p>The OpenFlow specification for the behavior of <tt class="docutils literal">OFPT_FLOW_MOD</tt> is confusing.
The following tables summarize the Open vSwitch implementation of its behavior
in the following categories:</p>
<dl class="docutils">
<dt>&quot;match on priority&quot;</dt>
<dd>Whether the <tt class="docutils literal">flow_mod</tt> acts only on flows whose priority matches that
included in the <tt class="docutils literal">flow_mod</tt> message.</dd>
<dt>&quot;match on out_port&quot;</dt>
<dd>Whether the <tt class="docutils literal">flow_mod</tt> acts only on flows that output to the out_port
included in the flow_mod message (if out_port is not <tt class="docutils literal">OFPP_NONE</tt>).
OpenFlow 1.1 and later have a similar feature (not listed separately here)
for <tt class="docutils literal">out_group</tt>.</dd>
<dt>&quot;match on flow_cookie&quot;:</dt>
<dd>Whether the <tt class="docutils literal">flow_mod</tt> acts only on flows whose <tt class="docutils literal">flow_cookie</tt> matches an
optional controller-specified value and mask.</dd>
<dt>&quot;updates flow_cookie&quot;:</dt>
<dd>Whether the <tt class="docutils literal">flow_mod</tt> changes the <tt class="docutils literal">flow_cookie</tt> of the flow or flows
that it matches to the <tt class="docutils literal">flow_cookie</tt> included in the flow_mod message.</dd>
<dt>&quot;updates <tt class="docutils literal">OFPFF_</tt> flags&quot;:</dt>
<dd>Whether the flow_mod changes the <tt class="docutils literal">OFPFF_SEND_FLOW_REM</tt> flag of the flow or
flows that it matches to the setting included in the flags of the flow_mod
message.</dd>
<dt>&quot;honors <tt class="docutils literal">OFPFF_CHECK_OVERLAP</tt>&quot;:</dt>
<dd>Whether the <tt class="docutils literal">OFPFF_CHECK_OVERLAP</tt> flag in the flow_mod is significant.</dd>
<dt>&quot;updates <tt class="docutils literal">idle_timeout</tt>&quot; and &quot;updates <tt class="docutils literal">hard_timeout</tt>&quot;:</dt>
<dd>Whether the <tt class="docutils literal">idle_timeout</tt> and hard_timeout in the <tt class="docutils literal">flow_mod</tt>,
respectively, have an effect on the flow or flows matched by the
<tt class="docutils literal">flow_mod</tt>.</dd>
<dt>&quot;updates idle timer&quot;:</dt>
<dd>Whether the <tt class="docutils literal">flow_mod</tt> resets the per-flow timer that measures how long a
flow has been idle.</dd>
<dt>&quot;updates hard timer&quot;:</dt>
<dd>Whether the <tt class="docutils literal">flow_mod</tt> resets the per-flow timer that measures how long it
has been since a flow was modified.</dd>
<dt>&quot;zeros counters&quot;:</dt>
<dd>Whether the <tt class="docutils literal">flow_mod</tt> resets per-flow packet and byte counters to zero.</dd>
<dt>&quot;may add a new flow&quot;:</dt>
<dd>Whether the <tt class="docutils literal">flow_mod</tt> may add a new flow to the flow table.  (Obviously
this is always true for &quot;add&quot; commands but in some OpenFlow versions &quot;modify&quot;
and &quot;modify-strict&quot; can also add new flows.)</dd>
<dt>&quot;sends <tt class="docutils literal">flow_removed</tt> message&quot;:</dt>
<dd>Whether the flow_mod generates a flow_removed message for the flow or flows
that it affects.</dd>
</dl>
<p>An entry labeled <tt class="docutils literal">yes</tt> means that the flow mod type does have the indicated
behavior, <tt class="docutils literal"><span class="pre">---</span></tt> means that it does not, an empty cell means that the property
is not applicable, and other values are explained below the table.</p>
<div class="section" id="openflow-1-0">
<h2>OpenFlow 1.0</h2>
<table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="5%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">RULE</th>
<th class="head">ADD</th>
<th class="head">MODIFY</th>
<th class="head">STRICT</th>
<th class="head">DELETE</th>
<th class="head">STRICT</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>match on <tt class="docutils literal">priority</tt></td>
<td>yes</td>
<td>---</td>
<td>yes</td>
<td>---</td>
<td>yes</td>
</tr>
<tr><td>match on <tt class="docutils literal">out_port</tt></td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr><td>match on <tt class="docutils literal">flow_cookie</tt></td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>---</td>
</tr>
<tr><td>match on <tt class="docutils literal">table_id</tt></td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>---</td>
</tr>
<tr><td>controller chooses <tt class="docutils literal">table_id</tt></td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>updates <tt class="docutils literal">flow_cookie</tt></td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>updates <tt class="docutils literal">OFPFF_SEND_FLOW_REM</tt></td>
<td>yes</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>honors <tt class="docutils literal">OFPFF_CHECK_OVERLAP</tt></td>
<td>yes</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>updates <tt class="docutils literal">idle_timeout</tt></td>
<td>yes</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>updates <tt class="docutils literal">hard_timeout</tt></td>
<td>yes</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>resets idle timer</td>
<td>yes</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>resets hard timer</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>zeros counters</td>
<td>yes</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>may add a new flow</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>sends <tt class="docutils literal">flow_removed</tt> message</td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>%</td>
<td>%</td>
</tr>
</tbody>
</table>
<p>where:</p>
<dl class="docutils">
<dt><tt class="docutils literal">+</tt></dt>
<dd>&quot;modify&quot; and &quot;modify-strict&quot; only take these actions when they create a new
flow, not when they update an existing flow.</dd>
<dt><tt class="docutils literal">%</tt></dt>
<dd>&quot;delete&quot; and &quot;delete_strict&quot; generates a flow_removed message if the deleted
flow or flows have the <tt class="docutils literal">OFPFF_SEND_FLOW_REM</tt> flag set.  (Each controller
can separately control whether it wants to receive the generated messages.)</dd>
</dl>
</div>
<div class="section" id="openflow-1-1">
<h2>OpenFlow 1.1</h2>
<p>OpenFlow 1.1 makes these changes:</p>
<ul class="simple">
<li>The controller now must specify the <tt class="docutils literal">table_id</tt> of the flow match searched
and into which a flow may be inserted.  Behavior for a <tt class="docutils literal">table_id</tt> of 255 is
undefined.</li>
<li>A <tt class="docutils literal">flow_mod</tt>, except an &quot;add&quot;, can now match on the <tt class="docutils literal">flow_cookie</tt>.</li>
<li>When a <tt class="docutils literal">flow_mod</tt> matches on the <tt class="docutils literal">flow_cookie</tt>, &quot;modify&quot; and
&quot;modify-strict&quot; never insert a new flow.</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="5%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">RULE</th>
<th class="head">ADD</th>
<th class="head">MODIFY</th>
<th class="head">STRICT</th>
<th class="head">DELETE</th>
<th class="head">STRICT</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>match on <tt class="docutils literal">priority</tt></td>
<td>yes</td>
<td>---</td>
<td>yes</td>
<td>---</td>
<td>yes</td>
</tr>
<tr><td>match on <tt class="docutils literal">out_port</tt></td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr><td>match on <tt class="docutils literal">flow_cookie</tt></td>
<td>---</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr><td>match on <tt class="docutils literal">table_id</tt></td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr><td>controller chooses <tt class="docutils literal">table_id</tt></td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>updates <tt class="docutils literal">flow_cookie</tt></td>
<td>yes</td>
<td>---</td>
<td>---</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>updates <tt class="docutils literal">OFPFF_SEND_FLOW_REM</tt></td>
<td>yes</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>honors <tt class="docutils literal">OFPFF_CHECK_OVERLAP</tt></td>
<td>yes</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>updates <tt class="docutils literal">idle_timeout</tt></td>
<td>yes</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>updates <tt class="docutils literal">hard_timeout</tt></td>
<td>yes</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>resets idle timer</td>
<td>yes</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>resets hard timer</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>zeros counters</td>
<td>yes</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>may add a new flow</td>
<td>yes</td>
<td>#</td>
<td>#</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>sends <tt class="docutils literal">flow_removed</tt> message</td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>%</td>
<td>%</td>
</tr>
</tbody>
</table>
<p>where:</p>
<dl class="docutils">
<dt><tt class="docutils literal">+</tt></dt>
<dd>&quot;modify&quot; and &quot;modify-strict&quot; only take these actions when they create a new
flow, not when they update an existing flow.</dd>
<dt><tt class="docutils literal">%</tt></dt>
<dd>&quot;delete&quot; and &quot;delete_strict&quot; generates a flow_removed message if the deleted
flow or flows have the <tt class="docutils literal">OFPFF_SEND_FLOW_REM</tt> flag set.  (Each controller
can separately control whether it wants to receive the generated messages.)</dd>
<dt><tt class="docutils literal">#</tt></dt>
<dd>&quot;modify&quot; and &quot;modify-strict&quot; only add a new flow if the flow_mod does not
match on any bits of the flow cookie</dd>
</dl>
</div>
<div class="section" id="openflow-1-2">
<h2>OpenFlow 1.2</h2>
<p>OpenFlow 1.2 makes these changes:</p>
<ul class="simple">
<li>Only &quot;add&quot; commands ever add flows, &quot;modify&quot; and &quot;modify-strict&quot; never do.</li>
<li>A new flag <tt class="docutils literal">OFPFF_RESET_COUNTS</tt> now controls whether &quot;modify&quot; and
&quot;modify-strict&quot; reset counters, whereas previously they never reset counters
(except when they inserted a new flow).</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="5%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">RULE</th>
<th class="head">ADD</th>
<th class="head">MODIFY</th>
<th class="head">STRICT</th>
<th class="head">DELETE</th>
<th class="head">STRICT</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>match on <tt class="docutils literal">priority</tt></td>
<td>yes</td>
<td>---</td>
<td>yes</td>
<td>---</td>
<td>yes</td>
</tr>
<tr><td>match on <tt class="docutils literal">out_port</tt></td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr><td>match on <tt class="docutils literal">flow_cookie</tt></td>
<td>---</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr><td>match on <tt class="docutils literal">table_id</tt></td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr><td>controller chooses <tt class="docutils literal">table_id</tt></td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>updates <tt class="docutils literal">flow_cookie</tt></td>
<td>yes</td>
<td>---</td>
<td>---</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>updates <tt class="docutils literal">OFPFF_SEND_FLOW_REM</tt></td>
<td>yes</td>
<td>---</td>
<td>---</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>honors <tt class="docutils literal">OFPFF_CHECK_OVERLAP</tt></td>
<td>yes</td>
<td>---</td>
<td>---</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>updates <tt class="docutils literal">idle_timeout</tt></td>
<td>yes</td>
<td>---</td>
<td>---</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>updates <tt class="docutils literal">hard_timeout</tt></td>
<td>yes</td>
<td>---</td>
<td>---</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>resets idle timer</td>
<td>yes</td>
<td>---</td>
<td>---</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>resets hard timer</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>zeros counters</td>
<td>yes</td>
<td>&amp;</td>
<td>&amp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>may add a new flow</td>
<td>yes</td>
<td>---</td>
<td>---</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>sends <tt class="docutils literal">flow_removed</tt> message</td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>%</td>
<td>%</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><tt class="docutils literal">%</tt></dt>
<dd>&quot;delete&quot; and &quot;delete_strict&quot; generates a flow_removed message if the deleted
flow or flows have the <tt class="docutils literal">OFPFF_SEND_FLOW_REM</tt> flag set.  (Each controller
can separately control whether it wants to receive the generated messages.)</dd>
<dt><tt class="docutils literal">&amp;</tt></dt>
<dd>&quot;modify&quot; and &quot;modify-strict&quot; reset counters if the <tt class="docutils literal">OFPFF_RESET_COUNTS</tt>
flag is specified.</dd>
</dl>
</div>
<div class="section" id="openflow-1-3">
<h2>OpenFlow 1.3</h2>
<p>OpenFlow 1.3 makes these changes:</p>
<ul class="simple">
<li>Behavior for a table_id of 255 is now defined, for &quot;delete&quot; and
&quot;delete-strict&quot; commands, as meaning to delete from all tables.  A table_id
of 255 is now explicitly invalid for other commands.</li>
<li>New flags <tt class="docutils literal">OFPFF_NO_PKT_COUNTS</tt> and <tt class="docutils literal">OFPFF_NO_BYT_COUNTS</tt> for &quot;add&quot;
operations.</li>
</ul>
<p>The table for 1.3 is the same as the one shown above for 1.2.</p>
</div>
<div class="section" id="openflow-1-4">
<h2>OpenFlow 1.4</h2>
<p>OpenFlow 1.4 makes these changes:</p>
<ul class="simple">
<li>Adds the &quot;importance&quot; field to <tt class="docutils literal">flow_mods</tt>, but it does not explicitly
specify which kinds of <tt class="docutils literal">flow_mods</tt> set the importance.  For consistency,
Open vSwitch uses the same rule for importance as for <tt class="docutils literal">idle_timeout</tt> and
<tt class="docutils literal">hard_timeout</tt>, that is, only an &quot;ADD&quot; flow_mod sets the importance.  (This
issue has been filed with the ONF as EXT-496.)</li>
</ul>
<!-- TODO(stephenfin) Link to EXT-496 -->
<ul class="simple">
<li>Eviction Mechanism to automatically delete entries of lower importance to
make space for newer entries.</li>
</ul>
</div>
</div>
<div class="section" id="openflow-1-4-bundles">
<h1>OpenFlow 1.4 Bundles</h1>
<p>Open vSwitch makes all flow table modifications atomically, i.e., any datapath
packet only sees flow table configurations either before or after any change
made by any <tt class="docutils literal">flow_mod</tt>.  For example, if a controller removes all flows with
a single OpenFlow <tt class="docutils literal">flow_mod</tt>, no packet sees an intermediate version of the
OpenFlow pipeline where only some of the flows have been deleted.</p>
<p>It should be noted that Open vSwitch caches datapath flows, and that the cached
flows are <em>NOT</em> flushed immediately when a flow table changes.  Instead, the
datapath flows are revalidated against the new flow table as soon as possible,
and usually within one second of the modification.  This design amortizes the
cost of datapath cache flushing across multiple flow table changes, and has a
significant performance effect during simultaneous heavy flow table churn and
high traffic load.  This means that different cached datapath flows may have
been computed based on a different flow table configurations, but each of the
datapath flows is guaranteed to have been computed over a coherent view of the
flow tables, as described above.</p>
<p>With OpenFlow 1.4 bundles this atomicity can be extended across an arbitrary
set of <tt class="docutils literal">flow_mod</tt>.  Bundles are supported for <tt class="docutils literal">flow_mod</tt> and port_mod
messages only.  For <tt class="docutils literal">flow_mod</tt>, both <tt class="docutils literal">atomic</tt> and <tt class="docutils literal">ordered</tt> bundle flags
are trivially supported, as all bundled messages are executed in the order they
were added and all flow table modifications are now atomic to the datapath.
Port mods may not appear in atomic bundles, as port status modifications are
not atomic.</p>
<p>To support bundles, ovs-ofctl has a <tt class="docutils literal"><span class="pre">--bundle</span></tt> option that makes the
flow mod commands (<tt class="docutils literal"><span class="pre">add-flow</span></tt>, <tt class="docutils literal"><span class="pre">add-flows</span></tt>, <tt class="docutils literal"><span class="pre">mod-flows</span></tt>, <tt class="docutils literal"><span class="pre">del-flows</span></tt>,
and <tt class="docutils literal"><span class="pre">replace-flows</span></tt>) use an OpenFlow 1.4 bundle to operate the
modifications as a single atomic transaction.  If any of the flow mods
in a transaction fail, none of them are executed.  All flow mods in a
bundle appear to datapath lookups simultaneously.</p>
<p>Furthermore, ovs-ofctl <tt class="docutils literal"><span class="pre">add-flow</span></tt> and <tt class="docutils literal"><span class="pre">add-flows</span></tt> commands now accept
arbitrary flow mods as an input by allowing the flow specification to
start with an explicit <tt class="docutils literal">add</tt>, <tt class="docutils literal">modify</tt>, <tt class="docutils literal">modify_strict</tt>, <tt class="docutils literal">delete</tt>, or
<tt class="docutils literal">delete_strict</tt> keyword.  A missing keyword is treated as <tt class="docutils literal">add</tt>, so
this is fully backwards compatible.  With the new <tt class="docutils literal"><span class="pre">--bundle</span></tt> option
all the flow mods are executed as a single atomic transaction using an
OpenFlow 1.4 bundle.  Without the <tt class="docutils literal"><span class="pre">--bundle</span></tt> option the flow mods are
executed in order up to the first failing <tt class="docutils literal">flow_mod</tt>, and in case of an
error the earlier successful <tt class="docutils literal">flow_mod</tt> calls are not rolled back.</p>
</div>
<div class="section" id="ofpt-packet-in">
<h1><tt class="docutils literal">OFPT_PACKET_IN</tt></h1>
<p>The OpenFlow 1.1 specification for <tt class="docutils literal">OFPT_PACKET_IN</tt> is confusing.  The
definition in OF1.1 <tt class="docutils literal">openflow.h</tt> is[*]:</p>
<pre class="literal-block">
/* Packet received on port (datapath -&gt; controller). */
struct ofp_packet_in {
    struct ofp_header header;
    uint32_t buffer_id;     /* ID assigned by datapath. */
    uint32_t in_port;       /* Port on which frame was received. */
    uint32_t in_phy_port;   /* Physical Port on which frame was received. */
    uint16_t total_len;     /* Full length of frame. */
    uint8_t reason;         /* Reason packet is being sent (one of OFPR_*) */
    uint8_t table_id;       /* ID of the table that was looked up */
    uint8_t data[0];        /* Ethernet frame, halfway through 32-bit word,
                               so the IP header is 32-bit aligned.  The
                               amount of data is inferred from the length
                               field in the header.  Because of padding,
                               offsetof(struct ofp_packet_in, data) ==
                               sizeof(struct ofp_packet_in) - 2. */
};
OFP_ASSERT(sizeof(struct ofp_packet_in) == 24);
</pre>
<p>The confusing part is the comment on the <tt class="docutils literal">data[]</tt> member.  This comment is a
leftover from OF1.0 <tt class="docutils literal">openflow.h</tt>, in which the comment was correct:
<tt class="docutils literal">sizeof(struct ofp_packet_in)</tt> is 20 in OF1.0 and <tt class="docutils literal">ffsetof(struct
ofp_packet_in, data)</tt> is 18.  When OF1.1 was written, the structure members
were changed but the comment was carelessly not updated, and the comment became
wrong: <tt class="docutils literal">sizeof(struct ofp_packet_in)</tt> and offsetof(struct ofp_packet_in,
data) are both 24 in OF1.1.</p>
<p>That leaves the question of how to implement <tt class="docutils literal">ofp_packet_in</tt> in OF1.1.  The
OpenFlow reference implementation for OF1.1 does not include any padding, that
is, the first byte of the encapsulated frame immediately follows the
<tt class="docutils literal">table_id</tt> member without a gap.  Open vSwitch therefore implements it the
same way for compatibility.</p>
<p>For an earlier discussion, please see the thread archived at:
<a class="reference external" href="https://mailman.stanford.edu/pipermail/openflow-discuss/2011-August/002604.html">https://mailman.stanford.edu/pipermail/openflow-discuss/2011-August/002604.html</a></p>
<p>[*] The quoted definition is directly from OF1.1.  Definitions used inside OVS
omit the 8-byte <tt class="docutils literal">ofp_header</tt> members, so the sizes in this discussion are
8 bytes larger than those declared in OVS header files.</p>
</div>
<div class="section" id="vlan-matching">
<h1>VLAN Matching</h1>
<p>The 802.1Q VLAN header causes more trouble than any other 4 bytes in
networking.  More specifically, three versions of OpenFlow and Open vSwitch
have among them four different ways to match the contents and presence of the
VLAN header.  The following table describes how each version works.</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="19%" />
<col width="22%" />
<col width="22%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Match</th>
<th class="head">NXM</th>
<th class="head">OF1.0</th>
<th class="head">OF1.1</th>
<th class="head">OF1.2</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">[1]</tt></td>
<td><tt class="docutils literal">0000/0000</tt></td>
<td><tt class="docutils literal"><span class="pre">????/1,??/?</span></tt></td>
<td><tt class="docutils literal"><span class="pre">????/1,??/?</span></tt></td>
<td><tt class="docutils literal"><span class="pre">0000/0000,--</span></tt></td>
</tr>
<tr><td><tt class="docutils literal">[2]</tt></td>
<td><tt class="docutils literal">0000/ffff</tt></td>
<td><tt class="docutils literal"><span class="pre">ffff/0,??/?</span></tt></td>
<td><tt class="docutils literal"><span class="pre">ffff/0,??/?</span></tt></td>
<td><tt class="docutils literal"><span class="pre">0000/ffff,--</span></tt></td>
</tr>
<tr><td><tt class="docutils literal">[3]</tt></td>
<td><tt class="docutils literal">1xxx/1fff</tt></td>
<td><tt class="docutils literal"><span class="pre">0xxx/0,??/1</span></tt></td>
<td><tt class="docutils literal"><span class="pre">0xxx/0,??/1</span></tt></td>
<td><tt class="docutils literal"><span class="pre">1xxx/ffff,--</span></tt></td>
</tr>
<tr><td><tt class="docutils literal">[4]</tt></td>
<td><tt class="docutils literal">z000/f000</tt></td>
<td><tt class="docutils literal"><span class="pre">????/1,0y/0</span></tt></td>
<td><tt class="docutils literal">fffe/0,0y/0</tt></td>
<td><tt class="docutils literal">1000/1000,0y</tt></td>
</tr>
<tr><td><tt class="docutils literal">[5]</tt></td>
<td><tt class="docutils literal">zxxx/ffff</tt></td>
<td><tt class="docutils literal">0xxx/0,0y/0</tt></td>
<td><tt class="docutils literal">0xxx/0,0y/0</tt></td>
<td><tt class="docutils literal">1xxx/ffff,0y</tt></td>
</tr>
<tr><td><tt class="docutils literal">[6]</tt></td>
<td><tt class="docutils literal">0000/0fff</tt></td>
<td><tt class="docutils literal">&lt;none&gt;</tt></td>
<td><tt class="docutils literal">&lt;none&gt;</tt></td>
<td><tt class="docutils literal">&lt;none&gt;</tt></td>
</tr>
<tr><td><tt class="docutils literal">[7]</tt></td>
<td><tt class="docutils literal">0000/f000</tt></td>
<td><tt class="docutils literal">&lt;none&gt;</tt></td>
<td><tt class="docutils literal">&lt;none&gt;</tt></td>
<td><tt class="docutils literal">&lt;none&gt;</tt></td>
</tr>
<tr><td><tt class="docutils literal">[8]</tt></td>
<td><tt class="docutils literal">0000/efff</tt></td>
<td><tt class="docutils literal">&lt;none&gt;</tt></td>
<td><tt class="docutils literal">&lt;none&gt;</tt></td>
<td><tt class="docutils literal">&lt;none&gt;</tt></td>
</tr>
<tr><td><tt class="docutils literal">[9]</tt></td>
<td><tt class="docutils literal">1001/1001</tt></td>
<td><tt class="docutils literal">&lt;none&gt;</tt></td>
<td><tt class="docutils literal">&lt;none&gt;</tt></td>
<td><tt class="docutils literal"><span class="pre">1001/1001,--</span></tt></td>
</tr>
<tr><td><tt class="docutils literal">[10]</tt></td>
<td><tt class="docutils literal">3000/3000</tt></td>
<td><tt class="docutils literal">&lt;none&gt;</tt></td>
<td><tt class="docutils literal">&lt;none&gt;</tt></td>
<td><tt class="docutils literal">&lt;none&gt;</tt></td>
</tr>
<tr><td><tt class="docutils literal">[11]</tt></td>
<td><tt class="docutils literal">1000/1000</tt></td>
<td><tt class="docutils literal">&lt;none&gt;</tt></td>
<td><tt class="docutils literal"><span class="pre">fffe/0,??/1</span></tt></td>
<td><tt class="docutils literal"><span class="pre">1000/1000,--</span></tt></td>
</tr>
</tbody>
</table>
<p>where:</p>
<dl class="docutils">
<dt>Match:</dt>
<dd>See the list below.</dd>
<dt>NXM:</dt>
<dd><tt class="docutils literal">xxxx/yyyy</tt> means <tt class="docutils literal">NXM_OF_VLAN_TCI_W</tt> with value <tt class="docutils literal">xxxx</tt> and mask
<tt class="docutils literal">yyyy</tt>.  A mask of <tt class="docutils literal">0000</tt> is equivalent to omitting
<tt class="docutils literal">NXM_OF_VLAN_TCI(_W)</tt>, a mask of <tt class="docutils literal">ffff</tt> is equivalent to
<tt class="docutils literal">NXM_OF_VLAN_TCI</tt>.</dd>
<dt>OF1.0, OF1.1:</dt>
<dd><tt class="docutils literal">wwww/x,yy/z</tt> means <tt class="docutils literal">dl_vlan</tt> <tt class="docutils literal">wwww</tt>, <tt class="docutils literal">OFPFW_DL_VLAN</tt> <tt class="docutils literal">x</tt>,
<tt class="docutils literal">dl_vlan_pcp</tt> <tt class="docutils literal">yy</tt>, and <tt class="docutils literal">OFPFW_DL_VLAN_PCP</tt> <tt class="docutils literal">z</tt>.  If
<tt class="docutils literal">OFPFW_DL_VLAN</tt> or <tt class="docutils literal">OFPFW_DL_VLAN_PCP</tt> is 1, the corresponding field
value is wildcarded, otherwise it is matched.  <tt class="docutils literal">?</tt> means that the given
bits are ignored (their conventional values are <tt class="docutils literal">0000/x,00/0</tt> in OF1.0,
<tt class="docutils literal">0000/x,00/1</tt> in OF1.1; <tt class="docutils literal">x</tt> is never ignored).  <tt class="docutils literal">&lt;none&gt;</tt> means that the
given match is not supported.</dd>
<dt>OF1.2:</dt>
<dd><tt class="docutils literal">xxxx/yyyy,zz</tt> means <tt class="docutils literal">OXM_OF_VLAN_VID_W</tt> with value <tt class="docutils literal">xxxx</tt> and mask
<tt class="docutils literal">yyyy</tt>, and <tt class="docutils literal">OXM_OF_VLAN_PCP</tt> (which is not maskable) with value <tt class="docutils literal">zz</tt>.
A mask of <tt class="docutils literal">0000</tt> is equivalent to omitting <tt class="docutils literal">OXM_OF_VLAN_VID(_W)</tt>, a mask
of <tt class="docutils literal">ffff</tt> is equivalent to <tt class="docutils literal">OXM_OF_VLAN_VID</tt>.  <tt class="docutils literal"><span class="pre">--</span></tt> means that
<tt class="docutils literal">OXM_OF_VLAN_PCP</tt> is omitted.  <tt class="docutils literal">&lt;none&gt;</tt> means that the given match is not
supported.</dd>
</dl>
<p>The matches are:</p>
<dl class="docutils">
<dt><tt class="docutils literal">[1]</tt>:</dt>
<dd>Matches any packet, that is, one without an 802.1Q header or with an 802.1Q
header with any TCI value.</dd>
<dt><tt class="docutils literal">[2]</tt></dt>
<dd><p class="first">Matches only packets without an 802.1Q header.</p>
<dl class="last docutils">
<dt>NXM:</dt>
<dd>Any match with <tt class="docutils literal">vlan_tci == 0</tt> and <tt class="docutils literal">(vlan_tci_mask &amp; 0x1000) != 0</tt> is
equivalent to the one listed in the table.</dd>
<dt>OF1.0:</dt>
<dd>The spec doesn't define behavior if <tt class="docutils literal">dl_vlan</tt> is set to <tt class="docutils literal">0xffff</tt> and
<tt class="docutils literal">OFPFW_DL_VLAN_PCP</tt> is not set.</dd>
<dt>OF1.1:</dt>
<dd>The spec says explicitly to ignore <tt class="docutils literal">dl_vlan_pcp</tt> when <tt class="docutils literal">dl_vlan</tt> is set
to <tt class="docutils literal">0xffff</tt>.</dd>
<dt>OF1.2:</dt>
<dd>The spec doesn't say what should happen if <tt class="docutils literal">vlan_vid == 0</tt> and
<tt class="docutils literal">(vlan_vid_mask &amp; 0x1000) != 0</tt> but <tt class="docutils literal">vlan_vid_mask != 0x1000</tt>, but it
would be straightforward to also interpret as <tt class="docutils literal">[2]</tt>.</dd>
</dl>
</dd>
<dt><tt class="docutils literal">[3]</tt></dt>
<dd>Matches only packets that have an 802.1Q header with VID <tt class="docutils literal">xxx</tt> (and any
PCP).</dd>
<dt><tt class="docutils literal">[4]</tt></dt>
<dd><p class="first">Matches only packets that have an 802.1Q header with PCP <tt class="docutils literal">y</tt> (and any VID).</p>
<dl class="last docutils">
<dt>NXM:</dt>
<dd><tt class="docutils literal">z</tt> is <tt class="docutils literal">(y &lt;&lt; 1) | 1</tt>.</dd>
<dt>OF1.0:</dt>
<dd>The spec isn't very clear, but OVS implements it this way.</dd>
<dt>OF1.2:</dt>
<dd>Presumably other masks such that <tt class="docutils literal">(vlan_vid_mask &amp; 0x1fff) == 0x1000</tt>
would also work, but the spec doesn't define their behavior.</dd>
</dl>
</dd>
<dt><tt class="docutils literal">[5]</tt></dt>
<dd><p class="first">Matches only packets that have an 802.1Q header with VID <tt class="docutils literal">xxx</tt> and PCP
<tt class="docutils literal">y</tt>.</p>
<blockquote class="last">
<dl class="docutils">
<dt>NXM:</dt>
<dd><tt class="docutils literal">z</tt> is <tt class="docutils literal">((y &lt;&lt; 1) | 1)</tt>.</dd>
<dt>OF1.2:</dt>
<dd>Presumably other masks such that <tt class="docutils literal">(vlan_vid_mask &amp; 0x1fff) == 0x1fff</tt>
would also work.</dd>
</dl>
</blockquote>
</dd>
<dt><tt class="docutils literal">[6]</tt></dt>
<dd>Matches packets with no 802.1Q header or with an 802.1Q header with a VID of
0.  Only possible with NXM.</dd>
<dt><tt class="docutils literal">[7]</tt></dt>
<dd>Matches packets with no 802.1Q header or with an 802.1Q header with a PCP of
0.  Only possible with NXM.</dd>
<dt><tt class="docutils literal">[8]</tt></dt>
<dd>Matches packets with no 802.1Q header or with an 802.1Q header with both VID
and PCP of 0.  Only possible with NXM.</dd>
<dt><tt class="docutils literal">[9]</tt></dt>
<dd>Matches only packets that have an 802.1Q header with an odd-numbered VID (and
any PCP).  Only possible with NXM and OF1.2.  (This is just an example; one
can match on any desired VID bit pattern.)</dd>
<dt><tt class="docutils literal">[10]</tt></dt>
<dd>Matches only packets that have an 802.1Q header with an odd-numbered PCP (and
any VID).  Only possible with NXM.  (This is just an example; one can match
on any desired VID bit pattern.)</dd>
<dt><tt class="docutils literal">[11]</tt></dt>
<dd>Matches any packet with an 802.1Q header, regardless of VID or PCP.</dd>
</dl>
<p>Additional notes:</p>
<dl class="docutils">
<dt>OF1.2:</dt>
<dd>The top three bits of <tt class="docutils literal">OXM_OF_VLAN_VID</tt> are fixed to zero, so bits 13, 14,
and 15 in the masks listed in the table may be set to arbitrary values, as
long as the corresponding value bits are also zero.  The suggested <tt class="docutils literal">ffff</tt>
mask for [2], [3], and [5] allows a shorter OXM representation (the mask is
omitted) than the minimal <tt class="docutils literal">1fff</tt> mask.</dd>
</dl>
</div>
<div class="section" id="flow-cookies">
<h1>Flow Cookies</h1>
<p>OpenFlow 1.0 and later versions have the concept of a &quot;flow cookie&quot;, which is a
64-bit integer value attached to each flow.  The treatment of the flow cookie
has varied greatly across OpenFlow versions, however.</p>
<p>In OpenFlow 1.0:</p>
<ul class="simple">
<li><tt class="docutils literal">OFPFC_ADD</tt> set the cookie in the flow that it added.</li>
<li><tt class="docutils literal">OFPFC_MODIFY</tt> and <tt class="docutils literal">OFPFC_MODIFY_STRICT</tt> updated the cookie for the flow
or flows that it modified.</li>
<li><tt class="docutils literal">OFPST_FLOW</tt> messages included the flow cookie.</li>
<li><tt class="docutils literal">OFPT_FLOW_REMOVED</tt> messages reported the cookie of the flow that was
removed.</li>
</ul>
<p>OpenFlow 1.1 made the following changes:</p>
<ul class="simple">
<li>Flow mod operations <tt class="docutils literal">OFPFC_MODIFY</tt>, <tt class="docutils literal">OFPFC_MODIFY_STRICT</tt>,
<tt class="docutils literal">OFPFC_DELETE</tt>, and <tt class="docutils literal">OFPFC_DELETE_STRICT</tt>, plus flow stats requests and
aggregate stats requests, gained the ability to match on flow cookies with an
arbitrary mask.</li>
<li><tt class="docutils literal">OFPFC_MODIFY</tt> and <tt class="docutils literal">OFPFC_MODIFY_STRICT</tt> were changed to add a new flow,
in the case of no match, only if the flow table modification operation did
not match on the cookie field.  (In OpenFlow 1.0, modify operations always
added a new flow when there was no match.)</li>
<li><tt class="docutils literal">OFPFC_MODIFY</tt> and <tt class="docutils literal">OFPFC_MODIFY_STRICT</tt> no longer updated flow cookies.</li>
</ul>
<p>OpenFlow 1.2 made the following changes:</p>
<ul class="simple">
<li><tt class="docutils literal">OFPC_MODIFY</tt> and <tt class="docutils literal">OFPFC_MODIFY_STRICT</tt> were changed to never add a new
flow, regardless of whether the flow cookie was used for matching.</li>
</ul>
<p>Open vSwitch support for OpenFlow 1.0 implements the OpenFlow 1.0 behavior with
the following extensions:</p>
<ul class="simple">
<li>An NXM extension field <tt class="docutils literal">NXM_NX_COOKIE(_W)</tt> allows the NXM versions of
<tt class="docutils literal">OFPFC_MODIFY</tt>, <tt class="docutils literal">OFPFC_MODIFY_STRICT</tt>, <tt class="docutils literal">OFPFC_DELETE</tt>, and
<tt class="docutils literal">OFPFC_DELETE_STRICT</tt> <tt class="docutils literal">flow_mod</tt> calls, plus flow stats requests and
aggregate stats requests, to match on flow cookies with arbitrary masks.
This is much like the equivalent OpenFlow 1.1 feature.</li>
<li>Like OpenFlow 1.1, <tt class="docutils literal">OFPC_MODIFY</tt> and <tt class="docutils literal">OFPFC_MODIFY_STRICT</tt> add a new flow
if there is no match and the mask is zero (or not given).</li>
<li>The <tt class="docutils literal">cookie</tt> field in <tt class="docutils literal">OFPT_FLOW_MOD</tt> and <tt class="docutils literal">NXT_FLOW_MOD</tt> messages is
used as the cookie value for <tt class="docutils literal">OFPFC_ADD</tt> commands, as described in OpenFlow
1.0.  For <tt class="docutils literal">OFPFC_MODIFY</tt> and <tt class="docutils literal">OFPFC_MODIFY_STRICT</tt> commands, the
<tt class="docutils literal">cookie</tt> field is used as a new cookie for flows that match unless it is
<tt class="docutils literal">UINT64_MAX</tt>, in which case the flow's cookie is not updated.</li>
<li><tt class="docutils literal">NXT_PACKET_IN</tt> (the Nicira extended version of <tt class="docutils literal">OFPT_PACKET_IN</tt>) reports
the cookie of the rule that generated the packet, or all-1-bits if no rule
generated the packet.  (Older versions of OVS used all-0-bits instead of
all-1-bits.)</li>
</ul>
<p>The following table shows the handling of different protocols when receiving
<tt class="docutils literal">OFPFC_MODIFY</tt> and <tt class="docutils literal">OFPFC_MODIFY_STRICT</tt> messages.  A mask of 0 indicates
either an explicit mask of zero or an implicit one by not specifying the
<tt class="docutils literal">NXM_NX_COOKIE(_W)</tt> field.</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="12%" />
<col width="12%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>OpenFlow 1.0</td>
<td>no</td>
<td>yes</td>
<td>(add on miss)</td>
<td>(add on miss)</td>
</tr>
<tr><td>OpenFlow 1.1</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr><td>OpenFlow 1.2</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr><td>NXM</td>
<td>yes</td>
<td>yes*</td>
<td>no</td>
<td>yes</td>
</tr>
</tbody>
</table>
<p>* Updates the flow's cookie unless the <tt class="docutils literal">cookie</tt> field is <tt class="docutils literal">UINT64_MAX</tt>.</p>
</div>
<div class="section" id="multiple-table-support">
<h1>Multiple Table Support</h1>
<p>OpenFlow 1.0 has only rudimentary support for multiple flow tables.  Notably,
OpenFlow 1.0 does not allow the controller to specify the flow table to which a
flow is to be added.  Open vSwitch adds an extension for this purpose, which is
enabled on a per-OpenFlow connection basis using the <tt class="docutils literal">NXT_FLOW_MOD_TABLE_ID</tt>
message.  When the extension is enabled, the upper 8 bits of the <tt class="docutils literal">command</tt>
member in an <tt class="docutils literal">OFPT_FLOW_MOD</tt> or <tt class="docutils literal">NXT_FLOW_MOD</tt> message designates the table
to which a flow is to be added.</p>
<p>The Open vSwitch software switch implementation offers 255 flow tables.  On
packet ingress, only the first flow table (table 0) is searched, and the
contents of the remaining tables are not considered in any way.  Tables other
than table 0 only come into play when an <tt class="docutils literal">NXAST_RESUBMIT_TABLE</tt> action
specifies another table to search.</p>
<p>Tables 128 and above are reserved for use by the switch itself.  Controllers
should use only tables 0 through 127.</p>
</div>
<div class="section" id="ofptc-table-configuration">
<h1><tt class="docutils literal">OFPTC_*</tt> Table Configuration</h1>
<p>This section covers the history of the <tt class="docutils literal">OFPTC_*</tt> table configuration bits
across OpenFlow versions.</p>
<p>OpenFlow 1.0 flow tables had fixed configurations.</p>
<p>OpenFlow 1.1 enabled controllers to configure behavior upon flow table miss and
added the <tt class="docutils literal">OFPTC_MISS_*</tt> constants for that purpose.  <tt class="docutils literal">OFPTC_*</tt> did not
control anything else but it was nevertheless conceptualized as a set of
bit-fields instead of an enum.  OF1.1 added the <tt class="docutils literal">OFPT_TABLE_MOD</tt> message to
set <tt class="docutils literal">OFPTC_MISS_*</tt> for a flow table and added the <tt class="docutils literal">config</tt> field to the
<tt class="docutils literal">OFPST_TABLE</tt> reply to report the current setting.</p>
<p>OpenFlow 1.2 did not change anything in this regard.</p>
<p>OpenFlow 1.3 switched to another means to changing flow table miss behavior and
deprecated <tt class="docutils literal">OFPTC_MISS_*</tt> without adding any more <tt class="docutils literal">OFPTC_*</tt> constants.
This meant that <tt class="docutils literal">OFPT_TABLE_MOD</tt> now had no purpose at all, but OF1.3 kept it
around &quot;for backward compatibility with older and newer versions of the
specification.&quot;  At the same time, OF1.3 introduced a new message
OFPMP_TABLE_FEATURES that included a field <tt class="docutils literal">config</tt> documented as reporting
the <tt class="docutils literal">OFPTC_*</tt> values set with <tt class="docutils literal">OFPT_TABLE_MOD</tt>; of course this served no
real purpose because no <tt class="docutils literal">OFPTC_*</tt> values are defined.  OF1.3 did remove the
<tt class="docutils literal">OFPTC_*</tt> field from <tt class="docutils literal">OFPMP_TABLE</tt> (previously named <tt class="docutils literal">OFPST_TABLE</tt>).</p>
<p>OpenFlow 1.4 defined two new <tt class="docutils literal">OFPTC_*</tt> constants, <tt class="docutils literal">OFPTC_EVICTION</tt> and
<tt class="docutils literal">OFPTC_VACANCY_EVENTS</tt>, using bits that did not overlap with <tt class="docutils literal">OFPTC_MISS_*</tt>
even though those bits had not been defined since OF1.2.  <tt class="docutils literal">OFPT_TABLE_MOD</tt>
still controlled these settings.  The field for <tt class="docutils literal">OFPTC_*</tt> values in
<tt class="docutils literal">OFPMP_TABLE_FEATURES</tt> was renamed from <tt class="docutils literal">config</tt> to <tt class="docutils literal">capabilities</tt> and
documented as reporting the flags that are supported in a <tt class="docutils literal">OFPT_TABLE_MOD</tt>
message.  The <tt class="docutils literal">OFPMP_TABLE_DESC</tt> message newly added in OF1.4 reported the
<tt class="docutils literal">OFPTC_*</tt> setting.</p>
<p>OpenFlow 1.5 did not change anything in this regard.</p>
<table border="1" class="docutils">
<caption>Revisions</caption>
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">OpenFlow</th>
<th class="head"><tt class="docutils literal">OFPTC_*</tt> flags</th>
<th class="head"><tt class="docutils literal">TABLE_MOD</tt></th>
<th class="head">Statistics</th>
<th class="head"><tt class="docutils literal">TABLE_FEATURES</tt></th>
<th class="head"><tt class="docutils literal">TABLE_DESC</tt></th>
</tr>
</thead>
<tbody valign="top">
<tr><td>OF1.0</td>
<td>none</td>
<td>no (*)(+)</td>
<td>no (*)</td>
<td>nothing (*)(+)</td>
<td>no (*)(+)</td>
</tr>
<tr><td>OF1.1/1.2</td>
<td><tt class="docutils literal">MISS_*</tt></td>
<td>yes</td>
<td>yes</td>
<td>nothing (+)</td>
<td>no (+)</td>
</tr>
<tr><td>OF1.3</td>
<td>none</td>
<td>yes (*)</td>
<td>no (*)</td>
<td>config (*)</td>
<td>no (*)(+)</td>
</tr>
<tr><td>OF1.4/1.5</td>
<td><tt class="docutils literal">EVICTION</tt>/<tt class="docutils literal">VACANCY_EVENTS</tt></td>
<td>yes</td>
<td>no</td>
<td>capabilities</td>
<td>yes</td>
</tr>
</tbody>
</table>
<p>where:</p>
<dl class="docutils">
<dt>OpenFlow:</dt>
<dd>The OpenFlow version(s).</dd>
<dt><tt class="docutils literal">OFPTC_*</tt> flags:</dt>
<dd>The <tt class="docutils literal">OFPTC_*</tt> flags defined in those versions.</dd>
<dt><tt class="docutils literal">TABLE_MOD</tt>:</dt>
<dd>Whether <tt class="docutils literal">OFPT_TABLE_MOD</tt> can modify <tt class="docutils literal">OFPTC_*</tt> flags.</dd>
<dt>Statistics:</dt>
<dd>Whether <tt class="docutils literal">OFPST_TABLE/OFPMP_TABLE</tt> reports the <tt class="docutils literal">OFPTC_*</tt> flags.</dd>
<dt><tt class="docutils literal">TABLE_FEATURES</tt>:</dt>
<dd>What <tt class="docutils literal">OFPMP_TABLE_FEATURES</tt> reports (if it exists): either the current
configuration or the switch's capabilities.</dd>
<dt><tt class="docutils literal">TABLE_DESC</tt>:</dt>
<dd>Whether <tt class="docutils literal">OFPMP_TABLE_DESC</tt> reports the current configuration.</dd>
</dl>
<p>(*): Nothing to report/change anyway.</p>
<p>(+): No such message.</p>
</div>
<div class="section" id="ipv6">
<h1>IPv6</h1>
<p>Open vSwitch supports stateless handling of IPv6 packets.  Flows can be written
to support matching TCP, UDP, and ICMPv6 headers within an IPv6 packet.  Deeper
matching of some Neighbor Discovery messages is also supported.</p>
<p>IPv6 was not designed to interact well with middle-boxes.  This, combined with
Open vSwitch's stateless nature, have affected the processing of IPv6 traffic,
which is detailed below.</p>
<div class="section" id="extension-headers">
<h2>Extension Headers</h2>
<p>The base IPv6 header is incredibly simple with the intention of only containing
information relevant for routing packets between two endpoints.  IPv6 relies
heavily on the use of extension headers to provide any other functionality.
Unfortunately, the extension headers were designed in such a way that it is
impossible to move to the next header (including the layer-4 payload) unless
the current header is understood.</p>
<p>Open vSwitch will process the following extension headers and continue to the
next header:</p>
<ul class="simple">
<li>Fragment (see the next section)</li>
<li>AH (Authentication Header)</li>
<li>Hop-by-Hop Options</li>
<li>Routing</li>
<li>Destination Options</li>
</ul>
<p>When a header is encountered that is not in that list, it is considered
&quot;terminal&quot;.  A terminal header's IPv6 protocol value is stored in <tt class="docutils literal">nw_proto</tt>
for matching purposes.  If a terminal header is TCP, UDP, or ICMPv6, the packet
will be further processed in an attempt to extract layer-4 information.</p>
</div>
<div class="section" id="fragments">
<h2>Fragments</h2>
<p>IPv6 requires that every link in the internet have an MTU of 1280 octets or
greater (RFC 2460).  As such, a terminal header (as described above in
&quot;Extension Headers&quot;) in the first fragment should generally be reachable.  In
this case, the terminal header's IPv6 protocol type is stored in the
<tt class="docutils literal">nw_proto</tt> field for matching purposes.  If a terminal header cannot be found
in the first fragment (one with a fragment offset of zero), the <tt class="docutils literal">nw_proto</tt>
field is set to 0.  Subsequent fragments (those with a non-zero fragment
offset) have the <tt class="docutils literal">nw_proto</tt> field set to the IPv6 protocol type for fragments
(44).</p>
</div>
<div class="section" id="jumbograms">
<h2>Jumbograms</h2>
<p>An IPv6 jumbogram (RFC 2675) is a packet containing a payload longer than
65,535 octets.  A jumbogram is only relevant in subnets with a link MTU greater
than 65,575 octets, and are not required to be supported on nodes that do not
connect to link with such large MTUs.  Currently, Open vSwitch doesn't process
jumbograms.</p>
</div>
</div>
<div class="section" id="in-band-control">
<h1>In-Band Control</h1>
<div class="section" id="motivation">
<h2>Motivation</h2>
<p>An OpenFlow switch must establish and maintain a TCP network connection to its
controller.  There are two basic ways to categorize the network that this
connection traverses: either it is completely separate from the one that the
switch is otherwise controlling, or its path may overlap the network that the
switch controls.  We call the former case &quot;out-of-band control&quot;, the latter
case &quot;in-band control&quot;.</p>
<p>Out-of-band control has the following benefits:</p>
<ul class="simple">
<li>Simplicity: Out-of-band control slightly simplifies the switch
implementation.</li>
<li>Reliability: Excessive switch traffic volume cannot interfere with control
traffic.</li>
<li>Integrity: Machines not on the control network cannot impersonate a switch or
a controller.</li>
<li>Confidentiality: Machines not on the control network cannot snoop on control
traffic.</li>
</ul>
<p>In-band control, on the other hand, has the following advantages:</p>
<ul class="simple">
<li>No dedicated port: There is no need to dedicate a physical switch port to
control, which is important on switches that have few ports (e.g. wireless
routers, low-end embedded platforms).</li>
<li>No dedicated network: There is no need to build and maintain a separate
control network.  This is important in many environments because it reduces
proliferation of switches and wiring.</li>
</ul>
<p>Open vSwitch supports both out-of-band and in-band control.  This section
describes the principles behind in-band control.  See the description of the
Controller table in ovs-vswitchd.conf.db(5) to configure OVS for in-band
control.</p>
</div>
<div class="section" id="principles">
<h2>Principles</h2>
<p>The fundamental principle of in-band control is that an OpenFlow switch must
recognize and switch control traffic without involving the OpenFlow controller.
All the details of implementing in-band control are special cases of this
principle.</p>
<p>The rationale for this principle is simple.  If the switch does not handle
in-band control traffic itself, then it will be caught in a contradiction: it
must contact the controller, but it cannot, because only the controller can set
up the flows that are needed to contact the controller.</p>
<p>The following points describe important special cases of this principle.</p>
<ul>
<li><p class="first">In-band control must be implemented regardless of whether the switch is
connected.</p>
<p>It is tempting to implement the in-band control rules only when the switch is
not connected to the controller, using the reasoning that the controller
should have complete control once it has established a connection with the
switch.</p>
<p>This does not work in practice.  Consider the case where the switch is
connected to the controller.  Occasionally it can happen that the controller
forgets or otherwise needs to obtain the MAC address of the switch.  To do
so, the controller sends a broadcast ARP request.  A switch that implements
the in-band control rules only when it is disconnected will then send an
<tt class="docutils literal">OFPT_PACKET_IN</tt> message up to the controller.  The controller will be
unable to respond, because it does not know the MAC address of the switch.
This is a deadlock situation that can only be resolved by the switch noticing
that its connection to the controller has hung and reconnecting.</p>
</li>
<li><p class="first">In-band control must override flows set up by the controller.</p>
<p>It is reasonable to assume that flows set up by the OpenFlow controller
should take precedence over in-band control, on the basis that the controller
should be in charge of the switch.</p>
<p>Again, this does not work in practice.  Reasonable controller implementations
may set up a &quot;last resort&quot; fallback rule that wildcards every field and,
e.g., sends it up to the controller or discards it.  If a controller does
that, then it will isolate itself from the switch.</p>
</li>
<li><p class="first">The switch must recognize all control traffic.</p>
<p>The fundamental principle of in-band control states, in part, that a switch
must recognize control traffic without involving the OpenFlow controller.
More specifically, the switch must recognize <em>all</em> control traffic.  &quot;False
negatives&quot;, that is, packets that constitute control traffic but that the
switch does not recognize as control traffic, lead to control traffic storms.</p>
<p>Consider an OpenFlow switch that only recognizes control packets sent to or
from that switch.  Now suppose that two switches of this type, named A and B,
are connected to ports on an Ethernet hub (not a switch) and that an OpenFlow
controller is connected to a third hub port.  In this setup, control traffic
sent by switch A will be seen by switch B, which will send it to the
controller as part of an OFPT_PACKET_IN message.  Switch A will then see the
OFPT_PACKET_IN message's packet, re-encapsulate it in another OFPT_PACKET_IN,
and send it to the controller.  Switch B will then see that OFPT_PACKET_IN,
and so on in an infinite loop.</p>
<p>Incidentally, the consequences of &quot;false positives&quot;, where packets that are
not control traffic are nevertheless recognized as control traffic, are much
less severe.  The controller will not be able to control their behavior, but
the network will remain in working order.  False positives do constitute a
security problem.</p>
</li>
<li><p class="first">The switch should use echo-requests to detect disconnection.</p>
<p>TCP will notice that a connection has hung, but this can take a considerable
amount of time.  For example, with default settings the Linux kernel TCP
implementation will retransmit for between 13 and 30 minutes, depending on
the connection's retransmission timeout, according to kernel documentation.
This is far too long for a switch to be disconnected, so an OpenFlow switch
should implement its own connection timeout.  OpenFlow <tt class="docutils literal">OFPT_ECHO_REQUEST</tt>
messages are the best way to do this, since they test the OpenFlow connection
itself.</p>
</li>
</ul>
</div>
<div class="section" id="implementation">
<h2>Implementation</h2>
<p>This section describes how Open vSwitch implements in-band control.  Correctly
implementing in-band control has proven difficult due to its many subtleties,
and has thus gone through many iterations.  Please read through and understand
the reasoning behind the chosen rules before making modifications.</p>
<p>Open vSwitch implements in-band control as &quot;hidden&quot; flows, that is, flows that
are not visible through OpenFlow, and at a higher priority than wildcarded
flows can be set up through OpenFlow.  This is done so that the OpenFlow
controller cannot interfere with them and possibly break connectivity with its
switches.  It is possible to see all flows, including in-band ones, with the
ovs-appctl &quot;bridge/dump-flows&quot; command.</p>
<p>The Open vSwitch implementation of in-band control can hide traffic to
arbitrary &quot;remotes&quot;, where each remote is one TCP port on one IP address.
Currently the remotes are automatically configured as the in-band OpenFlow
controllers plus the OVSDB managers, if any.  (The latter is a requirement
because OVSDB managers are responsible for configuring OpenFlow controllers, so
if the manager cannot be reached then OpenFlow cannot be reconfigured.)</p>
<p>The following rules (with the OFPP_NORMAL action) are set up on any bridge that
has any remotes:</p>
<ol class="loweralpha simple">
<li>DHCP requests sent from the local port.</li>
<li>ARP replies to the local port's MAC address.</li>
<li>ARP requests from the local port's MAC address.</li>
</ol>
<p>In-band also sets up the following rules for each unique next-hop MAC address
for the remotes' IPs (the &quot;next hop&quot; is either the remote itself, if it is on a
local subnet, or the gateway to reach the remote):</p>
<ol class="loweralpha simple" start="4">
<li>ARP replies to the next hop's MAC address.</li>
<li>ARP requests from the next hop's MAC address.</li>
</ol>
<p>In-band also sets up the following rules for each unique remote IP address:</p>
<ol class="loweralpha simple" start="6">
<li>ARP replies containing the remote's IP address as a target.</li>
<li>ARP requests containing the remote's IP address as a source.</li>
</ol>
<p>In-band also sets up the following rules for each unique remote (IP,port) pair:</p>
<ol class="loweralpha simple" start="8">
<li>TCP traffic to the remote's IP and port.</li>
<li>TCP traffic from the remote's IP and port.</li>
</ol>
<p>The goal of these rules is to be as narrow as possible to allow a switch to
join a network and be able to communicate with the remotes.  As mentioned
earlier, these rules have higher priority than the controller's rules, so if
they are too broad, they may prevent the controller from implementing its
policy.  As such, in-band actively monitors some aspects of flow and packet
processing so that the rules can be made more precise.</p>
<p>In-band control monitors attempts to add flows into the datapath that could
interfere with its duties.  The datapath only allows exact match entries, so
in-band control is able to be very precise about the flows it prevents.  Flows
that miss in the datapath are sent to userspace to be processed, so preventing
these flows from being cached in the &quot;fast path&quot; does not affect correctness.
The only type of flow that is currently prevented is one that would prevent
DHCP replies from being seen by the local port.  For example, a rule that
forwarded all DHCP traffic to the controller would not be allowed, but one that
forwarded to all ports (including the local port) would.</p>
<p>As mentioned earlier, packets that miss in the datapath are sent to the
userspace for processing.  The userspace has its own flow table, the
&quot;classifier&quot;, so in-band checks whether any special processing is needed before
the classifier is consulted.  If a packet is a DHCP response to a request from
the local port, the packet is forwarded to the local port, regardless of the
flow table.  Note that this requires L7 processing of DHCP replies to determine
whether the 'chaddr' field matches the MAC address of the local port.</p>
<p>It is interesting to note that for an L3-based in-band control mechanism, the
majority of rules are devoted to ARP traffic.  At first glance, some of these
rules appear redundant.  However, each serves an important role.  First, in
order to determine the MAC address of the remote side (controller or gateway)
for other ARP rules, we must allow ARP traffic for our local port with rules
(b) and (c).  If we are between a switch and its connection to the remote, we
have to allow the other switch's ARP traffic to through.  This is done with
rules (d) and (e), since we do not know the addresses of the other switches a
priori, but do know the remote's or gateway's.  Finally, if the remote is
running in a local guest VM that is not reached through the local port, the
switch that is connected to the VM must allow ARP traffic based on the remote's
IP address, since it will not know the MAC address of the local port that is
sending the traffic or the MAC address of the remote in the guest VM.</p>
<p>With a few notable exceptions below, in-band should work in most network
setups.  The following are considered &quot;supported&quot; in the current
implementation:</p>
<ul class="simple">
<li>Locally Connected.  The switch and remote are on the same subnet.  This uses
rules (a), (b), (c), (h), and (i).</li>
<li>Reached through Gateway.  The switch and remote are on different subnets and
must go through a gateway.  This uses rules (a), (b), (c), (h), and (i).</li>
<li>Between Switch and Remote.  This switch is between another switch and the
remote, and we want to allow the other switch's traffic through.  This uses
rules (d), (e), (h), and (i).  It uses (b) and (c) indirectly in order to
know the MAC address for rules (d) and (e).  Note that DHCP for the other
switch will not work unless an OpenFlow controller explicitly lets this
switch pass the traffic.</li>
<li>Between Switch and Gateway.  This switch is between another switch and the
gateway, and we want to allow the other switch's traffic through.  This uses
the same rules and logic as the &quot;Between Switch and Remote&quot; configuration
described earlier.</li>
<li>Remote on Local VM.  The remote is a guest VM on the system running in-band
control.  This uses rules (a), (b), (c), (h), and (i).</li>
<li>Remote on Local VM with Different Networks.  The remote is a guest VM on the
system running in-band control, but the local port is not used to connect to
the remote.  For example, an IP address is configured on eth0 of the switch.
The remote's VM is connected through eth1 of the switch, but an IP address
has not been configured for that port on the switch.  As such, the switch
will use eth0 to connect to the remote, and eth1's rules about the local port
will not work.  In the example, the switch attached to eth0 would use rules
(a), (b), (c), (h), and (i) on eth0.  The switch attached to eth1 would use
rules (f), (g), (h), and (i).</li>
</ul>
<p>The following are explicitly <em>not</em> supported by in-band control:</p>
<ul class="simple">
<li>Specify Remote by Name.  Currently, the remote must be identified by IP
address.  A naive approach would be to permit all DNS traffic.
Unfortunately, this would prevent the controller from defining any policy
over DNS.  Since switches that are located behind us need to connect to the
remote, in-band cannot simply add a rule that allows DNS traffic from the
local port.  The &quot;correct&quot; way to support this is to parse DNS requests to
allow all traffic related to a request for the remote's name through.  Due to
the potential security problems and amount of processing, we decided to hold
off for the time-being.</li>
<li>Differing Remotes for Switches.  All switches must know the L3 addresses for
all the remotes that other switches may use, since rules need to be set up to
allow traffic related to those remotes through.  See rules (f), (g), (h), and
(i).</li>
<li>Differing Routes for Switches.  In order for the switch to allow other
switches to connect to a remote through a gateway, it allows the gateway's
traffic through with rules (d) and (e).  If the routes to the remote differ
for the two switches, we will not know the MAC address of the alternate
gateway.</li>
</ul>
</div>
</div>
<div class="section" id="action-reproduction">
<h1>Action Reproduction</h1>
<p>It seems likely that many controllers, at least at startup, use the OpenFlow
&quot;flow statistics&quot; request to obtain existing flows, then compare the flows'
actions against the actions that they expect to find.  Before version 1.8.0,
Open vSwitch always returned exact, byte-for-byte copies of the actions that
had been added to the flow table.  The current version of Open vSwitch does not
always do this in some exceptional cases.  This section lists the exceptions
that controller authors must keep in mind if they compare actual actions
against desired actions in a bytewise fashion:</p>
<ul class="simple">
<li>Open vSwitch zeros padding bytes in action structures, regardless of their
values when the flows were added.</li>
<li>Open vSwitch &quot;normalizes&quot; the instructions in OpenFlow 1.1 (and later) in the
following way:<ul>
<li>OVS sorts the instructions into the following order: Apply-Actions,
Clear-Actions, Write-Actions, Write-Metadata, Goto-Table.</li>
<li>OVS drops Apply-Actions instructions that have empty action lists.</li>
<li>OVS drops Write-Actions instructions that have empty action sets.</li>
</ul>
</li>
</ul>
<p>Please report other discrepancies, if you notice any, so that we can fix or
document them.</p>
</div>
<div class="section" id="suggestions">
<h1>Suggestions</h1>
<p>Suggestions to improve Open vSwitch are welcome at <a class="reference external" href="mailto:discuss&#64;openvswitch.org">discuss&#64;openvswitch.org</a>.</p>
</div>
</div>
</body>
</html>
