<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>tutorial/ovn-tutorial.rst (Open vSwitch 2.6.90)</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="ovn-tutorial">
<h1 class="title">OVN Tutorial</h1>

<!-- Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations
under the License.

Convention for heading levels in Open vSwitch documentation:

=======  Heading 0 (reserved for the title in a document)
- - - - - - -  Heading 1
~~~~~~~  Heading 2
+++++++  Heading 3
'''''''  Heading 4

Avoid deeper levels because they do not render well. -->
<p>This tutorial is intended to give you a tour of the basic OVN features using
<tt class="docutils literal"><span class="pre">ovs-sandbox</span></tt> as a simulated test environment.  It's assumed that you have an
understanding of OVS before going through this tutorial. Detail about OVN is
covered in <a class="reference external" href="http://openvswitch.org/support/dist-docs/ovn-architecture.7.html">ovn-architecture</a>, but this tutorial lets you quickly see it in
action.</p>
<div class="section" id="getting-started">
<h1>Getting Started</h1>
<p>For some general information about <tt class="docutils literal"><span class="pre">ovs-sandbox</span></tt>, see the &quot;Getting Started&quot;
section of the <a class="reference external" href="https://github.com/openvswitch/ovs/blob/master/tutorial/tutorial.rst">tutorial</a>.</p>
<p><tt class="docutils literal"><span class="pre">ovs-sandbox</span></tt> does not include OVN support by default.  To enable OVN, you
must pass the <tt class="docutils literal"><span class="pre">--ovn</span></tt> flag.  For example, if running it straight from the ovs
git tree you would run:</p>
<pre class="literal-block">
$ make sandbox SANDBOXFLAGS=&quot;--ovn&quot;
</pre>
<p>Running the sandbox with OVN enabled does the following additional steps to the
environment:</p>
<ol class="arabic simple">
<li>Creates the <tt class="docutils literal">OVN_Northbound</tt> and <tt class="docutils literal">OVN_Southbound</tt> databases as described in
<a class="reference external" href="http://openvswitch.org/support/dist-docs/ovn-nb.5.html">ovn-nb(5)</a> and <a class="reference external" href="http://openvswitch.org/support/dist-docs/ovn-sb.5.html">ovn-sb(5)</a>.</li>
<li>Creates a backup server for <tt class="docutils literal">OVN_Southbond</tt> database. Sandbox launch
screen provides the instructions on accessing the backup database.  However
access to the backup server is not required to go through the tutorial.</li>
<li>Creates the <tt class="docutils literal">hardware_vtep</tt> database as described in <a class="reference external" href="http://openvswitch.org/support/dist-docs/vtep.5.html">vtep(5)</a>.</li>
<li>Runs the <a class="reference external" href="http://openvswitch.org/support/dist-docs/ovn-northd.8.html">ovn-northd(8)</a>, <a class="reference external" href="http://openvswitch.org/support/dist-docs/ovn-controller.8.html">ovn-controller(8)</a>, and
<a class="reference external" href="http://openvswitch.org/support/dist-docs/ovn-controller-vtep.8.html">ovn-controller-vtep(8)</a> daemons.</li>
<li>Makes OVN and VTEP utilities available for use in the environment, including
<a class="reference external" href="http://openvswitch.org/support/dist-docs/vtep-ctl.8.html">vtep-ctl(8)</a>, <a class="reference external" href="http://openvswitch.org/support/dist-docs/ovn-nbctl.8.html">ovn-nbctl(8)</a>, and <a class="reference external" href="http://openvswitch.org/support/dist-docs/ovn-sbctl.8.html">ovn-sbctl(8)</a>.</li>
</ol>
<p>Note that each of these demos assumes you start with a fresh sandbox
environment. <strong>Re-run `ovs-sandbox` before starting each section.</strong></p>
</div>
<div class="section" id="using-gdb">
<h1>Using GDB</h1>
<p>GDB support is not required to go through the tutorial. See the &quot;Using GDB&quot;
section of the <a class="reference external" href="https://github.com/openvswitch/ovs/blob/master/tutorial/tutorial.rst">tutorial</a> for more info. Additional flags exist for launching
the debugger for the OVN programs:</p>
<pre class="literal-block">
--gdb-ovn-northd
--gdb-ovn-controller
--gdb-ovn-controller-vtep
</pre>
</div>
<div class="section" id="simple-two-port-setup">
<h1>Simple Two Port Setup</h1>
<p>This first environment is the simplest OVN example.  It demonstrates using OVN
with a single logical switch that has two logical ports, both residing on the
same hypervisor.</p>
<p>Start by running the setup script for this environment:</p>
<pre class="literal-block">
$ ovn/env1/setup.sh
</pre>
<p>You can use the <tt class="docutils literal"><span class="pre">ovn-nbctl</span></tt> utility to see an overview of the logical
topology:</p>
<pre class="literal-block">
$ ovn-nbctl show
switch 78687d53-e037-4555-bcd3-f4f8eaf3f2aa (sw0)
    port sw0-port1
        addresses: [&quot;00:00:00:00:00:01&quot;]
    port sw0-port2
        addresses: [&quot;00:00:00:00:00:02&quot;]
</pre>
<p>The <tt class="docutils literal"><span class="pre">ovn-sbctl</span></tt> utility can be used to see into the state stored in the
<tt class="docutils literal">OVN_Southbound</tt> database.  The <tt class="docutils literal">show</tt> command shows that there is a single
chassis with two logical ports bound to it.  In a more realistic
multi-hypervisor environment, this would list all hypervisors and where all
logical ports are located:</p>
<pre class="literal-block">
$ ovn-sbctl show
Chassis &quot;56b18105-5706-46ef-80c4-ff20979ab068&quot;
    Encap geneve
        ip: &quot;127.0.0.1&quot;
    Port_Binding &quot;sw0-port1&quot;
    Port_Binding &quot;sw0-port2&quot;
</pre>
<p>OVN creates logical flows to describe how the network should behave in logical
space.  Each chassis then creates OpenFlow flows based on those logical flows
that reflect its own local view of the network.  The <tt class="docutils literal"><span class="pre">ovn-sbctl</span></tt> command can
show the logical flows:</p>
<pre class="literal-block">
$ ovn-sbctl lflow-list
Datapath: 2503dd42-14b1-414a-abbf-33e554e09ddc  Pipeline: ingress
  table=0 (ls_in_port_sec_l2 ), priority=100   , match=(eth.src[40]), action=(drop;)
  table=0 (ls_in_port_sec_l2 ), priority=100   , match=(vlan.present), action=(drop;)
  table=0 (ls_in_port_sec_l2 ), priority=50    , match=(inport == &quot;sw0-port1&quot; &amp;&amp; eth.src == {00:00:00:00:00:01}), action=(next;)
  table=0 (ls_in_port_sec_l2 ), priority=50    , match=(inport == &quot;sw0-port2&quot; &amp;&amp; eth.src == {00:00:00:00:00:02}), action=(next;)
  table=1 (ls_in_port_sec_ip ), priority=0     , match=(1), action=(next;)
  table=2 (ls_in_port_sec_nd ), priority=90    , match=(inport == &quot;sw0-port1&quot; &amp;&amp; eth.src == 00:00:00:00:00:01 &amp;&amp; arp.sha == 00:00:00:00:00:01), action=(next;)
  table=2 (ls_in_port_sec_nd ), priority=90    , match=(inport == &quot;sw0-port1&quot; &amp;&amp; eth.src == 00:00:00:00:00:01 &amp;&amp; ip6 &amp;&amp; nd &amp;&amp; ((nd.sll == 00:00:00:00:00:00 || nd.sll == 00:00:00:00:00:01) || ((nd.tll == 00:00:00:00:00:00 || nd.tll == 00:00:00:00:00:01)))), action=(next;)
  table=2 (ls_in_port_sec_nd ), priority=90    , match=(inport == &quot;sw0-port2&quot; &amp;&amp; eth.src == 00:00:00:00:00:02 &amp;&amp; arp.sha == 00:00:00:00:00:02), action=(next;)
  table=2 (ls_in_port_sec_nd  ), priority=90   , match=(inport == &quot;sw0-port2&quot; &amp;&amp; eth.src == 00:00:00:00:00:02 &amp;&amp; ip6 &amp;&amp; nd &amp;&amp; ((nd.sll == 00:00:00:00:00:00 || nd.sll == 00:00:00:00:00:02) || ((nd.tll == 00:00:00:00:00:00 || nd.tll == 00:00:00:00:00:02)))), action=(next;)
  table=2 (ls_in_port_sec_nd  ), priority=80   , match=(inport == &quot;sw0-port1&quot; &amp;&amp; (arp || nd)), action=(drop;)
  table=2 (ls_in_port_sec_nd  ), priority=80   , match=(inport == &quot;sw0-port2&quot; &amp;&amp; (arp || nd)), action=(drop;)
  table=2 (ls_in_port_sec_nd  ), priority=0    , match=(1), action=(next;)
  table=3 (ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=4 (ls_in_pre_lb       ), priority=0    , match=(1), action=(next;)
  table=5 (ls_in_pre_stateful ), priority=100  , match=(reg0[0] == 1), action=(ct_next;)
  table=5 (ls_in_pre_stateful ), priority=0    , match=(1), action=(next;)
  table=6 (ls_in_acl          ), priority=0    , match=(1), action=(next;)
  table=7 (ls_in_lb           ), priority=0    , match=(1), action=(next;)
  table=8 (ls_in_stateful     ), priority=100  , match=(reg0[1] == 1), action=(ct_commit; next;)
  table=8 (ls_in_stateful     ), priority=100  , match=(reg0[2] == 1), action=(ct_lb;)
  table=8 (ls_in_stateful     ), priority=0    , match=(1), action=(next;)
  table=9 (ls_in_arp_rsp      ), priority=0    , match=(1), action=(next;)
  table=10(ls_in_l2_lkup      ), priority=100  , match=(eth.mcast), action=(outport = &quot;_MC_flood&quot;; output;)
  table=10(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(outport = &quot;sw0-port1&quot;; output;)
  table=10(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = &quot;sw0-port2&quot;; output;)
Datapath: 2503dd42-14b1-414a-abbf-33e554e09ddc  Pipeline: egress
  table=0 (ls_out_pre_lb      ), priority=0    , match=(1), action=(next;)
  table=1 (ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=2 (ls_out_pre_stateful), priority=100  , match=(reg0[0] == 1), action=(ct_next;)
  table=2 (ls_out_pre_stateful), priority=0    , match=(1), action=(next;)
  table=3 (ls_out_lb          ), priority=0    , match=(1), action=(next;)
  table=4 (ls_out_acl         ), priority=0    , match=(1), action=(next;)
  table=5 (ls_out_stateful    ), priority=100  , match=(reg0[1] == 1), action=(ct_commit; next;)
  table=5 (ls_out_stateful    ), priority=100  , match=(reg0[2] == 1), action=(ct_lb;)
  table=5 (ls_out_stateful    ), priority=0    , match=(1), action=(next;)
  table=6 (ls_out_port_sec_ip ), priority=0    , match=(1), action=(next;)
  table=7 (ls_out_port_sec_l2 ), priority=100  , match=(eth.mcast), action=(output;)
  table=7 (ls_out_port_sec_l2 ), priority=50   , match=(outport == &quot;sw0-port1&quot; &amp;&amp; eth.dst == {00:00:00:00:00:01}), action=(output;)
  table=7 (ls_out_port_sec_l2 ), priority=50   , match=(outport == &quot;sw0-port2&quot; &amp;&amp; eth.dst == {00:00:00:00:00:02}), action=(output;)
</pre>
<p>Now we can start taking a closer look at how <tt class="docutils literal"><span class="pre">ovn-controller</span></tt> has programmed
the local switch.  Before looking at the flows, we can use <tt class="docutils literal"><span class="pre">ovs-ofctl</span></tt> to
verify the OpenFlow port numbers for each of the logical ports on the switch.
The output shows that <tt class="docutils literal">lport1</tt>, which corresponds with our logical port
<tt class="docutils literal"><span class="pre">sw0-port1</span></tt>, has an OpenFlow port number of <tt class="docutils literal">1</tt>.  Similarly, <tt class="docutils literal">lport2</tt> has
an OpenFlow port number of <tt class="docutils literal">2</tt>:</p>
<pre class="literal-block">
$ ovs-ofctl show br-int
OFPT_FEATURES_REPLY (xid=0x2): dpid:00003e1ba878364d
n_tables:254, n_buffers:0
capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS ARP_MATCH_IP
actions: output enqueue set_vlan_vid set_vlan_pcp strip_vlan mod_dl_src mod_dl_dst mod_nw_src mod_nw_dst mod_nw_tos mod_tp_src mod_tp_dst
 1(lport1): addr:aa:55:aa:55:00:07
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 2(lport2): addr:aa:55:aa:55:00:08
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 LOCAL(br-int): addr:3e:1b:a8:78:36:4d
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
OFPT_GET_CONFIG_REPLY (xid=0x4): frags=normal miss_send_len=0
</pre>
<p>Finally, use <tt class="docutils literal"><span class="pre">ovs-ofctl</span></tt> to see the OpenFlow flows for <tt class="docutils literal"><span class="pre">br-int</span></tt>.  Note that
some fields have been omitted for brevity:</p>
<pre class="literal-block">
$ ovs-ofctl -O OpenFlow13 dump-flows br-int
OFPST_FLOW reply (OF1.3) (xid=0x2):
 table=0, priority=100,in_port=1 actions=set_field:0x1-&gt;metadata,set_field:0x1-&gt;reg6,resubmit(,16)
 table=0, priority=100,in_port=2 actions=set_field:0x1-&gt;metadata,set_field:0x2-&gt;reg6,resubmit(,16)
 table=16, priority=100,metadata=0x1,vlan_tci=0x1000/0x1000 actions=drop
 table=16, priority=100,metadata=0x1,dl_src=01:00:00:00:00:00/01:00:00:00:00:00 actions=drop
 table=16, priority=50,reg6=0x1,metadata=0x1,dl_src=00:00:00:00:00:01 actions=resubmit(,17)
 table=16, priority=50,reg6=0x2,metadata=0x1,dl_src=00:00:00:00:00:02 actions=resubmit(,17)
 table=17, priority=0,metadata=0x1 actions=resubmit(,18)
 table=18, priority=90,icmp6,reg6=0x2,metadata=0x1,dl_src=00:00:00:00:00:02,icmp_type=136,icmp_code=0,nd_tll=00:00:00:00:00:00 actions=resubmit(,19)
 table=18, priority=90,icmp6,reg6=0x2,metadata=0x1,dl_src=00:00:00:00:00:02,icmp_type=136,icmp_code=0,nd_tll=00:00:00:00:00:02 actions=resubmit(,19)
 table=18, priority=90,icmp6,reg6=0x1,metadata=0x1,dl_src=00:00:00:00:00:01,icmp_type=136,icmp_code=0,nd_tll=00:00:00:00:00:00 actions=resubmit(,19)
 table=18, priority=90,icmp6,reg6=0x1,metadata=0x1,dl_src=00:00:00:00:00:01,icmp_type=136,icmp_code=0,nd_tll=00:00:00:00:00:01 actions=resubmit(,19)
 table=18, priority=90,icmp6,reg6=0x1,metadata=0x1,dl_src=00:00:00:00:00:01,icmp_type=135,icmp_code=0,nd_sll=00:00:00:00:00:01 actions=resubmit(,19)
 table=18, priority=90,icmp6,reg6=0x1,metadata=0x1,dl_src=00:00:00:00:00:01,icmp_type=135,icmp_code=0,nd_sll=00:00:00:00:00:00 actions=resubmit(,19)
 table=18, priority=90,icmp6,reg6=0x2,metadata=0x1,dl_src=00:00:00:00:00:02,icmp_type=135,icmp_code=0,nd_sll=00:00:00:00:00:00 actions=resubmit(,19)
 table=18, priority=90,icmp6,reg6=0x2,metadata=0x1,dl_src=00:00:00:00:00:02,icmp_type=135,icmp_code=0,nd_sll=00:00:00:00:00:02 actions=resubmit(,19)
 table=18, priority=90,arp,reg6=0x1,metadata=0x1,dl_src=00:00:00:00:00:01,arp_sha=00:00:00:00:00:01 actions=resubmit(,19)
 table=18, priority=90,arp,reg6=0x2,metadata=0x1,dl_src=00:00:00:00:00:02,arp_sha=00:00:00:00:00:02 actions=resubmit(,19)
 table=18, priority=80,icmp6,reg6=0x2,metadata=0x1,icmp_type=136,icmp_code=0 actions=drop
 table=18, priority=80,icmp6,reg6=0x1,metadata=0x1,icmp_type=136,icmp_code=0 actions=drop
 table=18, priority=80,icmp6,reg6=0x1,metadata=0x1,icmp_type=135,icmp_code=0 actions=drop
 table=18, priority=80,icmp6,reg6=0x2,metadata=0x1,icmp_type=135,icmp_code=0 actions=drop
 table=18, priority=80,arp,reg6=0x2,metadata=0x1 actions=drop
 table=18, priority=80,arp,reg6=0x1,metadata=0x1 actions=drop
 table=18, priority=0,metadata=0x1 actions=resubmit(,19)
 table=19, priority=0,metadata=0x1 actions=resubmit(,20)
 table=20, priority=0,metadata=0x1 actions=resubmit(,21)
 table=21, priority=0,metadata=0x1 actions=resubmit(,22)
 table=22, priority=0,metadata=0x1 actions=resubmit(,23)
 table=23, priority=0,metadata=0x1 actions=resubmit(,24)
 table=24, priority=0,metadata=0x1 actions=resubmit(,25)
 table=25, priority=0,metadata=0x1 actions=resubmit(,26)
 table=26, priority=100,metadata=0x1,dl_dst=01:00:00:00:00:00/01:00:00:00:00:00 actions=set_field:0xffff-&gt;reg7,resubmit(,32)
 table=26, priority=50,metadata=0x1,dl_dst=00:00:00:00:00:01 actions=set_field:0x1-&gt;reg7,resubmit(,32)
 table=26, priority=50,metadata=0x1,dl_dst=00:00:00:00:00:02 actions=set_field:0x2-&gt;reg7,resubmit(,32)
 table=32, priority=0 actions=resubmit(,33)
 table=33, priority=100,reg7=0x1,metadata=0x1 actions=resubmit(,34)
 table=33, priority=100,reg7=0xffff,metadata=0x1 actions=set_field:0x2-&gt;reg7,resubmit(,34),set_field:0x1-&gt;reg7,resubmit(,34),set_field:0xffff-&gt;reg7
 table=33, priority=100,reg7=0x2,metadata=0x1 actions=resubmit(,34)
 table=34, priority=100,reg6=0x1,reg7=0x1,metadata=0x1 actions=drop
 table=34, priority=100,reg6=0x2,reg7=0x2,metadata=0x1 actions=drop
 table=34, priority=0 actions=set_field:0-&gt;reg0,set_field:0-&gt;reg1,set_field:0-&gt;reg2,resubmit(,48)
 table=48, priority=0,metadata=0x1 actions=resubmit(,49)
 table=49, priority=0,metadata=0x1 actions=resubmit(,50)
 table=50, priority=0,metadata=0x1 actions=resubmit(,51)
 table=51, priority=0,metadata=0x1 actions=resubmit(,52)
 table=52, priority=0,metadata=0x1 actions=resubmit(,53)
 table=53, priority=0,metadata=0x1 actions=resubmit(,54)
 table=54, priority=0,metadata=0x1 actions=resubmit(,55)
 table=55, priority=100,metadata=0x1,dl_dst=01:00:00:00:00:00/01:00:00:00:00:00 actions=resubmit(,64)
 table=55, priority=50,reg7=0x2,metadata=0x1,dl_dst=00:00:00:00:00:02 actions=resubmit(,64)
 table=55, priority=50,reg7=0x1,metadata=0x1,dl_dst=00:00:00:00:00:01 actions=resubmit(,64)
 table=64, priority=100,reg7=0x1,metadata=0x1 actions=output:1
</pre>
<p>The <tt class="docutils literal"><span class="pre">ovs-appctl</span></tt> command can be used to generate an OpenFlow trace of how a
packet would be processed in this configuration.  This first trace shows a
packet from <tt class="docutils literal"><span class="pre">sw0-port1</span></tt> to <tt class="docutils literal"><span class="pre">sw0-port2</span></tt>.  The packet arrives from port <tt class="docutils literal">1</tt>
and should be output to port <tt class="docutils literal">2</tt>:</p>
<pre class="literal-block">
$ ovn/env1/packet1.sh
</pre>
<p>Trace a broadcast packet from <tt class="docutils literal"><span class="pre">sw0-port1</span></tt>.  The packet arrives from port
<tt class="docutils literal">1</tt> and should be output to port <tt class="docutils literal">2</tt>:</p>
<pre class="literal-block">
$ ovn/env1/packet2.sh
</pre>
<p>You can extend this setup by adding additional ports.  For example, to add a
third port, run this command:</p>
<pre class="literal-block">
$ ovn/env1/add-third-port.sh
</pre>
<p>Now if you do another trace of a broadcast packet from <tt class="docutils literal"><span class="pre">sw0-port1</span></tt>, you will
see that it is output to both ports <tt class="docutils literal">2</tt> and <tt class="docutils literal">3</tt>:</p>
<pre class="literal-block">
$ ovn/env1/packet2.sh
</pre>
<p>The logical port may have an unknown set of Ethernet addresses.  When an OVN logical
switch processes a unicast Ethernet frame whose destination MAC address is not in any
logical port's addresses column, it delivers it to the port (or ports) whose addresses
columns include unknown:</p>
<pre class="literal-block">
$ ovn/env1/add-unknown-ports.sh
</pre>
<p>This trace shows a packet from <tt class="docutils literal"><span class="pre">sw0-port1</span></tt> to <tt class="docutils literal"><span class="pre">sw0-port4</span></tt>, <tt class="docutils literal"><span class="pre">sw0-port5</span></tt>
whose addresses columns include unknown.  You will see that it is output to
both ports <tt class="docutils literal">4</tt> and <tt class="docutils literal">5</tt>:</p>
<pre class="literal-block">
$ ovn/env1/packet3.sh
</pre>
<p>The logical port would restrict the host to sending packets from and receiving
packets to the ethernet addresses defined in the logical port's
<tt class="docutils literal">port_security</tt> column.  In addition to the restrictions described for
Ethernet addresses above, such an element of port_security restricts the IPv4
or IPv6 addresses from which the host may send and to which it may receive
packets to the specified addresses:</p>
<pre class="literal-block">
$ ovn/env1/add-security-ip-ports.sh
</pre>
<p>This trace shows a packet from <tt class="docutils literal"><span class="pre">sw0-port6</span></tt> to <tt class="docutils literal"><span class="pre">sw0-port7</span></tt>:</p>
<pre class="literal-block">
$ ovn/env1/packet4.sh
</pre>
</div>
<div class="section" id="two-switches-four-ports">
<h1>Two Switches, Four Ports</h1>
<p>This environment is an extension of the last example.  The previous example
showed two ports on a single logical switch.  In this environment we add a
second logical switch that also has two ports.  This lets you start to see how
<tt class="docutils literal"><span class="pre">ovn-controller</span></tt> creates flows for isolated networks to co-exist on the same
switch:</p>
<pre class="literal-block">
$ ovn/env2/setup.sh
</pre>
<p>View the logical topology with <tt class="docutils literal"><span class="pre">ovn-nbctl</span></tt>:</p>
<pre class="literal-block">
$ ovn-nbctl show
switch e3190dc2-89d1-44ed-9308-e7077de782b3 (sw0)
    port sw0-port1
        addresses: 00:00:00:00:00:01
    port sw0-port2
        addresses: 00:00:00:00:00:02
switch c8ed4c5f-9733-43f6-93da-795b1aabacb1 (sw1)
    port sw1-port1
        addresses: 00:00:00:00:00:03
    port sw1-port2
        addresses: 00:00:00:00:00:04
</pre>
<p>Physically, all ports reside on the same chassis:</p>
<pre class="literal-block">
$ ovn-sbctl show
Chassis &quot;56b18105-5706-46ef-80c4-ff20979ab068&quot;
    Encap geneve
        ip: &quot;127.0.0.1&quot;
    Port_Binding &quot;sw1-port2&quot;
    Port_Binding &quot;sw0-port2&quot;
    Port_Binding &quot;sw0-port1&quot;
    Port_Binding &quot;sw1-port1&quot;
</pre>
<p>OVN creates separate logical flows for each logical switch:</p>
<pre class="literal-block">
$ ovn-sbctl lflow-list
Datapath: 7ee908c1-b0d3-4d03-acc9-42cd7ef7f27d  Pipeline: ingress
  table=0 (ls_in_port_sec_l2  ), priority=100  , match=(eth.src[40]), action=(drop;)
  table=0 (ls_in_port_sec_l2  ), priority=100  , match=(vlan.present), action=(drop;)
  table=0 (ls_in_port_sec_l2  ), priority=50   , match=(inport == &quot;sw1-port1&quot; &amp;&amp; eth.src == {00:00:00:00:00:03}), action=(next;)
  table=0 (ls_in_port_sec_l2  ), priority=50   , match=(inport == &quot;sw1-port2&quot; &amp;&amp; eth.src == {00:00:00:00:00:04}), action=(next;)
  table=1 (ls_in_port_sec_ip  ), priority=0    , match=(1), action=(next;)
  table=2 (ls_in_port_sec_nd  ), priority=90   , match=(inport == &quot;sw1-port1&quot; &amp;&amp; eth.src == 00:00:00:00:00:03 &amp;&amp; arp.sha == 00:00:00:00:00:03), action=(next;)
  table=2 (ls_in_port_sec_nd  ), priority=90   , match=(inport == &quot;sw1-port1&quot; &amp;&amp; eth.src == 00:00:00:00:00:03 &amp;&amp; ip6 &amp;&amp; nd &amp;&amp; ((nd.sll == 00:00:00:00:00:00 || nd.sll == 00:00:00:00:00:03) || ((nd.tll == 00:00:00:00:00:00 || nd.tll == 00:00:00:00:00:03)))), action=(next;)
  table=2 (ls_in_port_sec_nd  ), priority=90   , match=(inport == &quot;sw1-port2&quot; &amp;&amp; eth.src == 00:00:00:00:00:04 &amp;&amp; arp.sha == 00:00:00:00:00:04), action=(next;)
  table=2 (ls_in_port_sec_nd  ), priority=90   , match=(inport == &quot;sw1-port2&quot; &amp;&amp; eth.src == 00:00:00:00:00:04 &amp;&amp; ip6 &amp;&amp; nd &amp;&amp; ((nd.sll == 00:00:00:00:00:00 || nd.sll == 00:00:00:00:00:04) || ((nd.tll == 00:00:00:00:00:00 || nd.tll == 00:00:00:00:00:04)))), action=(next;)
  table=2 (ls_in_port_sec_nd  ), priority=80   , match=(inport == &quot;sw1-port1&quot; &amp;&amp; (arp || nd)), action=(drop;)
  table=2 (ls_in_port_sec_nd  ), priority=80   , match=(inport == &quot;sw1-port2&quot; &amp;&amp; (arp || nd)), action=(drop;)
  table=2 (ls_in_port_sec_nd  ), priority=0    , match=(1), action=(next;)
  table=3 (ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=4 (ls_in_pre_lb       ), priority=0    , match=(1), action=(next;)
  table=5 (ls_in_pre_stateful ), priority=100  , match=(reg0[0] == 1), action=(ct_next;)
  table=5 (ls_in_pre_stateful ), priority=0    , match=(1), action=(next;)
  table=6 (ls_in_acl          ), priority=0    , match=(1), action=(next;)
  table=7 (ls_in_lb           ), priority=0    , match=(1), action=(next;)
  table=8 (ls_in_stateful     ), priority=100  , match=(reg0[1] == 1), action=(ct_commit; next;)
  table=8 (ls_in_stateful     ), priority=100  , match=(reg0[2] == 1), action=(ct_lb;)
  table=8 (ls_in_stateful     ), priority=0    , match=(1), action=(next;)
  table=9 (ls_in_arp_rsp      ), priority=0    , match=(1), action=(next;)
  table=10(ls_in_l2_lkup      ), priority=100  , match=(eth.mcast), action=(outport = &quot;_MC_flood&quot;; output;)
  table=10(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:03), action=(outport = &quot;sw1-port1&quot;; output;)
  table=10(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:04), action=(outport = &quot;sw1-port2&quot;; output;)
Datapath: 7ee908c1-b0d3-4d03-acc9-42cd7ef7f27d  Pipeline: egress
  table=0 (ls_out_pre_lb      ), priority=0    , match=(1), action=(next;)
  table=1 (ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=2 (ls_out_pre_stateful), priority=100  , match=(reg0[0] == 1), action=(ct_next;)
  table=2 (ls_out_pre_stateful), priority=0    , match=(1), action=(next;)
  table=3 (ls_out_lb          ), priority=0    , match=(1), action=(next;)
  table=4 (ls_out_acl         ), priority=0    , match=(1), action=(next;)
  table=5 (ls_out_stateful    ), priority=100  , match=(reg0[1] == 1), action=(ct_commit; next;)
  table=5 (ls_out_stateful    ), priority=100  , match=(reg0[2] == 1), action=(ct_lb;)
  table=5 (ls_out_stateful    ), priority=0    , match=(1), action=(next;)
  table=6 (ls_out_port_sec_ip ), priority=0    , match=(1), action=(next;)
  table=7 (ls_out_port_sec_l2 ), priority=100  , match=(eth.mcast), action=(output;)
  table=7 (ls_out_port_sec_l2 ), priority=50   , match=(outport == &quot;sw1-port1&quot; &amp;&amp; eth.dst == {00:00:00:00:00:03}), action=(output;)
  table=7 (ls_out_port_sec_l2 ), priority=50   , match=(outport == &quot;sw1-port2&quot; &amp;&amp; eth.dst == {00:00:00:00:00:04}), action=(output;)
Datapath: 9ea0c8f9-4f82-4be3-a6c7-6e6f9c2de583  Pipeline: ingress
  table=0 (ls_in_port_sec_l2  ), priority=100  , match=(eth.src[40]), action=(drop;)
  table=0 (ls_in_port_sec_l2  ), priority=100  , match=(vlan.present), action=(drop;)
  table=0 (ls_in_port_sec_l2  ), priority=50   , match=(inport == &quot;sw0-port1&quot; &amp;&amp; eth.src == {00:00:00:00:00:01}), action=(next;)
  table=0 (ls_in_port_sec_l2  ), priority=50   , match=(inport == &quot;sw0-port2&quot; &amp;&amp; eth.src == {00:00:00:00:00:02}), action=(next;)
  table=1 (ls_in_port_sec_ip  ), priority=0    , match=(1), action=(next;)
  table=2 (ls_in_port_sec_nd  ), priority=90   , match=(inport == &quot;sw0-port1&quot; &amp;&amp; eth.src == 00:00:00:00:00:01 &amp;&amp; arp.sha == 00:00:00:00:00:01), action=(next;)
  table=2 (ls_in_port_sec_nd  ), priority=90   , match=(inport == &quot;sw0-port1&quot; &amp;&amp; eth.src == 00:00:00:00:00:01 &amp;&amp; ip6 &amp;&amp; nd &amp;&amp; ((nd.sll == 00:00:00:00:00:00 || nd.sll == 00:00:00:00:00:01) || ((nd.tll == 00:00:00:00:00:00 || nd.tll == 00:00:00:00:00:01)))), action=(next;)
  table=2 (ls_in_port_sec_nd  ), priority=90   , match=(inport == &quot;sw0-port2&quot; &amp;&amp; eth.src == 00:00:00:00:00:02 &amp;&amp; arp.sha == 00:00:00:00:00:02), action=(next;)
  table=2 (ls_in_port_sec_nd  ), priority=90   , match=(inport == &quot;sw0-port2&quot; &amp;&amp; eth.src == 00:00:00:00:00:02 &amp;&amp; ip6 &amp;&amp; nd &amp;&amp; ((nd.sll == 00:00:00:00:00:00 || nd.sll == 00:00:00:00:00:02) || ((nd.tll == 00:00:00:00:00:00 || nd.tll == 00:00:00:00:00:02)))), action=(next;)
  table=2 (ls_in_port_sec_nd  ), priority=80   , match=(inport == &quot;sw0-port1&quot; &amp;&amp; (arp || nd)), action=(drop;)
  table=2 (ls_in_port_sec_nd  ), priority=80   , match=(inport == &quot;sw0-port2&quot; &amp;&amp; (arp || nd)), action=(drop;)
  table=2 (ls_in_port_sec_nd  ), priority=0    , match=(1), action=(next;)
  table=3 (ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=4 (ls_in_pre_lb       ), priority=0    , match=(1), action=(next;)
  table=5 (ls_in_pre_stateful ), priority=100  , match=(reg0[0] == 1), action=(ct_next;)
  table=5 (ls_in_pre_stateful ), priority=0    , match=(1), action=(next;)
  table=6 (ls_in_acl          ), priority=0    , match=(1), action=(next;)
  table=7 (ls_in_lb           ), priority=0    , match=(1), action=(next;)
  table=8 (ls_in_stateful     ), priority=100  , match=(reg0[1] == 1), action=(ct_commit; next;)
  table=8 (ls_in_stateful     ), priority=100  , match=(reg0[2] == 1), action=(ct_lb;)
  table=8 (ls_in_stateful     ), priority=0    , match=(1), action=(next;)
  table=9 (ls_in_arp_rsp      ), priority=0    , match=(1), action=(next;)
  table=10(ls_in_l2_lkup      ), priority=100  , match=(eth.mcast), action=(outport = &quot;_MC_flood&quot;; output;)
  table=10(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(outport = &quot;sw0-port1&quot;; output;)
  table=10(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = &quot;sw0-port2&quot;; output;)
Datapath: 9ea0c8f9-4f82-4be3-a6c7-6e6f9c2de583  Pipeline: egress
  table=0 (ls_out_pre_lb      ), priority=0    , match=(1), action=(next;)
  table=1 (ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=2 (ls_out_pre_stateful), priority=100  , match=(reg0[0] == 1), action=(ct_next;)
  table=2 (ls_out_pre_stateful), priority=0    , match=(1), action=(next;)
  table=3 (ls_out_lb          ), priority=0    , match=(1), action=(next;)
  table=4 (ls_out_acl         ), priority=0    , match=(1), action=(next;)
  table=5 (ls_out_stateful    ), priority=100  , match=(reg0[1] == 1), action=(ct_commit; next;)
  table=5 (ls_out_stateful    ), priority=100  , match=(reg0[2] == 1), action=(ct_lb;)
  table=5 (ls_out_stateful    ), priority=0    , match=(1), action=(next;)
  table=6 (ls_out_port_sec_ip ), priority=0    , match=(1), action=(next;)
  table=7 (ls_out_port_sec_l2 ), priority=100  , match=(eth.mcast), action=(output;)
  table=7 (ls_out_port_sec_l2 ), priority=50   , match=(outport == &quot;sw0-port1&quot; &amp;&amp; eth.dst == {00:00:00:00:00:01}), action=(output;)
  table=7 (ls_out_port_sec_l2 ), priority=50   , match=(outport == &quot;sw0-port2&quot; &amp;&amp; eth.dst == {00:00:00:00:00:02}), action=(output;)
</pre>
<p>In this setup, <tt class="docutils literal"><span class="pre">sw0-port1</span></tt> and <tt class="docutils literal"><span class="pre">sw0-port2</span></tt> can send packets to each other,
but not to either of the ports on <tt class="docutils literal">sw1</tt>.  This first trace shows a packet
from <tt class="docutils literal"><span class="pre">sw0-port1</span></tt> to <tt class="docutils literal"><span class="pre">sw0-port2</span></tt>.  You should see th packet arrive on
OpenFlow port <tt class="docutils literal">1</tt> and output to OpenFlow port <tt class="docutils literal">2</tt>:</p>
<pre class="literal-block">
$ ovn/env2/packet1.sh
</pre>
<p>This next example shows a packet from <tt class="docutils literal"><span class="pre">sw0-port1</span></tt> with a destination MAC
address of <tt class="docutils literal">00:00:00:00:00:03</tt>, which is the MAC address for <tt class="docutils literal"><span class="pre">sw1-port1</span></tt>.
Since these ports are not on the same logical switch, the packet should just be
dropped:</p>
<pre class="literal-block">
$ ovn/env2/packet2.sh
</pre>
</div>
<div class="section" id="two-hypervisors">
<h1>Two Hypervisors</h1>
<p>The first two examples started by showing OVN on a single hypervisor.  A more
realistic deployment of OVN would span multiple hypervisors.  This example
creates a single logical switch with 4 logical ports.  It then simulates having
two hypervisors with two of the logical ports bound to each hypervisor:</p>
<pre class="literal-block">
$ ovn/env3/setup.sh
</pre>
<p>You can start by viewing the logical topology with <tt class="docutils literal"><span class="pre">ovn-nbctl</span></tt>:</p>
<pre class="literal-block">
$ ovn-nbctl show
switch b977dc03-79a5-41ba-9665-341a80e1abfd (sw0)
    port sw0-port1
        addresses: 00:00:00:00:00:01
    port sw0-port2
        addresses: 00:00:00:00:00:02
    port sw0-port4
        addresses: 00:00:00:00:00:04
    port sw0-port3
        addresses: 00:00:00:00:00:03
</pre>
<p>Using <tt class="docutils literal"><span class="pre">ovn-sbctl</span></tt> to view the state of the system, we can see that there are
two chassis: one local that we can interact with, and a fake remote chassis.
Two logical ports are bound to each.  Both chassis have an IP address of
localhost, but in a realistic deployment that would be the IP address used for
tunnels to that chassis:</p>
<pre class="literal-block">
$ ovn-sbctl show
Chassis &quot;56b18105-5706-46ef-80c4-ff20979ab068&quot;
    Encap geneve
        ip: &quot;127.0.0.1&quot;
    Port_Binding &quot;sw0-port2&quot;
    Port_Binding &quot;sw0-port1&quot;
Chassis fakechassis
    Encap geneve
        ip: &quot;127.0.0.1&quot;
    Port_Binding &quot;sw0-port4&quot;
    Port_Binding &quot;sw0-port3&quot;
</pre>
<p>Packets between <tt class="docutils literal"><span class="pre">sw0-port1</span></tt> and <tt class="docutils literal"><span class="pre">sw0-port2</span></tt> behave just like the previous
examples.  Packets to ports on a remote chassis are the interesting part of
this example.  You may have noticed before that OVN's logical flows are broken
up into ingress and egress tables.  Given a packet from <tt class="docutils literal"><span class="pre">sw0-port1</span></tt> on the
local chassis to <tt class="docutils literal"><span class="pre">sw0-port3</span></tt> on the remote chassis, the ingress pipeline is
executed on the local switch.  OVN then determines that it must forward the
packet over a geneve tunnel.  When it arrives at the remote chassis, the egress
pipeline will be executed there.</p>
<p>This first packet trace shows the first part of this example.  It's a packet
from <tt class="docutils literal"><span class="pre">sw0-port1</span></tt> to <tt class="docutils literal"><span class="pre">sw0-port3</span></tt> from the perspective of the local chassis.
<tt class="docutils literal"><span class="pre">sw0-port1</span></tt> is OpenFlow port <tt class="docutils literal">1</tt>.  The tunnel to the fake remote chassis is
OpenFlow port <tt class="docutils literal">3</tt>.  You should see the ingress pipeline being executed and
then the packet output to port <tt class="docutils literal">3</tt>, the geneve tunnel:</p>
<pre class="literal-block">
$ ovn/env3/packet1.sh
</pre>
<p>To simulate what would happen when that packet arrives at the remote chassis we
can flip this example around.  Consider a packet from <tt class="docutils literal"><span class="pre">sw0-port3</span></tt> to
<tt class="docutils literal"><span class="pre">sw0-port1</span></tt>.  This trace shows what would happen when that packet arrives at
the local chassis.  The packet arrives on OpenFlow port <tt class="docutils literal">3</tt> (the tunnel).
You should then see the egress pipeline get executed and the packet output to
OpenFlow port <tt class="docutils literal">1</tt>:</p>
<pre class="literal-block">
$ ovn/env3/packet2.sh
</pre>
</div>
<div class="section" id="locally-attached-networks">
<h1>Locally Attached Networks</h1>
<p>While OVN is generally focused on the implementation of logical networks using
overlays, it's also possible to use OVN as a control plane to manage logically
direct connectivity to networks that are locally accessible to each chassis.</p>
<p>This example includes two hypervisors.  Both hypervisors have two ports on
them.  We want to use OVN to manage the connectivity of these ports to a
network attached to each hypervisor that we will call &quot;physnet1&quot;.</p>
<p>This scenario requires some additional configuration of <tt class="docutils literal"><span class="pre">ovn-controller</span></tt>.  We
must configure a mapping between <tt class="docutils literal">physnet1</tt> and a local OVS bridge that
provides connectivity to that network.  We call these &quot;bridge mappings&quot;.  For
our example, the following script creates a bridge called <tt class="docutils literal"><span class="pre">br-eth1</span></tt> and then
configures <tt class="docutils literal"><span class="pre">ovn-controller</span></tt> with a bridge mapping from <tt class="docutils literal">physnet1</tt> to
<tt class="docutils literal"><span class="pre">br-eth1</span></tt>.</p>
<p>We want to create a fake second chassis and then create the topology that tells
OVN we want both ports on both hypervisors connected to <tt class="docutils literal">physnet1</tt>.  The way
this is modeled in OVN is by creating a logical switch for each port.  The
logical switch has the regular VIF port and a <tt class="docutils literal">localnet</tt> port:</p>
<pre class="literal-block">
$ ovn/env4/setup.sh
</pre>
<p>At this point we should be able to see that <tt class="docutils literal"><span class="pre">ovn-controller</span></tt> has
automatically created patch ports between <tt class="docutils literal"><span class="pre">br-int</span></tt> and <tt class="docutils literal"><span class="pre">br-eth1</span></tt>:</p>
<pre class="literal-block">
$ ovs-vsctl show
c0a06d85-d70a-4e11-9518-76a92588b34e
    Bridge &quot;br-eth1&quot;
        Port &quot;patch-provnet1-1-physnet1-to-br-int&quot;
            Interface &quot;patch-provnet1-1-physnet1-to-br-int&quot;
                type: patch
                options: {peer=&quot;patch-br-int-to-provnet1-1-physnet1&quot;}
        Port &quot;br-eth1&quot;
            Interface &quot;br-eth1&quot;
                type: internal
        Port &quot;patch-provnet1-2-physnet1-to-br-int&quot;
            Interface &quot;patch-provnet1-2-physnet1-to-br-int&quot;
                type: patch
                options: {peer=&quot;patch-br-int-to-provnet1-2-physnet1&quot;}
    Bridge br-int
        fail_mode: secure
        Port &quot;ovn-fakech-0&quot;
            Interface &quot;ovn-fakech-0&quot;
                type: geneve
                options: {key=flow, remote_ip=&quot;127.0.0.1&quot;}
        Port &quot;patch-br-int-to-provnet1-2-physnet1&quot;
            Interface &quot;patch-br-int-to-provnet1-2-physnet1&quot;
                type: patch
                options: {peer=&quot;patch-provnet1-2-physnet1-to-br-int&quot;}
        Port br-int
            Interface br-int
                type: internal
        Port &quot;patch-br-int-to-provnet1-1-physnet1&quot;
            Interface &quot;patch-br-int-to-provnet1-1-physnet1&quot;
                type: patch
                options: {peer=&quot;patch-provnet1-1-physnet1-to-br-int&quot;}
        Port &quot;lport2&quot;
            Interface &quot;lport2&quot;
        Port &quot;lport1&quot;
            Interface &quot;lport1
</pre>
<p>The logical topology from <tt class="docutils literal"><span class="pre">ovn-nbctl</span></tt> should look like this:</p>
<pre class="literal-block">
$ ovn-nbctl show
    switch 9db81140-5504-4f60-be3d-2bee45b57e27 (provnet1-2)
    port provnet1-2-port1
        addresses: [&quot;00:00:00:00:00:02&quot;]
    port provnet1-2-physnet1
        addresses: [&quot;unknown&quot;]
    switch cf175cb9-35c5-41cf-8bc7-2d322cdbead0 (provnet1-3)
    port provnet1-3-physnet1
        addresses: [&quot;unknown&quot;]
    port provnet1-3-port1
        addresses: [&quot;00:00:00:00:00:03&quot;]
    switch b85f7af6-8055-4db2-ba93-efc7887cf38f (provnet1-1)
    port provnet1-1-port1
        addresses: [&quot;00:00:00:00:00:01&quot;]
    port provnet1-1-physnet1
        addresses: [&quot;unknown&quot;]
    switch 63a5e276-8807-417d-bbec-a7e907e106b1 (provnet1-4)
    port provnet1-4-port1
        addresses: [&quot;00:00:00:00:00:04&quot;]
    port provnet1-4-physnet1
        addresses: [&quot;unknown&quot;]
</pre>
<p><tt class="docutils literal">port1</tt> on each logical switch represents a regular logical port for a VIF on
a hypervisor.  <tt class="docutils literal">physnet1</tt> on each logical switch is the special <tt class="docutils literal">localnet</tt>
port.  You can use <tt class="docutils literal"><span class="pre">ovn-nbctl</span></tt> to see that this port has a <tt class="docutils literal">type</tt> and
<tt class="docutils literal">options</tt> set:</p>
<pre class="literal-block">
$ ovn-nbctl lsp-get-type provnet1-1-physnet1
localnet

$ ovn-nbctl lsp-get-options provnet1-1-physnet1
network_name=physnet1
</pre>
<p>The physical topology should reflect that there are two regular ports on each
chassis:</p>
<pre class="literal-block">
$ ovn-sbctl show
Chassis &quot;56b18105-5706-46ef-80c4-ff20979ab068&quot;
    hostname: sandbox
    Encap geneve
        ip: &quot;127.0.0.1&quot;
    Port_Binding &quot;provnet1-1-port1&quot;
    Port_Binding &quot;provnet1-2-port1&quot;
Chassis fakechassis
    Encap geneve
        ip: &quot;127.0.0.1&quot;
    Port_Binding &quot;provnet1-3-port1&quot;
    Port_Binding &quot;provnet1-4-port1&quot;
</pre>
<p>All four of our ports should be able to communicate with each other, but they
do so through <tt class="docutils literal">physnet1</tt>.  A packet from any of these ports to any
destination should be output to the OpenFlow port number that corresponds to
the patch port to <tt class="docutils literal"><span class="pre">br-eth1</span></tt>.</p>
<p>This example assumes following OpenFlow port number mappings:</p>
<ul class="simple">
<li><tt class="docutils literal">1</tt> = tunnel to the fake second chassis</li>
<li><tt class="docutils literal">2</tt> = <tt class="docutils literal">lport1</tt>, which is the logical port named <tt class="docutils literal"><span class="pre">provnet1-1-port1</span></tt></li>
<li><tt class="docutils literal">3</tt> = <tt class="docutils literal"><span class="pre">patch-br-int-to-provnet1-1-physnet1</span></tt>, patch port to <tt class="docutils literal"><span class="pre">br-eth1</span></tt></li>
<li><tt class="docutils literal">4</tt> = <tt class="docutils literal">lport2</tt>, which is the logical port named <tt class="docutils literal"><span class="pre">provnet1-2-port1</span></tt></li>
<li><tt class="docutils literal">5</tt> = <tt class="docutils literal"><span class="pre">patch-br-int-to-provnet1-2-physnet1</span></tt>, patch port to <tt class="docutils literal"><span class="pre">br-eth1</span></tt></li>
</ul>
<p>We get those port numbers using <tt class="docutils literal"><span class="pre">ovs-ofctl</span></tt>:</p>
<pre class="literal-block">
$ ovs-ofctl show br-int
OFPT_FEATURES_REPLY (xid=0x2): dpid:00002a84824b0d40
n_tables:254, n_buffers:0
capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS ARP_MATCH_IP
actions: output enqueue set_vlan_vid set_vlan_pcp strip_vlan mod_dl_src mod_dl_dst
 1(ovn-fakech-0): addr:aa:55:aa:55:00:0e
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 2(lport1): addr:aa:55:aa:55:00:0f
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 3(patch-br-int-to): addr:7a:6f:8a:d5:69:2a
     config:     0
     state:      0
     speed: 0 Mbps now, 0 Mbps max
 4(lport2): addr:aa:55:aa:55:00:10
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
 5(patch-br-int-to): addr:4a:fd:c1:11:fc:a5
     config:     0
     state:      0
     speed: 0 Mbps now, 0 Mbps max
 LOCAL(br-int): addr:2a:84:82:4b:0d:40
     config:     PORT_DOWN
     state:      LINK_DOWN
     speed: 0 Mbps now, 0 Mbps max
OFPT_GET_CONFIG_REPLY (xid=0x4): frags=normal miss_send_len=0
</pre>
<p>This first trace shows a packet from <tt class="docutils literal"><span class="pre">provnet1-1-port1</span></tt> with a destination
MAC address of <tt class="docutils literal"><span class="pre">provnet1-2-port1</span></tt>.  We expect the packets from <tt class="docutils literal">lport1</tt>
(OpenFlow port 2) to be sent out to <tt class="docutils literal">lport2</tt> (OpenFlow port 4).  For example,
the following topology illustrates how the packets travel from <tt class="docutils literal">lport1</tt> to
<tt class="docutils literal">lport2</tt>:</p>
<pre class="literal-block">
`lport1` --&gt; `patch-br-int-to-provnet1-1-physnet1`(OpenFlow port 3)
--&gt; `br-eth1` --&gt; `patch-br-int-to-provnet1-2-physnet1` --&gt; `lport2`(OpenFlow port 4)
</pre>
<p>Similarly, We expect the packets from <tt class="docutils literal"><span class="pre">provnet1-2-port1</span></tt> to be sent out to
<tt class="docutils literal"><span class="pre">provnet1-1-port1</span></tt>.  We then expect the network to handle getting the packet
to its destination.  In practice, this will be optimized at <tt class="docutils literal"><span class="pre">br-eth1</span></tt> and the
packet won't actually go out and back on the network:</p>
<pre class="literal-block">
$ ovn/env4/packet1.sh
</pre>
<p>This next trace shows an example of a packet being sent to a destination on
another hypervisor.  The source is <tt class="docutils literal"><span class="pre">provnet1-1-port1</span></tt>, but the destination is
<tt class="docutils literal"><span class="pre">provnet1-3-port1</span></tt>, which is on the other fake chassis.  As usual, we expect
the output to be to <tt class="docutils literal"><span class="pre">br-eth1</span></tt> (<tt class="docutils literal"><span class="pre">patch-br-int-to-provnet1-1-physnet1</span></tt>,
OpenFlow port 3):</p>
<pre class="literal-block">
$ ovn/env4/packet2.sh
</pre>
<p>This next test shows a broadcast packet.  The destination should still only be
OpenFlow port 3 and 4:</p>
<pre class="literal-block">
$ ovn/env4/packet3.sh
</pre>
<p>Finally, this last trace shows what happens when a broadcast packet arrives
from the network.  In this case, it simulates a broadcast that originated from a
port on the remote fake chassis and arrived at the local chassis via <tt class="docutils literal"><span class="pre">br-eth1</span></tt>.
We should see it output to both local ports that are attached to this network
(OpenFlow ports 2 and 4):</p>
<pre class="literal-block">
$ ovn/env4/packet4.sh
</pre>
</div>
<div class="section" id="locally-attached-networks-with-vlans">
<h1>Locally Attached Networks with VLANs</h1>
<p>This example is an extension of the previous one.  We take the same setup and
add two more ports to each hypervisor.  Instead of having the new ports
directly connected to <tt class="docutils literal">physnet1</tt> as before, we indicate that we want them on
VLAN 101 of <tt class="docutils literal">physnet1</tt>.  This shows how <tt class="docutils literal">localnet</tt> ports can be used to
provide connectivity to either a flat network or a VLAN on that network:</p>
<pre class="literal-block">
$ ovn/env5/setup.sh
</pre>
<p>The logical topology shown by <tt class="docutils literal"><span class="pre">ovn-nbctl</span></tt> is similar to <tt class="docutils literal">env4</tt>, except we
now have 8 regular VIF ports connected to <tt class="docutils literal">physnet1</tt> instead of 4.  The
additional 4 ports we have added are all on VLAN 101 of <tt class="docutils literal">physnet1</tt>.  Note
that the <tt class="docutils literal">localnet</tt> ports representing connectivity to VLAN 101 of
<tt class="docutils literal">physnet1</tt> have the <tt class="docutils literal">tag</tt> field set to <tt class="docutils literal">101</tt>:</p>
<pre class="literal-block">
$ ovn-nbctl show
    switch 3e60b940-00bf-44c6-9db6-04abf28d7e5f (provnet1-1)
    port provnet1-1-physnet1
        addresses: [&quot;unknown&quot;]
    port provnet1-1-port1
        addresses: [&quot;00:00:00:00:00:01&quot;]
    switch 87f6bea0-f74d-4f39-aa65-ca1f94670429 (provnet1-2)
    port provnet1-2-port1
        addresses: [&quot;00:00:00:00:00:02&quot;]
    port provnet1-2-physnet1
        addresses: [&quot;unknown&quot;]
    switch e6c9cb69-a056-428d-aa40-e903ce416dcd (provnet1-6-101)
    port provnet1-6-101-port1
        addresses: [&quot;00:00:00:00:00:06&quot;]
    port provnet1-6-physnet1-101
        parent:
        tag: 101
        addresses: [&quot;unknown&quot;]
    switch 5f8f72ca-6030-4f66-baea-fe6174eb54df (provnet1-4)
    port provnet1-4-port1
        addresses: [&quot;00:00:00:00:00:04&quot;]
    port provnet1-4-physnet1
        addresses: [&quot;unknown&quot;]
    switch 15d585eb-d2c1-45ea-a946-b08de0eb2f55 (provnet1-7-101)
    port provnet1-7-physnet1-101
        parent:
        tag: 101
        addresses: [&quot;unknown&quot;]
    port provnet1-7-101-port1
        addresses: [&quot;00:00:00:00:00:07&quot;]
    switch 7be4aabe-1bb0-4e16-a755-a1f6d81c1c2f (provnet1-5-101)
    port provnet1-5-101-port1
        addresses: [&quot;00:00:00:00:00:05&quot;]
    port provnet1-5-physnet1-101
        parent:
        tag: 101
        addresses: [&quot;unknown&quot;]
    switch 9bbdbf0e-50f3-4286-ba5a-29bf347531bb (provnet1-8-101)
    port provnet1-8-101-port1
        addresses: [&quot;00:00:00:00:00:08&quot;]
    port provnet1-8-physnet1-101
        parent:
        tag: 101
        addresses: [&quot;unknown&quot;]
    switch 70d053f7-2bca-4dff-96ae-bd728d3ba1d2 (provnet1-3)
    port provnet1-3-physnet1
        addresses: [&quot;unknown&quot;]
    port provnet1-3-port1
        addresses: [&quot;00:00:00:00:00:03&quot;]
</pre>
<p>The physical topology shows that we have 4 regular VIF ports on each simulated
hypervisor:</p>
<pre class="literal-block">
$ ovn-sbctl show
Chassis fakechassis
    Encap geneve
    ip: &quot;127.0.0.1&quot;
    Port_Binding &quot;provnet1-3-port1&quot;
    Port_Binding &quot;provnet1-8-101-port1&quot;
    Port_Binding &quot;provnet1-7-101-port1&quot;
    Port_Binding &quot;provnet1-4-port1&quot;
Chassis &quot;56b18105-5706-46ef-80c4-ff20979ab068&quot;
    hostname: sandbox
    Encap geneve
    ip: &quot;127.0.0.1&quot;
    Port_Binding &quot;provnet1-2-port1&quot;
    Port_Binding &quot;provnet1-5-101-port1&quot;
    Port_Binding &quot;provnet1-1-port1&quot;
    Port_Binding &quot;provnet1-6-101-port1&quot;
</pre>
<p>All of the traces from the previous example, <tt class="docutils literal">env4</tt>, should work in this
environment and provide the same result.  Now we can show what happens for the
ports connected to VLAN 101.  This first example shows a packet originating
from <tt class="docutils literal"><span class="pre">provnet1-5-101-port1</span></tt>, which is OpenFlow port 6.  We should see VLAN
tag 101 pushed on the packet and then output to OpenFlow port 7, the patch port
to <tt class="docutils literal"><span class="pre">br-eth1</span></tt> (the bridge providing connectivity to <tt class="docutils literal">physnet1</tt>), and finally
arrives on OpenFlow port 8.</p>
<blockquote>
$ ovn/env5/packet1.sh</blockquote>
<p>If we look at a broadcast packet arriving on VLAN 101 of <tt class="docutils literal">physnet1</tt>, we
should see it output to OpenFlow ports 6 and 8 only:</p>
<pre class="literal-block">
$ ovn/env5/packet2.sh
</pre>
</div>
<div class="section" id="stateful-acls">
<h1>Stateful ACLs</h1>
<p>ACLs provide a way to do distributed packet filtering for OVN networks.  One
example use of ACLs is that OpenStack Neutron uses them to implement security
groups.  ACLs are implemented using conntrack integration with OVS.</p>
<p>Start with a simple logical switch with 2 logical ports:</p>
<pre class="literal-block">
$ ovn/env6/setup.sh
</pre>
<p>A common use case would be the following policy applied for <tt class="docutils literal"><span class="pre">sw0-port1</span></tt>:</p>
<ul class="simple">
<li>Allow outbound IP traffic and associated return traffic.</li>
<li>Allow incoming ICMP requests and associated return traffic.</li>
<li>Allow incoming SSH connections and associated return traffic.</li>
<li>Drop other incoming IP traffic.</li>
</ul>
<p>The following script applies this policy to our environment:</p>
<pre class="literal-block">
$ ovn/env6/add-acls.sh
</pre>
<p>We can view the configured ACLs on this network using the <tt class="docutils literal"><span class="pre">ovn-nbctl</span></tt>
command:</p>
<pre class="literal-block">
$ ovn-nbctl acl-list sw0
from-lport  1002 (inport == &quot;sw0-port1&quot; &amp;&amp; ip) allow-related
  to-lport  1002 (outport == &quot;sw0-port1&quot; &amp;&amp; ip &amp;&amp; icmp) allow-related
  to-lport  1002 (outport == &quot;sw0-port1&quot; &amp;&amp; ip &amp;&amp; tcp &amp;&amp; tcp.dst == 22) allow-related
  to-lport  1001 (outport == &quot;sw0-port1&quot; &amp;&amp; ip) drop
</pre>
<p>Now that we have ACLs configured, there are new entries in the logical flow
table in the stages <tt class="docutils literal">switch_in_pre_acl</tt>, <tt class="docutils literal">switch_in_acl</tt>,
<tt class="docutils literal">switch_out_pre_acl</tt>, and <tt class="docutils literal">switch_out_acl</tt>.</p>
<blockquote>
$ ovn-sbctl lflow-list</blockquote>
<p>Let's look more closely at <tt class="docutils literal">switch_out_pre_acl</tt> and <tt class="docutils literal">switch_out_acl</tt>.</p>
<p>In <tt class="docutils literal">switch_out_pre_acl</tt>, we match IP traffic and put it through the
connection tracker.  This populates the connection state fields so that we can
apply policy as appropriate:</p>
<pre class="literal-block">
table=0(switch_out_pre_acl), priority=  100, match=(ip), action=(ct_next;)
table=1(switch_out_pre_acl), priority=    0, match=(1), action=(next;)
</pre>
<p>In <tt class="docutils literal">switch_out_acl</tt>, we allow packets associated with existing connections.
We drop packets that are deemed to be invalid (such as non-SYN TCP packet not
associated with an existing connection):</p>
<pre class="literal-block">
table=1(switch_out_acl), priority=65535, match=(!ct.est &amp;&amp; ct.rel &amp;&amp; !ct.new &amp;&amp; !ct.inv), action=(next;)
table=1(switch_out_acl), priority=65535, match=(ct.est &amp;&amp; !ct.rel &amp;&amp; !ct.new &amp;&amp; !ct.inv), action=(next;)
table=1(switch_out_acl), priority=65535, match=(ct.inv), action=(drop;)
</pre>
<p>For new connections, we apply our configured ACL policy to decide whether to
allow the connection or not.  In this case, we'll allow ICMP or SSH.
Otherwise, we'll drop the packet:</p>
<pre class="literal-block">
table=1(switch_out_acl), priority= 2002, match=(ct.new &amp;&amp; (outport == &quot;sw0-port1&quot; &amp;&amp; ip &amp;&amp; icmp)), action=(ct_commit; next;)
table=1(switch_out_acl), priority= 2002, match=(ct.new &amp;&amp; (outport == &quot;sw0-port1&quot; &amp;&amp; ip &amp;&amp; tcp &amp;&amp; tcp.dst == 22)), action=(ct_commit; next;)
table=1(switch_out_acl), priority= 2001, match=(outport == &quot;sw0-port1&quot; &amp;&amp; ip), action=(drop;)
</pre>
<p>When using ACLs, the default policy is to allow and track IP connections.
Based on our above policy, IP traffic directed at <tt class="docutils literal"><span class="pre">sw0-port1</span></tt> will never hit
this flow at priority 1:</p>
<pre class="literal-block">
table=1(switch_out_acl), priority=    1, match=(ip), action=(ct_commit; next;)
table=1(switch_out_acl), priority=    0, match=(1), action=(next;)
</pre>
<p>Note that conntrack integration is not yet supported in ovs-sandbox, so the
OpenFlow flows will not represent what you'd see in a real environment.  The
logical flows described above give a very good idea of what the flows look
like, though.</p>
<p><a class="reference external" href="http://blog.russellbryant.net/2015/10/22/openstack-security-groups-using-ovn-acls/">This blog post</a>
discusses OVN ACLs from an OpenStack perspective and also provides an example
of what the resulting OpenFlow flows look like.</p>
</div>
<div class="section" id="container-ports">
<h1>Container Ports</h1>
<p>OVN supports containers running directly on the hypervisors and running
containers inside VMs. This example shows how OVN supports network
virtualization to containers when run inside VMs. Details about how to use
docker containers in OVS can be found in the <a class="reference external" href="../INSTALL.Docker.rst">Docker installlation guide</a>.</p>
<p>To support container traffic created inside a VM and to distinguish network
traffic coming from different container vifs, for each container a logical port
needs to be created with parent name set to the VM's logical port and the tag
set to the vlan tag of the container vif.</p>
<p>Start with a simple logical switch with three logical ports:</p>
<pre class="literal-block">
$ ovn/env7/setup.sh
</pre>
<p>Lets create a container vif attached to the logical port <tt class="docutils literal"><span class="pre">sw0-port1</span></tt> and
another container vif attached to the logical port <tt class="docutils literal"><span class="pre">sw0-port2</span></tt>:</p>
<pre class="literal-block">
$ ovn/env7/add-container-ports.sh
</pre>
<p>Run the <tt class="docutils literal"><span class="pre">ovn-nbctl</span></tt> command to see the logical ports:</p>
<pre class="literal-block">
$ovn-nbctl show
</pre>
<p>As you can see a logical port <tt class="docutils literal"><span class="pre">csw0-cport1</span></tt> is created on a logical switch
'csw0' whose parent is <tt class="docutils literal"><span class="pre">sw0-port1</span></tt> and it has tag set to <tt class="docutils literal">42</tt>.  In
addition, a logical port <tt class="docutils literal"><span class="pre">csw0-cport2</span></tt> is created on the logical switch
<tt class="docutils literal">csw0</tt> whose parent is <tt class="docutils literal"><span class="pre">sw0-port2</span></tt> and it has tag set to <tt class="docutils literal">43</tt>.</p>
<p>Bridge <tt class="docutils literal"><span class="pre">br-vmport1</span></tt> represents the ovs bridge running inside the VM connected
to the logical port <tt class="docutils literal"><span class="pre">sw0-port1</span></tt>. In this tutorial the ovs port to
<tt class="docutils literal"><span class="pre">sw0-port1</span></tt> is created as a patch port with its peer connected to the ovs
bridge <tt class="docutils literal"><span class="pre">br-vmport1</span></tt>. An ovs port <tt class="docutils literal">cport1</tt> is added to <tt class="docutils literal"><span class="pre">br-vmport1</span></tt> which
represents the container interface connected to the ovs bridge and vlan tag set
to <tt class="docutils literal">42</tt>. Similarly <tt class="docutils literal"><span class="pre">br-vmport2</span></tt> represents the ovs bridge for the logical
port <tt class="docutils literal"><span class="pre">sw0-port2</span></tt> and <tt class="docutils literal">cport2</tt> connected to <tt class="docutils literal"><span class="pre">br-vmport2</span></tt> with vlan tag set
to <tt class="docutils literal">43</tt>.</p>
<p>This first trace shows a packet from <tt class="docutils literal"><span class="pre">csw0-port1</span></tt> with a destination mac
address of <tt class="docutils literal"><span class="pre">csw0-port2</span></tt>. You can see ovs bridge of the vm <tt class="docutils literal"><span class="pre">br-vmport1</span></tt> tags
the traffic with vlan id <tt class="docutils literal">42</tt> and the traffic reaches to the br-int because
of the patch port. As you can see below <tt class="docutils literal"><span class="pre">ovn-controller</span></tt> has added a flow to
strip the vlan tag and set the reg6 and metadata appropriately:</p>
<pre class="literal-block">
$ ovs-ofctl -O OpenFlow13 dump-flows br-int
OFPST_FLOW reply (OF1.3) (xid=0x2):
cookie=0x0, duration=2767.032s, table=0, n_packets=0, n_bytes=0, priority=150,in_port=3,dl_vlan=42 actions=pop_vlan,set_field:0x3-&gt;reg5,set_field:0x2-&gt;metadata,set_field:0x1-&gt;reg6,resubmit(,16)
cookie=0x0, duration=2767.002s, table=0, n_packets=0, n_bytes=0, priority=150,in_port=4,dl_vlan=43 actions=pop_vlan,set_field:0x4-&gt;reg5,set_field:0x2-&gt;metadata,set_field:0x2-&gt;reg6,resubmit(,16)
cookie=0x0, duration=2767.032s, table=0, n_packets=0, n_bytes=0, priority=100,in_port=3 actions=set_field:0x1-&gt;reg5,set_field:0x1-&gt;metadata,set_field:0x1-&gt;reg6,resubmit(,16)
cookie=0x0, duration=2767.001s, table=0, n_packets=0, n_bytes=0, priority=100,in_port=4 actions=set_field:0x2-&gt;reg5,set_field:0x1-&gt;metadata,set_field:0x2-&gt;reg6,resubmit(,16)
</pre>
<pre class="literal-block">
$ ovn/env7/packet1.sh
</pre>
<p>The second trace shows a packet from <tt class="docutils literal"><span class="pre">csw0-port2</span></tt> to <tt class="docutils literal"><span class="pre">csw0-port1</span></tt>:</p>
<pre class="literal-block">
$ ovn/env7/packet2.sh
</pre>
<p>You can extend this setup by adding additional container ports with two
hypervisors. Refer to tutorial three above.</p>
</div>
<div class="section" id="l2gateway-ports">
<h1>L2Gateway Ports</h1>
<p>L2Gateway provides a way to connect logical switch ports of type <tt class="docutils literal">l2gateway</tt>
to a physical network.  The difference between <tt class="docutils literal">l2gateway</tt> ports and
<tt class="docutils literal">localnet</tt> ports is that an <tt class="docutils literal">l2gateway</tt> port is bound to a specific
chassis.  A single chassis serves as the L2 gateway to the physical network and
all traffic between chassis continues to go over geneve tunnels.</p>
<p>Start with a simple logical switch with three logical ports:</p>
<pre class="literal-block">
$ ovn/env8/setup.sh
</pre>
<p>This first example shows a packet originating from <tt class="docutils literal">lport1</tt>, which is
OpenFlow port 1.  We expect all packets from <tt class="docutils literal">lport1</tt> to be sent out to
<tt class="docutils literal"><span class="pre">br-eth1</span></tt> (<tt class="docutils literal"><span class="pre">patch-br-int-to-sw0-port3</span></tt>, OpenFlow port 3).  The patch port
to <tt class="docutils literal"><span class="pre">br-eth1</span></tt> provides connectivity to the physical network.</p>
<blockquote>
$ ovn/env8/packet1.sh</blockquote>
<p>The last trace shows what happens when a broadcast packet arrives from the
network.  In this case, it simulates a broadcast that originated from a port on
the physical network and arrived at the local chassis via <tt class="docutils literal"><span class="pre">br-eth1</span></tt>. We
should see it output to the local ports <tt class="docutils literal">lport1</tt> and <tt class="docutils literal">lport2</tt>:</p>
<pre class="literal-block">
$ ovn/env8/packet2.sh
</pre>
</div>
</div>
</body>
</html>
