<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>INSTALL.DPDK-ADVANCED.rst (Open vSwitch 2.6.90)</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="open-vswitch-with-dpdk-advanced">
<h1 class="title">Open vSwitch with DPDK (Advanced)</h1>

<!-- Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations
under the License.

Convention for heading levels in Open vSwitch documentation:

=======  Heading 0 (reserved for the title in a document)
- - - - - - -  Heading 1
~~~~~~~  Heading 2
+++++++  Heading 3
'''''''  Heading 4

Avoid deeper levels because they do not render well. -->
<p>The Advanced Install Guide explains how to improve OVS performance when using
DPDK datapath. This guide provides information on tuning, system configuration,
troubleshooting, static code analysis and testcases.</p>
<div class="section" id="building-as-a-shared-library">
<h1>Building as a Shared Library</h1>
<p>DPDK can be built as a static or a shared library and shall be linked by
applications using DPDK datapath. When building OVS with DPDK, you can link
Open vSwitch against the shared DPDK library.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Minor performance loss is seen with OVS when using shared DPDK library as
compared to static library.</p>
</div>
<p>To build Open vSwitch using DPDK as a shared library, first refer to the <a class="reference external" href="INSTALL.DPDK.rst">DPDK
installation guide</a> for download instructions for DPDK and OVS.</p>
<p>Once DPDK and OVS have been downloaded, you must configure the DPDK library
accordingly. Simply set <tt class="docutils literal">CONFIG_RTE_BUILD_SHARED_LIB=y</tt> in
<tt class="docutils literal">config/common_base</tt>, then build and install DPDK. Once done, DPDK can be
built as usual. For example:</p>
<pre class="literal-block">
$ export DPDK_TARGET=x86_64-native-linuxapp-gcc
$ export DPDK_BUILD=$DPDK_DIR/$DPDK_TARGET
$ make install T=$DPDK_TARGET DESTDIR=install
</pre>
<p>Once DPDK is built, export the DPDK shared library location and setup OVS as
detailed in the <a class="reference external" href="INSTALL.DPDK.rst">DPDK installation guide</a>:</p>
<pre class="literal-block">
$ export LD_LIBRARY_PATH=$DPDK_DIR/x86_64-native-linuxapp-gcc/lib
</pre>
</div>
<div class="section" id="system-configuration">
<h1>System Configuration</h1>
<p>To achieve optimal OVS performance, the system can be configured and that
includes BIOS tweaks, Grub cmdline additions, better understanding of NUMA
nodes and apt selection of PCIe slots for NIC placement.</p>
<div class="section" id="recommended-bios-settings">
<h2>Recommended BIOS Settings</h2>
<table border="1" class="docutils">
<caption>Recommended BIOS Settings</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Setting</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>C3 Power State</td>
<td>Disabled</td>
</tr>
<tr><td>C6 Power State</td>
<td>Disabled</td>
</tr>
<tr><td>MLC Streamer</td>
<td>Enabled</td>
</tr>
<tr><td>MLC Spacial Prefetcher</td>
<td>Enabled</td>
</tr>
<tr><td>DCU Data Prefetcher</td>
<td>Enabled</td>
</tr>
<tr><td>DCA</td>
<td>Enabled</td>
</tr>
<tr><td>CPU Power and Performance</td>
<td>Performance</td>
</tr>
<tr><td>Memeory RAS and Performance Config -&gt; NUMA optimized</td>
<td>Enabled</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="pcie-slot-selection">
<h2>PCIe Slot Selection</h2>
<p>The fastpath performance can be affected by factors related to the placement of
the NIC, such as channel speeds between PCIe slot and CPU or the proximity of
PCIe slot to the CPU cores running the DPDK application. Listed below are the
steps to identify right PCIe slot.</p>
<ol class="arabic">
<li><p class="first">Retrieve host details using <tt class="docutils literal">dmidecode</tt>. For example:</p>
<pre class="literal-block">
$ dmidecode -t baseboard | grep &quot;Product Name&quot;
</pre>
</li>
<li><p class="first">Download the technical specification for product listed, e.g: S2600WT2</p>
</li>
<li><p class="first">Check the Product Architecture Overview on the Riser slot placement, CPU
sharing info and also PCIe channel speeds</p>
<p>For example: On S2600WT, CPU1 and CPU2 share Riser Slot 1 with Channel speed
between CPU1 and Riser Slot1 at 32GB/s, CPU2 and Riser Slot1 at 16GB/s.
Running DPDK app on CPU1 cores and NIC inserted in to Riser card Slots will
optimize OVS performance in this case.</p>
</li>
<li><p class="first">Check the Riser Card #1 - Root Port mapping information, on the available
slots and individual bus speeds. In S2600WT slot 1, slot 2 has high bus
speeds and are potential slots for NIC placement.</p>
</li>
</ol>
</div>
<div class="section" id="advanced-hugepage-setup">
<h2>Advanced Hugepage Setup</h2>
<p>Allocate and mount 1 GB hugepages.</p>
<ul>
<li><p class="first">For persistent allocation of huge pages, add the following options to the
kernel bootline:</p>
<pre class="literal-block">
default_hugepagesz=1GB hugepagesz=1G hugepages=N
</pre>
<p>For platforms supporting multiple huge page sizes, add multiple options:</p>
<pre class="literal-block">
default_hugepagesz=&lt;size&gt; hugepagesz=&lt;size&gt; hugepages=N
</pre>
<p>where:</p>
<dl class="docutils">
<dt><tt class="docutils literal">N</tt></dt>
<dd><p class="first last">number of huge pages requested</p>
</dd>
<dt><tt class="docutils literal">size</tt></dt>
<dd><p class="first last">huge page size with an optional suffix <tt class="docutils literal">[kKmMgG]</tt></p>
</dd>
</dl>
</li>
<li><p class="first">For run-time allocation of huge pages:</p>
<pre class="literal-block">
$ echo N &gt; /sys/devices/system/node/nodeX/hugepages/hugepages-1048576kB/nr_hugepages
</pre>
<p>where:</p>
<dl class="docutils">
<dt><tt class="docutils literal">N</tt></dt>
<dd><p class="first last">number of huge pages requested</p>
</dd>
<dt><tt class="docutils literal">X</tt></dt>
<dd><p class="first last">NUMA Node</p>
</dd>
</dl>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">For run-time allocation of 1G huge pages, Contiguous Memory Allocator
(<tt class="docutils literal">CONFIG_CMA</tt>) has to be supported by kernel, check your Linux distro.</p>
</div>
</li>
</ul>
<p>Now mount the huge pages, if not already done so:</p>
<pre class="literal-block">
$ mount -t hugetlbfs -o pagesize=1G none /dev/hugepages
</pre>
</div>
<div class="section" id="enable-hyperthreading">
<h2>Enable HyperThreading</h2>
<p>With HyperThreading, or SMT, enabled, a physical core appears as two logical
cores. SMT can be utilized to spawn worker threads on logical cores of the same
physical core there by saving additional cores.</p>
<p>With DPDK, when pinning pmd threads to logical cores, care must be taken to set
the correct bits of the <tt class="docutils literal"><span class="pre">pmd-cpu-mask</span></tt> to ensure that the pmd threads are
pinned to SMT siblings.</p>
<p>Take a sample system configuration, with 2 sockets, 2 * 10 core processors, HT
enabled. This gives us a total of 40 logical cores. To identify the physical
core shared by two logical cores, run:</p>
<pre class="literal-block">
$ cat /sys/devices/system/cpu/cpuN/topology/thread_siblings_list
</pre>
<p>where <tt class="docutils literal">N</tt> is the logical core number.</p>
<p>In this example, it would show that cores <tt class="docutils literal">1</tt> and <tt class="docutils literal">21</tt> share the same
physical core., thus, the <tt class="docutils literal"><span class="pre">pmd-cpu-mask</span></tt> can be used to enable these two pmd
threads running on these two logical cores (one physical core) is:</p>
<pre class="literal-block">
$ ovs-vsctl set Open_vSwitch . other_config:pmd-cpu-mask=100002
</pre>
</div>
<div class="section" id="isolate-cores">
<h2>Isolate Cores</h2>
<p>The <tt class="docutils literal">isolcpus</tt> option can be used to isolate cores from the Linux scheduler.
The isolated cores can then be used to dedicatedly run HPC applications or
threads.  This helps in better application performance due to zero context
switching and minimal cache thrashing. To run platform logic on core 0 and
isolate cores between 1 and 19 from scheduler, add  <tt class="docutils literal"><span class="pre">isolcpus=1-19</span></tt> to GRUB
cmdline.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">It has been verified that core isolation has minimal advantage due to mature
Linux scheduler in some circumstances.</p>
</div>
</div>
<div class="section" id="numa-cluster-on-die">
<h2>NUMA/Cluster-on-Die</h2>
<p>Ideally inter-NUMA datapaths should be avoided where possible as packets will
go across QPI and there may be a slight performance penalty when compared with
intra NUMA datapaths. On Intel Xeon Processor E5 v3, Cluster On Die is
introduced on models that have 10 cores or more.  This makes it possible to
logically split a socket into two NUMA regions and again it is preferred where
possible to keep critical datapaths within the one cluster.</p>
<p>It is good practice to ensure that threads that are in the datapath are pinned
to cores in the same NUMA area. e.g. pmd threads and QEMU vCPUs responsible for
forwarding. If DPDK is built with <tt class="docutils literal">CONFIG_RTE_LIBRTE_VHOST_NUMA=y</tt>, vHost
User ports automatically detect the NUMA socket of the QEMU vCPUs and will be
serviced by a PMD from the same node provided a core on this node is enabled in
the <tt class="docutils literal"><span class="pre">pmd-cpu-mask</span></tt>. <tt class="docutils literal">libnuma</tt> packages are required for this feature.</p>
</div>
<div class="section" id="compiler-optimizations">
<h2>Compiler Optimizations</h2>
<p>The default compiler optimization level is <tt class="docutils literal"><span class="pre">-O2</span></tt>. Changing this to more
aggressive compiler optimization such as <tt class="docutils literal"><span class="pre">-O3</span> <span class="pre">-march=native</span></tt> with
gcc (verified on 5.3.1) can produce performance gains though not siginificant.
<tt class="docutils literal"><span class="pre">-march=native</span></tt> will produce optimized code on local machine and should be
used when software compilation is done on Testbed.</p>
</div>
</div>
<div class="section" id="performance-tuning">
<h1>Performance Tuning</h1>
<div class="section" id="affinity">
<h2>Affinity</h2>
<p>For superior performance, DPDK pmd threads and Qemu vCPU threads needs to be
affinitized accordingly.</p>
<ul>
<li><p class="first">PMD thread Affinity</p>
<p>A poll mode driver (pmd) thread handles the I/O of all DPDK interfaces
assigned to it. A pmd thread shall poll the ports for incoming packets,
switch the packets and send to tx port.  pmd thread is CPU bound, and needs
to be affinitized to isolated cores for optimum performance.</p>
<p>By setting a bit in the mask, a pmd thread is created and pinned to the
corresponding CPU core. e.g. to run a pmd thread on core 2:</p>
<pre class="literal-block">
$ ovs-vsctl set Open_vSwitch . other_config:pmd-cpu-mask=4
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">pmd thread on a NUMA node is only created if there is at least one DPDK
interface from that NUMA node added to OVS.</p>
</div>
</li>
<li><p class="first">QEMU vCPU thread Affinity</p>
<p>A VM performing simple packet forwarding or running complex packet pipelines
has to ensure that the vCPU threads performing the work has as much CPU
occupancy as possible.</p>
<p>For example, on a multicore VM, multiple QEMU vCPU threads shall be spawned.
When the DPDK <tt class="docutils literal">testpmd</tt> application that does packet forwarding is invoked,
the <tt class="docutils literal">taskset</tt> command should be used to affinitize the vCPU threads to the
dedicated isolated cores on the host system.</p>
</li>
</ul>
</div>
<div class="section" id="multiple-poll-mode-driver-threads">
<h2>Multiple Poll-Mode Driver Threads</h2>
<p>With pmd multi-threading support, OVS creates one pmd thread for each NUMA node
by default. However, in cases where there are multiple ports/rxq's producing
traffic, performance can be improved by creating multiple pmd threads running
on separate cores. These pmd threads can share the workload by each being
responsible for different ports/rxq's. Assignment of ports/rxq's to pmd threads
is done automatically.</p>
<p>A set bit in the mask means a pmd thread is created and pinned to the
corresponding CPU core. For example, to run pmd threads on core 1 and 2:</p>
<pre class="literal-block">
$ ovs-vsctl set Open_vSwitch . other_config:pmd-cpu-mask=6
</pre>
<p>When using dpdk and dpdkvhostuser ports in a bi-directional VM loopback as
shown below, spreading the workload over 2 or 4 pmd threads shows significant
improvements as there will be more total CPU occupancy available:</p>
<pre class="literal-block">
NIC port0 &lt;-&gt; OVS &lt;-&gt; VM &lt;-&gt; OVS &lt;-&gt; NIC port 1
</pre>
</div>
<div class="section" id="dpdk-physical-port-rx-queues">
<h2>DPDK Physical Port Rx Queues</h2>
<pre class="literal-block">
$ ovs-vsctl set Interface &lt;DPDK interface&gt; options:n_rxq=&lt;integer&gt;
</pre>
<p>The command above sets the number of rx queues for DPDK physical interface.
The rx queues are assigned to pmd threads on the same NUMA node in a
round-robin fashion.</p>
</div>
<div class="section" id="dpdk-physical-port-queue-sizes">
<h2>DPDK Physical Port Queue Sizes</h2>
<pre class="literal-block">
$ ovs-vsctl set Interface dpdk0 options:n_rxq_desc=&lt;integer&gt;
$ ovs-vsctl set Interface dpdk0 options:n_txq_desc=&lt;integer&gt;
</pre>
<p>The command above sets the number of rx/tx descriptors that the NIC associated
with dpdk0 will be initialised with.</p>
<p>Different <tt class="docutils literal">n_rxq_desc</tt> and <tt class="docutils literal">n_txq_desc</tt> configurations yield different
benefits in terms of throughput and latency for different scenarios.
Generally, smaller queue sizes can have a positive impact for latency at the
expense of throughput. The opposite is often true for larger queue sizes.
Note: increasing the number of rx descriptors eg. to 4096  may have a negative
impact on performance due to the fact that non-vectorised DPDK rx functions may
be used. This is dependant on the driver in use, but is true for the commonly
used i40e and ixgbe DPDK drivers.</p>
</div>
<div class="section" id="exact-match-cache">
<h2>Exact Match Cache</h2>
<p>Each pmd thread contains one Exact Match Cache (EMC). After initial flow setup
in the datapath, the EMC contains a single table and provides the lowest level
(fastest) switching for DPDK ports. If there is a miss in the EMC then the next
level where switching will occur is the datapath classifier.  Missing in the
EMC and looking up in the datapath classifier incurs a significant performance
penalty.  If lookup misses occur in the EMC because it is too small to handle
the number of flows, its size can be increased. The EMC size can be modified by
editing the define <tt class="docutils literal">EM_FLOW_HASH_SHIFT</tt> in <tt class="docutils literal"><span class="pre">lib/dpif-netdev.c</span></tt>.</p>
<p>As mentioned above, an EMC is per pmd thread. An alternative way of increasing
the aggregate amount of possible flow entries in EMC and avoiding datapath
classifier lookups is to have multiple pmd threads running.</p>
</div>
<div class="section" id="rx-mergeable-buffers">
<h2>Rx Mergeable Buffers</h2>
<p>Rx mergeable buffers is a virtio feature that allows chaining of multiple
virtio descriptors to handle large packet sizes. Large packets are handled by
reserving and chaining multiple free descriptors together. Mergeable buffer
support is negotiated between the virtio driver and virtio device and is
supported by the DPDK vhost library.  This behavior is supported and enabled by
default, however in the case where the user knows that rx mergeable buffers are
not needed i.e. jumbo frames are not needed, it can be forced off by adding
<tt class="docutils literal">mrg_rxbuf=off</tt> to the QEMU command line options. By not reserving multiple
chains of descriptors it will make more individual virtio descriptors available
for rx to the guest using dpdkvhost ports and this can improve performance.</p>
</div>
</div>
<div class="section" id="ovs-testcases">
<h1>OVS Testcases</h1>
<div class="section" id="phy-vm-phy-vhost-loopback">
<h2>PHY-VM-PHY (vHost Loopback)</h2>
<p>The <a class="reference external" href="INSTALL.DPDK.rst">DPDK installation guide</a> details steps for PHY-VM-PHY loopback testcase
and packet forwarding using DPDK testpmd application in the Guest VM. For users
wishing to do packet forwarding using kernel stack below, you need to run the
below commands on the guest:</p>
<pre class="literal-block">
$ ifconfig eth1 1.1.1.2/24
$ ifconfig eth2 1.1.2.2/24
$ systemctl stop firewalld.service
$ systemctl stop iptables.service
$ sysctl -w net.ipv4.ip_forward=1
$ sysctl -w net.ipv4.conf.all.rp_filter=0
$ sysctl -w net.ipv4.conf.eth1.rp_filter=0
$ sysctl -w net.ipv4.conf.eth2.rp_filter=0
$ route add -net 1.1.2.0/24 eth2
$ route add -net 1.1.1.0/24 eth1
$ arp -s 1.1.2.99 DE:AD:BE:EF:CA:FE
$ arp -s 1.1.1.99 DE:AD:BE:EF:CA:EE
</pre>
</div>
<div class="section" id="phy-vm-phy-ivshmem">
<h2>PHY-VM-PHY (IVSHMEM)</h2>
<p>IVSHMEM can also be validated using the PHY-VM-PHY configuration. To begin,
follow the steps described in the <a class="reference external" href="INSTALL.DPDK.rst">DPDK installation guide</a> to create and
initialize the database, start ovs-vswitchd and add <tt class="docutils literal">dpdk</tt>-type devices to
bridge <tt class="docutils literal">br0</tt>. Once complete, follow the below steps:</p>
<ol class="arabic">
<li><p class="first">Add DPDK ring port to the bridge:</p>
<pre class="literal-block">
$ ovs-vsctl add-port br0 dpdkr0 -- set Interface dpdkr0 type=dpdkr
</pre>
</li>
<li><p class="first">Build modified QEMU</p>
<p>QEMU must be patched to enable IVSHMEM support:</p>
<pre class="literal-block">
$ cd /usr/src/
$ wget http://wiki.qemu.org/download/qemu-2.2.1.tar.bz2
$ tar -jxvf qemu-2.2.1.tar.bz2
$ cd /usr/src/qemu-2.2.1
$ wget https://raw.githubusercontent.com/netgroup-polito/un-orchestrator/master/orchestrator/compute_controller/plugins/kvm-libvirt/patches/ivshmem-qemu-2.2.1.patch
$ patch -p1 &lt; ivshmem-qemu-2.2.1.patch
$ ./configure --target-list=x86_64-softmmu --enable-debug --extra-cflags='-g'
$ make -j 4
</pre>
</li>
<li><p class="first">Generate QEMU commandline:</p>
<pre class="literal-block">
$ mkdir -p /usr/src/cmdline_generator
$ cd /usr/src/cmdline_generator
$ wget https://raw.githubusercontent.com/netgroup-polito/un-orchestrator/master/orchestrator/compute_controller/plugins/kvm-libvirt/cmdline_generator/cmdline_generator.c
$ wget https://raw.githubusercontent.com/netgroup-polito/un-orchestrator/master/orchestrator/compute_controller/plugins/kvm-libvirt/cmdline_generator/Makefile
$ export RTE_SDK=/usr/src/dpdk-16.07
$ export RTE_TARGET=x86_64-ivshmem-linuxapp-gcc
$ make
$ ./build/cmdline_generator -m -p dpdkr0 XXX
$ cmdline=`cat OVSMEMPOOL`
</pre>
</li>
<li><p class="first">Start guest VM:</p>
<pre class="literal-block">
$ export VM_NAME=ivshmem-vm
$ export QCOW2_IMAGE=/root/CentOS7_x86_64.qcow2
$ export QEMU_BIN=/usr/src/qemu-2.2.1/x86_64-softmmu/qemu-system-x86_64
$ taskset 0x20 $QEMU_BIN -cpu host -smp 2,cores=2 -hda $QCOW2_IMAGE \
    -m 4096 --enable-kvm -name $VM_NAME -nographic -vnc :2 \
    -pidfile /tmp/vm1.pid $cmdline
</pre>
</li>
<li><p class="first">Build and run the sample <tt class="docutils literal">dpdkr</tt> app in VM:</p>
<pre class="literal-block">
$ echo 1024 &gt; /proc/sys/vm/nr_hugepages
$ mount -t hugetlbfs nodev /dev/hugepages (if not already mounted)

# Build the DPDK ring application in the VM
$ export RTE_SDK=/root/dpdk-16.07
$ export RTE_TARGET=x86_64-ivshmem-linuxapp-gcc
$ make

# Run dpdkring application
$ ./build/dpdkr -c 1 -n 4 -- -n 0
# where &quot;-n 0&quot; refers to ring '0' i.e dpdkr0
</pre>
</li>
</ol>
</div>
<div class="section" id="phy-vm-phy-vhost-multiqueue">
<h2>PHY-VM-PHY (vHost Multiqueue)</h2>
<p>vHost Multique functionality can also be validated using the PHY-VM-PHY
configuration. To begin, follow the steps described in the <a class="reference external" href="INSTALL.DPDK.rst">DPDK installation
guide</a> to create and initialize the database, start ovs-vswitchd and add
<tt class="docutils literal">dpdk</tt>-type devices to bridge <tt class="docutils literal">br0</tt>. Once complete, follow the below steps:</p>
<ol class="arabic">
<li><p class="first">Configure PMD and RXQs.</p>
<p>For example, set the number of dpdk port rx queues to at least 2  The number
of rx queues at vhost-user interface gets automatically configured after
virtio device connection and doesn't need manual configuration:</p>
<pre class="literal-block">
$ ovs-vsctl set Open_vSwitch . other_config:pmd-cpu-mask=c
$ ovs-vsctl set Interface dpdk0 options:n_rxq=2
$ ovs-vsctl set Interface dpdk1 options:n_rxq=2
</pre>
</li>
<li><p class="first">Instantiate Guest VM using QEMU cmdline</p>
<p>We must configure with appropriate software versions to ensure this feature
is supported.</p>
<table border="1" class="docutils">
<caption>Recommended BIOS Settings</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Setting</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>QEMU version</td>
<td>2.5.0</td>
</tr>
<tr><td>QEMU thread affinity</td>
<td>2 cores (taskset 0x30)</td>
</tr>
<tr><td>Memory</td>
<td>4 GB</td>
</tr>
<tr><td>Cores</td>
<td>2</td>
</tr>
<tr><td>Distro</td>
<td>Fedora 22</td>
</tr>
<tr><td>Multiqueue</td>
<td>Enabled</td>
</tr>
</tbody>
</table>
<p>To do this, instantiate the guest as follows:</p>
<pre class="literal-block">
$ export VM_NAME=vhost-vm
$ export GUEST_MEM=4096M
$ export QCOW2_IMAGE=/root/Fedora22_x86_64.qcow2
$ export VHOST_SOCK_DIR=/usr/local/var/run/openvswitch
$ taskset 0x30 qemu-system-x86_64 -cpu host -smp 2,cores=2 -m 4096M \
    -drive file=$QCOW2_IMAGE --enable-kvm -name $VM_NAME \
    -nographic -numa node,memdev=mem -mem-prealloc \
    -object memory-backend-file,id=mem,size=$GUEST_MEM,mem-path=/dev/hugepages,share=on \
    -chardev socket,id=char1,path=$VHOST_SOCK_DIR/dpdkvhostuser0 \
    -netdev type=vhost-user,id=mynet1,chardev=char1,vhostforce,queues=2 \
    -device virtio-net-pci,mac=00:00:00:00:00:01,netdev=mynet1,mq=on,vectors=6 \
    -chardev socket,id=char2,path=$VHOST_SOCK_DIR/dpdkvhostuser1 \
    -netdev type=vhost-user,id=mynet2,chardev=char2,vhostforce,queues=2 \
    -device virtio-net-pci,mac=00:00:00:00:00:02,netdev=mynet2,mq=on,vectors=6
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Queue value above should match the queues configured in OVS, The vector
value should be set to &quot;number of queues x 2 + 2&quot;</p>
</div>
</li>
<li><p class="first">Configure the guest interface</p>
<p>Assuming there are 2 interfaces in the guest named eth0, eth1 check the
channel configuration and set the number of combined channels to 2 for
virtio devices:</p>
<pre class="literal-block">
$ ethtool -l eth0
$ ethtool -L eth0 combined 2
$ ethtool -L eth1 combined 2
</pre>
<p>More information can be found in vHost walkthrough section.</p>
</li>
<li><p class="first">Configure kernel packet forwarding</p>
<p>Configure IP and enable interfaces:</p>
<pre class="literal-block">
$ ifconfig eth0 5.5.5.1/24 up
$ ifconfig eth1 90.90.90.1/24 up
</pre>
<p>Configure IP forwarding and add route entries:</p>
<pre class="literal-block">
$ sysctl -w net.ipv4.ip_forward=1
$ sysctl -w net.ipv4.conf.all.rp_filter=0
$ sysctl -w net.ipv4.conf.eth0.rp_filter=0
$ sysctl -w net.ipv4.conf.eth1.rp_filter=0
$ ip route add 2.1.1.0/24 dev eth1
$ route add default gw 2.1.1.2 eth1
$ route add default gw 90.90.90.90 eth1
$ arp -s 90.90.90.90 DE:AD:BE:EF:CA:FE
$ arp -s 2.1.1.2 DE:AD:BE:EF:CA:FA
</pre>
<p>Check traffic on multiple queues:</p>
<pre class="literal-block">
$ cat /proc/interrupts | grep virtio
</pre>
</li>
</ol>
</div>
</div>
<div class="section" id="vhost-walkthrough">
<h1>vHost Walkthrough</h1>
<p>Two types of vHost User ports are available in OVS:</p>
<ul class="simple">
<li>vhost-user (<tt class="docutils literal">dpdkvhostuser</tt>)</li>
<li>vhost-user-client (<tt class="docutils literal">dpdkvhostuserclient</tt>)</li>
</ul>
<p>vHost User uses a client-server model. The server creates/manages/destroys the
vHost User sockets, and the client connects to the server. Depending on which
port type you use, <tt class="docutils literal">dpdkvhostuser</tt> or <tt class="docutils literal">dpdkvhostuserclient</tt>, a different
configuration of the client-server model is used.</p>
<p>For vhost-user ports, Open vSwitch acts as the server and QEMU the client.  For
vhost-user-client ports, Open vSwitch acts as the client and QEMU the server.</p>
<div class="section" id="vhost-user">
<h2>vhost-user</h2>
<ol class="arabic">
<li><p class="first">Install the prerequisites:</p>
<ul class="simple">
<li>QEMU version &gt;= 2.2</li>
</ul>
</li>
<li><p class="first">Add vhost-user ports to the switch.</p>
<p>Unlike DPDK ring ports, DPDK vhost-user ports can have arbitrary names,
except that forward and backward slashes are prohibited in the names.</p>
<p>For vhost-user, the name of the port type is <tt class="docutils literal">dpdkvhostuser</tt>:</p>
<pre class="literal-block">
$ ovs-vsctl add-port br0 vhost-user-1 -- set Interface vhost-user-1 \
    type=dpdkvhostuser
</pre>
<p>This action creates a socket located at
<tt class="docutils literal"><span class="pre">/usr/local/var/run/openvswitch/vhost-user-1</span></tt>, which you must provide to
your VM on the QEMU command line. More instructions on this can be found in
the next section &quot;Adding vhost-user ports to VM&quot;</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p>If you wish for the vhost-user sockets to be created in a sub-directory of
<tt class="docutils literal">/usr/local/var/run/openvswitch</tt>, you may specify this directory in the
ovsdb like so:</p>
<pre class="last literal-block">
$ ovs-vsctl --no-wait \
    set Open_vSwitch . other_config:vhost-sock-dir=subdir`
</pre>
</div>
</li>
<li><p class="first">Add vhost-user ports to VM</p>
<ol class="arabic">
<li><p class="first">Configure sockets</p>
<p>Pass the following parameters to QEMU to attach a vhost-user device:</p>
<pre class="literal-block">
-chardev socket,id=char1,path=/usr/local/var/run/openvswitch/vhost-user-1
-netdev type=vhost-user,id=mynet1,chardev=char1,vhostforce
-device virtio-net-pci,mac=00:00:00:00:00:01,netdev=mynet1
</pre>
<p>where <tt class="docutils literal"><span class="pre">vhost-user-1</span></tt> is the name of the vhost-user port added to the
switch.</p>
<p>Repeat the above parameters for multiple devices, changing the chardev
<tt class="docutils literal">path</tt> and <tt class="docutils literal">id</tt> as necessary. Note that a separate and different
chardev <tt class="docutils literal">path</tt> needs to be specified for each vhost-user device. For
example you have a second vhost-user port named <tt class="docutils literal"><span class="pre">vhost-user-2</span></tt>, you
append your QEMU command line with an additional set of parameters:</p>
<pre class="literal-block">
-chardev socket,id=char2,path=/usr/local/var/run/openvswitch/vhost-user-2
-netdev type=vhost-user,id=mynet2,chardev=char2,vhostforce
-device virtio-net-pci,mac=00:00:00:00:00:02,netdev=mynet2
</pre>
</li>
</ol>
<blockquote>
<ol class="arabic" start="2">
<li><p class="first">Configure hugepages</p>
<p>QEMU must allocate the VM's memory on hugetlbfs. vhost-user ports access
a virtio-net device's virtual rings and packet buffers mapping the VM's
physical memory on hugetlbfs. To enable vhost-user ports to map the VM's
memory into their process address space, pass the following parameters
to QEMU:</p>
<pre class="literal-block">
-object memory-backend-file,id=mem,size=4096M,mem-path=/dev/hugepages,share=on
-numa node,memdev=mem -mem-prealloc
</pre>
</li>
<li><p class="first">Enable multiqueue support (optional)</p>
<p>QEMU needs to be configured to use multiqueue:</p>
<pre class="literal-block">
-chardev socket,id=char2,path=/usr/local/var/run/openvswitch/vhost-user-2
-netdev type=vhost-user,id=mynet2,chardev=char2,vhostforce,queues=$q
-device virtio-net-pci,mac=00:00:00:00:00:02,netdev=mynet2,mq=on,vectors=$v
</pre>
<p>where:</p>
<dl class="docutils">
<dt><tt class="docutils literal">$q</tt></dt>
<dd><p class="first last">The number of queues</p>
</dd>
<dt><tt class="docutils literal">$v</tt></dt>
<dd><p class="first last">The number of vectors, which is <tt class="docutils literal">$q</tt> * 2 + 2</p>
</dd>
</dl>
<p>The vhost-user interface will be automatically reconfigured with
required number of rx and tx queues after connection of virtio device.
Manual configuration of <tt class="docutils literal">n_rxq</tt> is not supported because OVS will work
properly only if <tt class="docutils literal">n_rxq</tt> will match number of queues configured in
QEMU.</p>
<p>A least 2 PMDs should be configured for the vswitch when using
multiqueue.  Using a single PMD will cause traffic to be enqueued to the
same vhost queue rather than being distributed among different vhost
queues for a vhost-user interface.</p>
<p>If traffic destined for a VM configured with multiqueue arrives to the
vswitch via a physical DPDK port, then the number of rxqs should also be
set to at least 2 for that physical DPDK port. This is required to
increase the probability that a different PMD will handle the multiqueue
transmission to the guest using a different vhost queue.</p>
<p>If one wishes to use multiple queues for an interface in the guest, the
driver in the guest operating system must be configured to do so. It is
recommended that the number of queues configured be equal to <tt class="docutils literal">$q</tt>.</p>
<p>For example, this can be done for the Linux kernel virtio-net driver
with:</p>
<pre class="literal-block">
$ ethtool -L &lt;DEV&gt; combined &lt;$q&gt;
</pre>
<p>where:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">-L</span></tt></dt>
<dd><p class="first last">Changes the numbers of channels of the specified network device</p>
</dd>
<dt><tt class="docutils literal">combined</tt></dt>
<dd><p class="first last">Changes the number of multi-purpose channels.</p>
</dd>
</dl>
</li>
</ol>
</blockquote>
</li>
</ol>
<div class="section" id="configure-the-vm-using-libvirt">
<h3>Configure the VM using libvirt</h3>
<p>You can also build and configure the VM using libvirt rather than QEMU by
itself.</p>
<ol class="arabic">
<li><p class="first">Change the user/group, access control policty and restart libvirtd.</p>
<ul>
<li><p class="first">In <tt class="docutils literal">/etc/libvirt/qemu.conf</tt> add/edit the following lines:</p>
<pre class="literal-block">
user = &quot;root&quot;
group = &quot;root&quot;
</pre>
</li>
<li><p class="first">Disable SELinux or set to permissive mode:</p>
<pre class="literal-block">
$ setenforce 0
</pre>
</li>
<li><p class="first">Restart the libvirtd process, For example, on Fedora:</p>
<pre class="literal-block">
$ systemctl restart libvirtd.service
</pre>
</li>
</ul>
</li>
<li><p class="first">Instantiate the VM</p>
<ul>
<li><p class="first">Copy the XML configuration described in the <a class="reference external" href="INSTALL.DPDK.rst">DPDK installation guide</a>.</p>
</li>
<li><p class="first">Start the VM:</p>
<pre class="literal-block">
$ virsh create demovm.xml
</pre>
</li>
<li><p class="first">Connect to the guest console:</p>
<pre class="literal-block">
$ virsh console demovm
</pre>
</li>
</ul>
</li>
<li><p class="first">Configure the VM</p>
<p>The demovm xml configuration is aimed at achieving out of box performance on
VM.</p>
<ul class="simple">
<li>The vcpus are pinned to the cores of the CPU socket 0 using <tt class="docutils literal">vcpupin</tt>.</li>
<li>Configure NUMA cell and memory shared using <tt class="docutils literal"><span class="pre">memAccess='shared'</span></tt>.</li>
<li>Disable <tt class="docutils literal"><span class="pre">mrg_rxbuf='off'</span></tt></li>
</ul>
</li>
</ol>
<p>Refer to the <a class="reference external" href="http://libvirt.org/formatdomain.html">libvirt documentation</a>
for more information.</p>
</div>
</div>
<div class="section" id="vhost-user-client">
<h2>vhost-user-client</h2>
<ol class="arabic">
<li><p class="first">Install the prerequisites:</p>
<ul class="simple">
<li>QEMU version &gt;= 2.7</li>
</ul>
</li>
<li><p class="first">Add vhost-user-client ports to the switch.</p>
<p>Unlike vhost-user ports, the name given to port does not govern the name of
the socket device. <tt class="docutils literal"><span class="pre">vhost-server-path</span></tt> reflects the full path of the
socket that has been or will be created by QEMU for the given vHost User
client port.</p>
<p>For vhost-user-client, the name of the port type is
<tt class="docutils literal">dpdkvhostuserclient</tt>:</p>
<pre class="literal-block">
$ VHOST_USER_SOCKET_PATH=/path/to/socker
$ ovs-vsctl add-port br0 vhost-client-1 \
    -- set Interface vhost-client-1 type=dpdkvhostuserclient \
         options:vhost-server-path=$VHOST_USER_SOCKET_PATH
</pre>
</li>
<li><p class="first">Add vhost-user-client ports to VM</p>
<ol class="arabic">
<li><p class="first">Configure sockets</p>
<p>Pass the following parameters to QEMU to attach a vhost-user device:</p>
<pre class="literal-block">
-chardev socket,id=char1,path=$VHOST_USER_SOCKET_PATH,server
-netdev type=vhost-user,id=mynet1,chardev=char1,vhostforce
-device virtio-net-pci,mac=00:00:00:00:00:01,netdev=mynet1
</pre>
<p>where <tt class="docutils literal"><span class="pre">vhost-user-1</span></tt> is the name of the vhost-user port added to the
switch.</p>
<p>If the corresponding dpdkvhostuserclient port has not yet been configured
in OVS with <tt class="docutils literal"><span class="pre">vhost-server-path=/path/to/socket</span></tt>, QEMU will print a log
similar to the following:</p>
<pre class="literal-block">
QEMU waiting for connection on: disconnected:unix:/path/to/socket,server
</pre>
<p>QEMU will wait until the port is created sucessfully in OVS to boot the VM.</p>
<p>One benefit of using this mode is the ability for vHost ports to
'reconnect' in event of the switch crashing or being brought down. Once
it is brought back up, the vHost ports will reconnect automatically and
normal service will resume.</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="section" id="dpdk-backend-inside-vm">
<h2>DPDK Backend Inside VM</h2>
<p>Additional configuration is required if you want to run ovs-vswitchd with DPDK
backend inside a QEMU virtual machine. Ovs-vswitchd creates separate DPDK TX
queues for each CPU core available. This operation fails inside QEMU virtual
machine because, by default, VirtIO NIC provided to the guest is configured to
support only single TX queue and single RX queue. To change this behavior, you
need to turn on <tt class="docutils literal">mq</tt> (multiqueue) property of all <tt class="docutils literal"><span class="pre">virtio-net-pci</span></tt> devices
emulated by QEMU and used by DPDK.  You may do it manually (by changing QEMU
command line) or, if you use Libvirt, by adding the following string to
<tt class="docutils literal">&lt;interface&gt;</tt> sections of all network devices used by DPDK:</p>
<pre class="literal-block">
&lt;driver name='vhost' queues='N'/&gt;
</pre>
<p>Where:</p>
<dl class="docutils">
<dt><tt class="docutils literal">N</tt></dt>
<dd>determines how many queues can be used by the guest.</dd>
</dl>
<p>This requires QEMU &gt;= 2.2.</p>
</div>
</div>
<div class="section" id="qos">
<h1>QoS</h1>
<p>Assuming you have a vhost-user port transmitting traffic consisting of packets
of size 64 bytes, the following command would limit the egress transmission
rate of the port to ~1,000,000 packets per second:</p>
<pre class="literal-block">
$ ovs-vsctl set port vhost-user0 qos=&#64;newqos -- \
    --id=&#64;newqos create qos type=egress-policer other-config:cir=46000000 \
    other-config:cbs=2048`
</pre>
<p>To examine the QoS configuration of the port, run:</p>
<pre class="literal-block">
$ ovs-appctl -t ovs-vswitchd qos/show vhost-user0
</pre>
<p>To clear the QoS configuration from the port and ovsdb, run:</p>
<pre class="literal-block">
$ ovs-vsctl destroy QoS vhost-user0 -- clear Port vhost-user0 qos
</pre>
<p>Refer to vswitch.xml for more details on egress-policer.</p>
</div>
<div class="section" id="rate-limiting">
<h1>Rate Limiting</h1>
<p>Here is an example on Ingress Policing usage.  Assuming you have a vhost-user
port receiving traffic consisting of packets of size 64 bytes, the following
command would limit the reception rate of the port to ~1,000,000 packets per
second:</p>
<pre class="literal-block">
$ ovs-vsctl set interface vhost-user0 ingress_policing_rate=368000 \
    ingress_policing_burst=1000`
</pre>
<p>To examine the ingress policer configuration of the port:</p>
<pre class="literal-block">
$ ovs-vsctl list interface vhost-user0
</pre>
<p>To clear the ingress policer configuration from the port:</p>
<pre class="literal-block">
$ ovs-vsctl set interface vhost-user0 ingress_policing_rate=0
</pre>
<p>Refer to vswitch.xml for more details on ingress-policer.</p>
</div>
<div class="section" id="flow-control">
<h1>Flow Control</h1>
<p>Flow control can be enabled only on DPDK physical ports.  To enable flow
control support at tx side while adding a port, run:</p>
<pre class="literal-block">
$ ovs-vsctl add-port br0 dpdk0 -- \
    set Interface dpdk0 type=dpdk options:tx-flow-ctrl=true
</pre>
<p>Similarly, to enable rx flow control, run:</p>
<pre class="literal-block">
$ ovs-vsctl add-port br0 dpdk0 -- \
    set Interface dpdk0 type=dpdk options:rx-flow-ctrl=true
</pre>
<p>To enable flow control auto-negotiation, run:</p>
<pre class="literal-block">
$ ovs-vsctl add-port br0 dpdk0 -- \
    set Interface dpdk0 type=dpdk options:flow-ctrl-autoneg=true
</pre>
<p>To turn ON the tx flow control at run time(After the port is being added to
OVS):</p>
<pre class="literal-block">
$ ovs-vsctl set Interface dpdk0 options:tx-flow-ctrl=true
</pre>
<p>The flow control parameters can be turned off by setting <tt class="docutils literal">false</tt> to the
respective parameter. To disable the flow control at tx side, run:</p>
<pre class="literal-block">
$ ovs-vsctl set Interface dpdk0 options:tx-flow-ctrl=false
</pre>
</div>
<div class="section" id="pdump">
<h1>pdump</h1>
<p>Pdump allows you to listen on DPDK ports and view the traffic that is passing
on them. To use this utility, one must have libpcap installed on the system.
Furthermore, DPDK must be built with <tt class="docutils literal">CONFIG_RTE_LIBRTE_PDUMP=y</tt> and
<tt class="docutils literal">CONFIG_RTE_LIBRTE_PMD_PCAP=y</tt>.</p>
<div class="warning">
<p class="first admonition-title">Warning</p>
<p class="last">A performance decrease is expected when using a monitoring application like
the DPDK pdump app.</p>
</div>
<p>To use pdump, simply launch OVS as usual. Then, navigate to the <tt class="docutils literal">app/pdump</tt>
directory in DPDK, <tt class="docutils literal">make</tt> the application and run like so:</p>
<pre class="literal-block">
$ sudo ./build/app/dpdk-pdump -- \
    --pdump port=0,queue=0,rx-dev=/tmp/pkts.pcap \
    --server-socket-path=/usr/local/var/run/openvswitch
</pre>
<p>The above command captures traffic received on queue 0 of port 0 and stores it
in <tt class="docutils literal">/tmp/pkts.pcap</tt>. Other combinations of port numbers, queues numbers and
pcap locations are of course also available to use. For example, to capture all
packets that traverse port 0 in a single pcap file:</p>
<pre class="literal-block">
$ sudo ./build/app/dpdk-pdump -- \
    --pdump 'port=0,queue=*,rx-dev=/tmp/pkts.pcap,tx-dev=/tmp/pkts.pcap' \
    --server-socket-path=/usr/local/var/run/openvswitch
</pre>
<p><tt class="docutils literal"><span class="pre">server-socket-path</span></tt> must be set to the value of ovs_rundir() which typically
resolves to <tt class="docutils literal">/usr/local/var/run/openvswitch</tt>.</p>
<p>Many tools are available to view the contents of the pcap file. Once example is
tcpdump. Issue the following command to view the contents of <tt class="docutils literal">pkts.pcap</tt>:</p>
<pre class="literal-block">
$ tcpdump -r pkts.pcap
</pre>
<p>More information on the pdump app and its usage can be found in the <a class="reference external" href="http://dpdk.org/doc/guides/sample_app_ug/pdump.html">DPDK docs</a>.</p>
</div>
<div class="section" id="jumbo-frames">
<h1>Jumbo Frames</h1>
<p>By default, DPDK ports are configured with standard Ethernet MTU (1500B). To
enable Jumbo Frames support for a DPDK port, change the Interface's
<tt class="docutils literal">mtu_request</tt> attribute to a sufficiently large value. For example, to add a
DPDK Phy port with MTU of 9000:</p>
<pre class="literal-block">
$ ovs-vsctl add-port br0 dpdk0 \
  -- set Interface dpdk0 type=dpdk \
  -- set Interface dpdk0 mtu_request=9000`
</pre>
<p>Similarly, to change the MTU of an existing port to 6200:</p>
<pre class="literal-block">
$ ovs-vsctl set Interface dpdk0 mtu_request=6200
</pre>
<p>Some additional configuration is needed to take advantage of jumbo frames with
vHost ports:</p>
<ol class="arabic">
<li><p class="first"><em>mergeable buffers</em> must be enabled for vHost ports, as demonstrated in the
QEMU command line snippet below:</p>
<pre class="literal-block">
-netdev type=vhost-user,id=mynet1,chardev=char0,vhostforce \
-device virtio-net-pci,mac=00:00:00:00:00:01,netdev=mynet1,mrg_rxbuf=on
</pre>
</li>
<li><p class="first">Where virtio devices are bound to the Linux kernel driver in a guest
environment (i.e. interfaces are not bound to an in-guest DPDK driver), the
MTU of those logical network interfaces must also be increased to a
sufficiently large value. This avoids segmentation of Jumbo Frames received
in the guest. Note that 'MTU' refers to the length of the IP packet only,
and not that of the entire frame.</p>
<p>To calculate the exact MTU of a standard IPv4 frame, subtract the L2 header
and CRC lengths (i.e. 18B) from the max supported frame size.  So, to set
the MTU for a 9018B Jumbo Frame:</p>
<pre class="literal-block">
$ ifconfig eth1 mtu 9000
</pre>
</li>
</ol>
<p>When Jumbo Frames are enabled, the size of a DPDK port's mbuf segments are
increased, such that a full Jumbo Frame of a specific size may be accommodated
within a single mbuf segment.</p>
<p>Jumbo frame support has been validated against 9728B frames, which is the
largest frame size supported by Fortville NIC using the DPDK i40e driver, but
larger frames and other DPDK NIC drivers may be supported. These cases are
common for use cases involving East-West traffic only.</p>
</div>
<div class="section" id="vsperf">
<h1>vsperf</h1>
<p>The vsperf project aims to develop a vSwitch test framework that can be used to
validate the suitability of different vSwitch implementations in a telco
deployment environment. More information can be found on the <a class="reference external" href="https://wiki.opnfv.org/display/vsperf/VSperf+Home">OPNFV wiki</a>.</p>
</div>
<div class="section" id="bug-reporting">
<h1>Bug Reporting</h1>
<p>Report problems to <a class="reference external" href="mailto:bugs&#64;openvswitch.org">bugs&#64;openvswitch.org</a>.</p>
</div>
</div>
</body>
</html>
