<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>INSTALL.rst (Open vSwitch 2.6.90)</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="open-vswitch-on-linux-freebsd-and-netbsd">
<h1 class="title">Open vSwitch on Linux, FreeBSD and NetBSD</h1>

<!-- Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations
under the License.

Convention for heading levels in Open vSwitch documentation:

=======  Heading 0 (reserved for the title in a document)
- - - - - - -  Heading 1
~~~~~~~  Heading 2
+++++++  Heading 3
'''''''  Heading 4

Avoid deeper levels because they do not render well. -->
<p>This document describes how to build and install Open vSwitch on a generic
Linux, FreeBSD, or NetBSD host. For specifics around installation on a specific
platform, refer to one of these installation guides:</p>
<ul class="simple">
<li><a class="reference external" href="INSTALL.Debian.rst">Debian</a></li>
<li><a class="reference external" href="INSTALL.Fedora.rst">Fedora</a></li>
<li><a class="reference external" href="INSTALL.RHEL.rst">RHEL</a></li>
<li><a class="reference external" href="INSTALL.XenServer.rst">XenServer</a></li>
<li><a class="reference external" href="INSTALL.NetBSD.rst">NetBSD</a></li>
<li><a class="reference external" href="INSTALL.Windows.rst">Windows</a></li>
<li><a class="reference external" href="INSTALL.DPDK.rst">DPDK</a></li>
</ul>
<div class="section" id="build-requirements">
<span id="general-build-reqs"></span><h1>Build Requirements</h1>
<p>To compile the userspace programs in the Open vSwitch distribution, you will
need the following software:</p>
<ul>
<li><p class="first">GNU make</p>
</li>
<li><p class="first">A C compiler, such as:</p>
<ul class="simple">
<li>GCC 4.x.</li>
<li>Clang. Clang 3.4 and later provide useful static semantic analysis and
thread-safety checks. For Ubuntu, there are nightly built packages
available on clang's website.</li>
<li>MSVC 2013. See the <a class="reference external" href="INSTALL.Windows">Windows installation guide</a>
for additional Windows build instructions.</li>
</ul>
<p>While OVS may be compatible with other compilers, optimal support for atomic
operations may be missing, making OVS very slow (see <tt class="docutils literal"><span class="pre">lib/ovs-atomic.h</span></tt>).</p>
</li>
<li><p class="first">libssl, from OpenSSL, is optional but recommended if you plan to connect the
Open vSwitch to an OpenFlow controller. libssl is required to establish
confidentiality and authenticity in the connections from an Open vSwitch to
an OpenFlow controller. If libssl is installed, then Open vSwitch will
automatically build with support for it.</p>
</li>
<li><p class="first">libcap-ng, written by Steve Grubb, is optional but recommended. It is
required to run OVS daemons as a non-root user with dropped root privileges.
If libcap-ng is installed, then Open vSwitch will automatically build with
support for it.</p>
</li>
<li><p class="first">Python 2.7. You must also have the Python <tt class="docutils literal">six</tt> library.</p>
</li>
</ul>
<p>On Linux, you may choose to compile the kernel module that comes with the Open
vSwitch distribution or to use the kernel module built into the Linux kernel
(version 3.3 or later). See the <a class="reference external" href="FAQ.rst">FAQ</a> question &quot;What features
are not available in the Open vSwitch kernel datapath that ships as part of the
upstream Linux kernel?&quot; for more information on this trade-off. You may also
use the userspace-only implementation, at some cost in features and performance
(see the <a class="reference external" href="INSTALL.userspace.rst">userspace installation guide</a> for details).</p>
<p>To compile the kernel module on Linux, you must also install the
following:</p>
<ul>
<li><p class="first">A supported Linux kernel version. Refer to the <a class="reference external" href="README.rst">README</a>
for a list of supported versions.</p>
<p>For optional support of ingress policing, you must enable kernel
configuration options <tt class="docutils literal">NET_CLS_BASIC</tt>, <tt class="docutils literal">NET_SCH_INGRESS</tt>, and
<tt class="docutils literal">NET_ACT_POLICE</tt>, either built-in or as modules. <tt class="docutils literal">NET_CLS_POLICE</tt> is
obsolete and not needed.)</p>
<p>On kernels before 3.11, the <tt class="docutils literal">ip_gre</tt> module, for GRE tunnels over IP
(<tt class="docutils literal">NET_IPGRE</tt>), must not be loaded or compiled in.</p>
<p>To configure HTB or HFSC quality of service with Open vSwitch, you must
enable the respective configuration options.</p>
<p>To use Open vSwitch support for TAP devices, you must enable <tt class="docutils literal">CONFIG_TUN</tt>.</p>
</li>
<li><p class="first">To build a kernel module, you need the same version of GCC that was used to
build that kernel.</p>
</li>
<li><p class="first">A kernel build directory corresponding to the Linux kernel image the module
is to run on. Under Debian and Ubuntu, for example, each linux-image package
containing a kernel binary has a corresponding linux-headers package with
the required build infrastructure.</p>
</li>
</ul>
<p>If you are working from a Git tree or snapshot (instead of from a distribution
tarball), or if you modify the Open vSwitch build system or the database
schema, you will also need the following software:</p>
<ul class="simple">
<li>Autoconf version 2.63 or later.</li>
<li>Automake version 1.10 or later.</li>
<li>libtool version 2.4 or later. (Older versions might work too.)</li>
</ul>
<p>To run the unit tests, you also need:</p>
<ul class="simple">
<li>Perl. Version 5.10.1 is known to work. Earlier versions should also
work.</li>
</ul>
<p>The datapath tests for userspace and Linux datapaths also rely upon:</p>
<ul class="simple">
<li>pyftpdlib. Version 1.2.0 is known to work. Earlier versions should
also work.</li>
<li>GNU wget. Version 1.16 is known to work. Earlier versions should also
work.</li>
</ul>
<p>The ovs-vswitchd.conf.db(5) manpage will include an E-R diagram, in formats
other than plain text, only if you have the following:</p>
<ul class="simple">
<li>dot from graphviz (<a class="reference external" href="http://www.graphviz.org/">http://www.graphviz.org/</a>).</li>
<li>Perl. Version 5.10.1 is known to work. Earlier versions should also
work.</li>
</ul>
<p>If you are going to extensively modify Open vSwitch, consider installing the
following to obtain better warnings:</p>
<ul>
<li><p class="first">&quot;sparse&quot; version 0.4.4 or later
(<a class="reference external" href="http://www.kernel.org/pub/software/devel/sparse/dist/">http://www.kernel.org/pub/software/devel/sparse/dist/</a>).</p>
</li>
<li><p class="first">GNU make.</p>
</li>
<li><p class="first">clang, version 3.4 or later</p>
</li>
<li><p class="first">flake8, version 2.X, along with the hacking flake8 plugin (for Python code).
The automatic flake8 check that runs against Python code has some warnings
enabled that come from the &quot;hacking&quot; flake8 plugin. If it's not installed,
the warnings just won't occur until it's run on a system with &quot;hacking&quot;
installed. Note that there are problems with flake8 3.0 and the &quot;hacking&quot;
plugin. To ensure you get flake8 2.X, you can use:</p>
<pre class="literal-block">
$ pip install 'flake8&lt;3.0'
</pre>
</li>
</ul>
<p>You may find the ovs-dev script found in <tt class="docutils literal"><span class="pre">utilities/ovs-dev.py</span></tt> useful.</p>
</div>
<div class="section" id="installation-requirements">
<span id="general-install-reqs"></span><h1>Installation Requirements</h1>
<p>The machine you build Open vSwitch on may not be the one you run it on. To
simply install and run Open vSwitch you require the following software:</p>
<ul class="simple">
<li>libc compatible with the libc used for build.</li>
<li>libssl compatible with the libssl used for build, if OpenSSL was used
for the build.</li>
<li>On Linux, the same kernel version configured as part of the build.</li>
<li>For optional support of ingress policing on Linux, the &quot;tc&quot; program
from iproute2 (part of all major distributions and available at
<a class="reference external" href="http://www.linux-foundation.org/en/Net:Iproute2">http://www.linux-foundation.org/en/Net:Iproute2</a>).</li>
<li>Python 2.7. You must also have the Python six library.</li>
</ul>
<p>On Linux you should ensure that <tt class="docutils literal">/dev/urandom</tt> exists. To support TAP
devices, you must also ensure that <tt class="docutils literal">/dev/net/tun</tt> exists.</p>
</div>
<div class="section" id="bootstrapping">
<span id="general-bootstrapping"></span><h1>Bootstrapping</h1>
<p>This step is not needed if you have downloaded a released tarball. If
you pulled the sources directly from an Open vSwitch Git tree or got a
Git tree snapshot, then run boot.sh in the top source directory to build
the &quot;configure&quot; script:</p>
<pre class="literal-block">
$ ./boot.sh
</pre>
</div>
<div class="section" id="configuring">
<span id="general-configuring"></span><h1>Configuring</h1>
<p>Configure the package by running the configure script. You can usually
invoke configure without any arguments. For example:</p>
<pre class="literal-block">
$ ./configure
</pre>
<p>By default all files are installed under <tt class="docutils literal">/usr/local</tt>. Open vSwitch also
expects to find its database in <tt class="docutils literal">/usr/local/etc/openvswitch</tt> by default. If
you want to install all files into, e.g., <tt class="docutils literal">/usr</tt> and <tt class="docutils literal">/var</tt> instead of
<tt class="docutils literal">/usr/local</tt> and <tt class="docutils literal">/usr/local/var</tt> and expect to use <tt class="docutils literal">/etc/openvswitch</tt> as
the default database directory, add options as shown here:</p>
<pre class="literal-block">
$ ./configure --prefix=/usr --localstatedir=/var --sysconfdir=/etc
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Open vSwitch installed with packages like .rpm (e.g. via <tt class="docutils literal">yum install</tt> or
<tt class="docutils literal">rpm <span class="pre">-ivh</span></tt>) and .deb (e.g. via <tt class="docutils literal"><span class="pre">apt-get</span> install</tt> or <tt class="docutils literal">dpkg <span class="pre">-i</span></tt>) use the
above configure options.</p>
</div>
<p>By default, static libraries are built and linked against. If you want to use
shared libraries instead:</p>
<pre class="literal-block">
$ ./configure --enable-shared
</pre>
<p>To use a specific C compiler for compiling Open vSwitch user programs, also
specify it on the configure command line, like so:</p>
<pre class="literal-block">
$ ./configure CC=gcc-4.2
</pre>
<p>To use 'clang' compiler:</p>
<pre class="literal-block">
$ ./configure CC=clang
</pre>
<p>To supply special flags to the C compiler, specify them as <tt class="docutils literal">CFLAGS</tt> on the
configure command line. If you want the default CFLAGS, which include <tt class="docutils literal"><span class="pre">-g</span></tt> to
build debug symbols and <tt class="docutils literal"><span class="pre">-O2</span></tt> to enable optimizations, you must include them
yourself. For example, to build with the default CFLAGS plus <tt class="docutils literal"><span class="pre">-mssse3</span></tt>, you
might run configure as follows:</p>
<pre class="literal-block">
$ ./configure CFLAGS=&quot;-g -O2 -mssse3&quot;
</pre>
<p>For efficient hash computation special flags can be passed to leverage built-in
intrinsics. For example on X86_64 with SSE4.2 instruction set support, CRC32
intrinsics can be used by passing <tt class="docutils literal"><span class="pre">-msse4.2</span></tt>:</p>
<pre class="literal-block">
$ ./configure CFLAGS=&quot;-g -O2 -msse4.2&quot;`
</pre>
<p>If you are on a different processor and don't know what flags to choose, it is
recommended to use <tt class="docutils literal"><span class="pre">-march=native</span></tt> settings:</p>
<pre class="literal-block">
$ ./configure CFLAGS=&quot;-g -O2 -march=native&quot;
</pre>
<p>With this, GCC will detect the processor and automatically set appropriate
flags for it. This should not be used if you are compiling OVS outside the
target machine.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p>CFLAGS are not applied when building the Linux kernel module. Custom CFLAGS
for the kernel module are supplied using the <tt class="docutils literal">EXTRA_CFLAGS</tt> variable when
running make. For example:</p>
<pre class="last literal-block">
$ make EXTRA_CFLAGS=&quot;-Wno-error=date-time&quot;
</pre>
</div>
<p>To build the Linux kernel module, so that you can run the kernel-based switch,
pass the location of the kernel build directory on <tt class="docutils literal"><span class="pre">--with-linux</span></tt>. For
example, to build for a running instance of Linux:</p>
<pre class="literal-block">
$ ./configure --with-linux=/lib/modules/$(uname -r)/build
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">If <tt class="docutils literal"><span class="pre">--with-linux</span></tt> requests building for an unsupported version of Linux,
then <tt class="docutils literal">configure</tt> will fail with an error message. Refer to the <a class="reference external" href="FAQ.rst">FAQ</a> for advice in that case.</p>
</div>
<p>If you wish to build the kernel module for an architecture other than the
architecture of the machine used for the build, you may specify the kernel
architecture string using the KARCH variable when invoking the configure
script. For example, to build for MIPS with Linux:</p>
<pre class="literal-block">
$ ./configure --with-linux=/path/to/linux KARCH=mips
</pre>
<p>If you plan to do much Open vSwitch development, you might want to add
<tt class="docutils literal"><span class="pre">--enable-Werror</span></tt>, which adds the <tt class="docutils literal"><span class="pre">-Werror</span></tt> option to the compiler command
line, turning warnings into errors. That makes it impossible to miss warnings
generated by the build. For example:</p>
<pre class="literal-block">
$ ./configure --enable-Werror
</pre>
<p>To build with gcov code coverage support, add <tt class="docutils literal"><span class="pre">--enable-coverage</span></tt>:</p>
<pre class="literal-block">
$ ./configure --enable-coverage
</pre>
<p>The configure script accepts a number of other options and honors additional
environment variables. For a full list, invoke configure with the <tt class="docutils literal"><span class="pre">--help</span></tt>
option:</p>
<pre class="literal-block">
$ ./configure --help
</pre>
<p>You can also run configure from a separate build directory. This is helpful if
you want to build Open vSwitch in more than one way from a single source
directory, e.g. to try out both GCC and Clang builds, or to build kernel
modules for more than one Linux version. For example:</p>
<pre class="literal-block">
$ mkdir _gcc &amp;&amp; (cd _gcc &amp;&amp; ./configure CC=gcc)
$ mkdir _clang &amp;&amp; (cd _clang &amp;&amp; ./configure CC=clang)
</pre>
<p>Under certains loads the ovsdb-server and other components perform better when
using the jemalloc memory allocator, instead of the glibc memory allocator. If
you wish to link with jemalloc add it to LIBS:</p>
<pre class="literal-block">
$ ./configure LIBS=-ljemalloc
</pre>
</div>
<div class="section" id="building">
<span id="general-building"></span><h1>Building</h1>
<ol class="arabic">
<li><p class="first">Run GNU make in the build directory, e.g.:</p>
<pre class="literal-block">
$ make
</pre>
<p>or if GNU make is installed as &quot;gmake&quot;:</p>
<pre class="literal-block">
$ gmake
</pre>
<p>If you used a separate build directory, run make or gmake from that
directory, e.g.:</p>
<pre class="literal-block">
$ make -C _gcc
$ make -C _clang
</pre>
<p>For improved warnings if you installed <tt class="docutils literal">sparse</tt> (see &quot;Prerequisites&quot;), add
<tt class="docutils literal">C=1</tt> to the command line.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Some versions of Clang and ccache are not completely compatible. If you
see unusual warnings when you use both together, consider disabling
ccache.</p>
</div>
</li>
<li><p class="first">Consider running the testsuite. Refer to <strong>Testing</strong> for instructions.</p>
</li>
<li><p class="first">Run <tt class="docutils literal">make install</tt> to install the executables and manpages into the
running system, by default under <tt class="docutils literal">/usr/local</tt>:</p>
<pre class="literal-block">
$ make install
</pre>
</li>
</ol>
<ol class="arabic" start="5">
<li><p class="first">If you built kernel modules, you may install them, e.g.:</p>
<pre class="literal-block">
$ make modules_install
</pre>
<p>It is possible that you already had a Open vSwitch kernel module installed
on your machine that came from upstream Linux (in a different directory). To
make sure that you load the Open vSwitch kernel module you built from this
repository, you should create a <tt class="docutils literal">depmod.d</tt> file that prefers your newly
installed kernel modules over the kernel modules from upstream Linux. The
following snippet of code achieves the same:</p>
<pre class="literal-block">
$ config_file=&quot;/etc/depmod.d/openvswitch.conf&quot;
$ for module in datapath/linux/*.ko; do
  modname=&quot;$(basename ${module})&quot;
  echo &quot;override ${modname%.ko} * extra&quot; &gt;&gt; &quot;$config_file&quot;
  echo &quot;override ${modname%.ko} * weak-updates&quot; &gt;&gt; &quot;$config_file&quot;
  done
$ depmod -a
</pre>
<p>Finally, load the kernel modules that you need. e.g.:</p>
<pre class="literal-block">
$ /sbin/modprobe openvswitch
</pre>
<p>To verify that the modules have been loaded, run <tt class="docutils literal">/sbin/lsmod</tt> and check
that openvswitch is listed:</p>
<pre class="literal-block">
$ /sbin/lsmod | grep openvswitch
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p>If the <tt class="docutils literal">modprobe</tt> operation fails, look at the last few kernel log
messages (e.g. with <tt class="docutils literal">dmesg | tail</tt>). Generally, issues like this occur
when Open vSwitch is built for a kernel different from the one into which
you are trying to load it.  Run <tt class="docutils literal">modinfo</tt> on <tt class="docutils literal">openvswitch.ko</tt> and on a
module built for the running kernel, e.g.:</p>
<pre class="literal-block">
$ /sbin/modinfo openvswitch.ko
$ /sbin/modinfo /lib/modules/$(uname -r)/kernel/net/bridge/bridge.ko
</pre>
<p>Compare the &quot;vermagic&quot; lines output by the two commands.  If they differ,
then Open vSwitch was built for the wrong kernel.</p>
<p class="last">If you decide to report a bug or ask a question related to module loading,
include the output from the <tt class="docutils literal">dmesg</tt> and <tt class="docutils literal">modinfo</tt> commands mentioned
above.</p>
</div>
</li>
</ol>
</div>
<div class="section" id="starting">
<span id="general-starting"></span><h1>Starting</h1>
<p>Before starting ovs-vswitchd itself, you need to start its configuration
database, ovsdb-server. Each machine on which Open vSwitch is installed should
run its own copy of ovsdb-server. Before ovsdb-server itself can be started,
configure a database that it can use:</p>
<pre class="literal-block">
$ mkdir -p /usr/local/etc/openvswitch
$ ovsdb-tool create /usr/local/etc/openvswitch/conf.db \
    vswitchd/vswitch.ovsschema
</pre>
<p>Configure ovsdb-server to use database created above, to listen on a Unix
domain socket, to connect to any managers specified in the database itself, and
to use the SSL configuration in the database:</p>
<pre class="literal-block">
$ mkdir -p /usr/local/var/run/openvswitch
$ ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \
    --remote=db:Open_vSwitch,Open_vSwitch,manager_options \
    --private-key=db:Open_vSwitch,SSL,private_key \
    --certificate=db:Open_vSwitch,SSL,certificate \
    --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \
    --pidfile --detach
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">If you built Open vSwitch without SSL support, then omit <tt class="docutils literal"><span class="pre">--private-key</span></tt>,
<tt class="docutils literal"><span class="pre">--certificate</span></tt>, and <tt class="docutils literal"><span class="pre">--bootstrap-ca-cert</span></tt>.)</p>
</div>
<p>Initialize the database using ovs-vsctl. This is only necessary the first time
after you create the database with ovsdb-tool, though running it at any time is
harmless:</p>
<pre class="literal-block">
$ ovs-vsctl --no-wait init
</pre>
<p>Start the main Open vSwitch daemon, telling it to connect to the same Unix
domain socket:</p>
<pre class="literal-block">
$ ovs-vswitchd --pidfile --detach
</pre>
</div>
<div class="section" id="validating">
<h1>Validating</h1>
<p>At this point you can use ovs-vsctl to set up bridges and other Open vSwitch
features.  For example, to create a bridge named <tt class="docutils literal">br0</tt> and add ports <tt class="docutils literal">eth0</tt>
and <tt class="docutils literal">vif1.0</tt> to it:</p>
<pre class="literal-block">
$ ovs-vsctl add-br br0
$ ovs-vsctl add-port br0 eth0
$ ovs-vsctl add-port br0 vif1.0
</pre>
<p>Refer to ovs-vsctl(8) for more details.</p>
</div>
<div class="section" id="upgrading">
<h1>Upgrading</h1>
<p>When you upgrade Open vSwitch from one version to another you should also
upgrade the database schema:</p>
<ol class="arabic">
<li><p class="first">Stop the Open vSwitch daemons, e.g.:</p>
<pre class="literal-block">
$ kill `cd /usr/local/var/run/openvswitch &amp;&amp; cat ovsdb-server.pid ovs-vswitchd.pid`
</pre>
</li>
<li><p class="first">Install the new Open vSwitch release by using the same configure options as
was used for installing the previous version. If you do not use the same
configure options, you can end up with two different versions of Open
vSwitch executables installed in different locations.</p>
</li>
<li><p class="first">Upgrade the database, in one of the following two ways:</p>
<ul>
<li><p class="first">If there is no important data in your database, then you may delete the
database file and recreate it with ovsdb-tool, following the instructions
under &quot;Building and Installing Open vSwitch for Linux, FreeBSD or NetBSD&quot;.</p>
</li>
<li><p class="first">If you want to preserve the contents of your database, back it up first,
then use <tt class="docutils literal"><span class="pre">ovsdb-tool</span> convert</tt> to upgrade it, e.g.:</p>
<pre class="literal-block">
$ ovsdb-tool convert /usr/local/etc/openvswitch/conf.db \
    vswitchd/vswitch.ovsschema
</pre>
</li>
</ul>
</li>
<li><p class="first">Start the Open vSwitch daemons as described under <strong>Starting</strong> above.</p>
</li>
</ol>
</div>
<div class="section" id="hot-upgrading">
<h1>Hot Upgrading</h1>
<p>Upgrading Open vSwitch from one version to the next version with minimum
disruption of traffic going through the system that is using that Open vSwitch
needs some considerations:</p>
<ol class="arabic simple">
<li>If the upgrade only involves upgrading the userspace utilities and daemons
of Open vSwitch, make sure that the new userspace version is compatible with
the previously loaded kernel module.</li>
<li>An upgrade of userspace daemons means that they have to be restarted.
Restarting the daemons means that the OpenFlow flows in the ovs-vswitchd
daemon will be lost. One way to restore the flows is to let the controller
re-populate it. Another way is to save the previous flows using a utility
like ovs-ofctl and then re-add them after the restart. Restoring the old
flows is accurate only if the new Open vSwitch interfaces retain the old
'ofport' values.</li>
<li>When the new userspace daemons get restarted, they automatically flush the
old flows setup in the kernel. This can be expensive if there are hundreds
of new flows that are entering the kernel but userspace daemons are busy
setting up new userspace flows from either the controller or an utility like
ovs-ofctl. Open vSwitch database provides an option to solve this problem
through the <tt class="docutils literal"><span class="pre">other_config:flow-restore-wait</span></tt> column of the
<tt class="docutils literal">Open_vSwitch</tt> table. Refer to the ovs-vswitchd.conf.db(5) manpage for
details.</li>
<li>If the upgrade also involves upgrading the kernel module, the old kernel
module needs to be unloaded and the new kernel module should be loaded. This
means that the kernel network devices belonging to Open vSwitch is recreated
and the kernel flows are lost. The downtime of the traffic can be reduced if
the userspace daemons are restarted immediately and the userspace flows are
restored as soon as possible.</li>
</ol>
<p>The ovs-ctl utility's <tt class="docutils literal">restart</tt> function only restarts the userspace daemons,
makes sure that the 'ofport' values remain consistent across restarts, restores
userspace flows using the ovs-ofctl utility and also uses the
<tt class="docutils literal"><span class="pre">other_config:flow-restore-wait</span></tt> column to keep the traffic downtime to the
minimum. The ovs-ctl utility's <tt class="docutils literal"><span class="pre">force-reload-kmod</span></tt> function does all of the
above, but also replaces the old kernel module with the new one. Open vSwitch
startup scripts for Debian, XenServer and RHEL use ovs-ctl's functions and it
is recommended that these functions be used for other software platforms too.</p>
</div>
<div class="section" id="testing">
<span id="general-testing"></span><h1>Testing</h1>
<p>This section describe Open vSwitch's built-in support for various test
suites. You must bootstrap, configure and build Open vSwitch (steps are
in &quot;Building and Installing Open vSwitch for Linux, FreeBSD or NetBSD&quot;
above) before you run the tests described here. You do not need to
install Open vSwitch or to build or load the kernel module to run these
test suites. You do not need supervisor privilege to run these test
suites.</p>
<div class="section" id="unit-tests">
<h2>Unit Tests</h2>
<p>Open vSwitch includes a suite of self-tests. Before you submit patches
upstream, we advise that you run the tests and ensure that they pass. If you
add new features to Open vSwitch, then adding tests for those features will
ensure your features don't break as developers modify other areas of Open
vSwitch.</p>
<p>To run all the unit tests in Open vSwitch, one at a time, run:</p>
<pre class="literal-block">
$ make check
</pre>
<p>This takes under 5 minutes on a modern desktop system.</p>
<p>To run all the unit tests in Open vSwitch in parallel, run:</p>
<pre class="literal-block">
$ make check TESTSUITEFLAGS=-j8
</pre>
<p>You can run up to eight threads. This takes under a minute on a modern 4-core
desktop system.</p>
<p>To see a list of all the available tests, run:</p>
<blockquote>
$ make check TESTSUITEFLAGS=--list</blockquote>
<p>To run only a subset of tests, e.g. test 123 and tests 477 through 484, run:</p>
<pre class="literal-block">
$ make check TESTSUITEFLAGS='123 477-484'
</pre>
<p>Tests do not have inter-dependencies, so you may run any subset.</p>
<p>To run tests matching a keyword, e.g. <tt class="docutils literal">ovsdb</tt>, run:</p>
<pre class="literal-block">
$ make check TESTSUITEFLAGS='-k ovsdb'
</pre>
<p>To see a complete list of test options, run:</p>
<pre class="literal-block">
$ make check TESTSUITEFLAGS=--help
</pre>
<p>The results of a testing run are reported in <tt class="docutils literal">tests/testsuite.log</tt>. Report
report test failures as bugs and include the <tt class="docutils literal">testsuite.log</tt> in your report.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p>Sometimes a few tests may fail on some runs but not others. This is usually a
bug in the testsuite, not a bug in Open vSwitch itself. If you find that a
test fails intermittently, please report it, since the developers may not
have noticed. You can make the testsuite automatically rerun tests that fail,
by adding <tt class="docutils literal">RECHECK=yes</tt> to the <tt class="docutils literal">make</tt> command line, e.g.:</p>
<pre class="last literal-block">
$ make check TESTSUITEFLAGS=-j8 RECHECK=yes
</pre>
</div>
<div class="section" id="coverage">
<h3>Coverage</h3>
<p>If the build was configured with <tt class="docutils literal"><span class="pre">--enable-coverage</span></tt> and the <tt class="docutils literal">lcov</tt> utility
is installed, you can run the testsuite and generate a code coverage report by
using the <tt class="docutils literal"><span class="pre">check-lcoc</span></tt> target:</p>
<pre class="literal-block">
$ make check-lcov
</pre>
<p>All the same options are avaiable via TESTSUITEFLAGS. For example:</p>
<pre class="literal-block">
$ make check-lcov TESTSUITEFLAGS=-j8 -k ovn
</pre>
</div>
<div class="section" id="valgrind">
<h3>Valgrind</h3>
<p>If you have <tt class="docutils literal">valgrind</tt> installed, you can run the testsuite under
valgrind by using the <tt class="docutils literal"><span class="pre">check-valgrind</span></tt> target:</p>
<pre class="literal-block">
$ make check-valgrind
</pre>
<p>When you do this, the &quot;valgrind&quot; results for test <tt class="docutils literal">&lt;N&gt;</tt> are reported in files
named <tt class="docutils literal"><span class="pre">tests/testsuite.dir/&lt;N&gt;/valgrind.*</span></tt>.</p>
<p>All the same options are available via TESTSUITEFLAGS.</p>
<div class="hint">
<p class="first admonition-title">Hint</p>
<p class="last">You may find that the valgrind results are easier to interpret if you put
<tt class="docutils literal"><span class="pre">-q</span></tt> in <tt class="docutils literal"><span class="pre">~/.valgrindrc</span></tt>, since that reduces the amount of output.</p>
</div>
</div>
</div>
<div class="section" id="oftest">
<span id="general-oftest"></span><h2>OFTest</h2>
<p>OFTest is an OpenFlow protocol testing suite. Open vSwitch includes a Makefile
target to run OFTest with Open vSwitch in &quot;dummy mode&quot;. In this mode of
testing, no packets travel across physical or virtual networks.  Instead, Unix
domain sockets stand in as simulated networks. This simulation is imperfect,
but it is much easier to set up, does not require extra physical or virtual
hardware, and does not require supervisor privileges.</p>
<p>To run OFTest with Open vSwitch, first read and follow the instructions under
<strong>Testing</strong> above. Second, obtain a copy of OFTest and install its
prerequisites. You need a copy of OFTest that includes commit 406614846c5 (make
ovs-dummy platform work again). This commit was merged into the OFTest
repository on Feb 1, 2013, so any copy of OFTest more recent than that should
work. Testing OVS in dummy mode does not require root privilege, so you may
ignore that requirement.</p>
<p>Optionally, add the top-level OFTest directory (containing the <tt class="docutils literal">oft</tt> program)
to your <tt class="docutils literal">$PATH</tt>. This slightly simplifies running OFTest later.</p>
<p>To run OFTest in dummy mode, run the following command from your Open vSwitch
build directory:</p>
<pre class="literal-block">
$ make check-oftest OFT=&lt;oft-binary&gt;
</pre>
<p>where <tt class="docutils literal"><span class="pre">&lt;oft-binary&gt;</span></tt> is the absolute path to the <tt class="docutils literal">oft</tt> program in OFTest.
If you added &quot;oft&quot; to your $PATH, you may omit the OFT variable
assignment</p>
<p>By default, <tt class="docutils literal"><span class="pre">check-oftest</span></tt> passes <tt class="docutils literal">oft</tt> just enough options to enable dummy
mode. You can use <tt class="docutils literal">OFTFLAGS</tt> to pass additional options. For example, to run
just the <tt class="docutils literal">basic.Echo</tt> test instead of all tests (the default) and enable
verbose logging, run:</p>
<pre class="literal-block">
$ make check-oftest OFT=&lt;oft-binary&gt; OFTFLAGS='--verbose -T basic.Echo'
</pre>
<p>If you use OFTest that does not include commit 4d1f3eb2c792 (oft: change
default port to 6653), merged into the OFTest repository in October 2013, then
you need to add an option to use the IETF-assigned controller port:</p>
<pre class="literal-block">
$ make check-oftest OFT=&lt;oft-binary&gt; OFTFLAGS='--port=6653'
</pre>
<p>Interpret OFTest results cautiously. Open vSwitch can fail a given test in
OFTest for many reasons, including bugs in Open vSwitch, bugs in OFTest, bugs
in the &quot;dummy mode&quot; integration, and differing interpretations of the OpenFlow
standard and other standards.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Open vSwitch has not been validated against OFTest. Report test failures that
you believe to represent bugs in Open vSwitch. Include the precise versions
of Open vSwitch and OFTest in your bug report, plus any other information
needed to reproduce the problem.</p>
</div>
</div>
<div class="section" id="ryu">
<h2>Ryu</h2>
<p>Ryu is an OpenFlow controller written in Python that includes an extensive
OpenFlow testsuite. Open vSwitch includes a Makefile target to run Ryu in
&quot;dummy mode&quot;. See <strong>OFTest</strong> above for an explanation of dummy mode.</p>
<p>To run Ryu tests with Open vSwitch, first read and follow the instructions
under <strong>Testing</strong> above. Second, obtain a copy of Ryu, install its
prerequisites, and build it. You do not need to install Ryu (some of the tests
do not get installed, so it does not help).</p>
<p>To run Ryu tests, run the following command from your Open vSwitch build
directory:</p>
<pre class="literal-block">
$ make check-ryu RYUDIR=&lt;ryu-source-dir&gt;``
</pre>
<p>where <tt class="docutils literal"><span class="pre">&lt;ryu-source-dir&gt;</span></tt> is the absolute path to the root of the Ryu source
distribution. The default <tt class="docutils literal"><span class="pre">&lt;ryu-source-dir&gt;</span></tt> is <tt class="docutils literal"><span class="pre">$srcdir/../ryu</span></tt>
where <tt class="docutils literal">$srcdir</tt> is your Open vSwitch source directory. If this is correct,
omit <tt class="docutils literal">RYUDIR</tt></p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Open vSwitch has not been validated against Ryu. Report test failures that
you believe to represent bugs in Open vSwitch. Include the precise versions
of Open vSwitch and Ryu in your bug report, plus any other information
needed to reproduce the problem.</p>
</div>
</div>
<div class="section" id="datapath-testing">
<h2>Datapath testing</h2>
<p>Open vSwitch includes a suite of tests specifically for datapath functionality,
which can be run against the userspace or kernel datapaths. If you are
developing datapath features, it is recommended that you use these tests and
build upon them to verify your implementation.</p>
<p>The datapath tests make some assumptions about the environment. They must be
run under root privileges on a Linux system with support for network
namespaces. For ease of use, the OVS source tree includes a vagrant box to
invoke these tests. Running the tests inside Vagrant provides kernel isolation,
protecting your development host from kernel panics or configuration conflicts
in the testsuite. If you wish to run the tests without using the vagrant box,
there are further instructions below.</p>
<div class="section" id="vagrant">
<h3>Vagrant</h3>
<div class="important">
<p class="first admonition-title">Important</p>
<p class="last">Requires Vagrant (version 1.7.0 or later) and a compatible hypervisor</p>
</div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">You must <strong>Bootstrap</strong> and <strong>Configure</strong> the sources before you run the steps
described here.</p>
</div>
<p>A Vagrantfile is provided allowing to compile and provision the source tree as
found locally in a virtual machine using the following command:</p>
<pre class="literal-block">
$ vagrant up
</pre>
<p>This will bring up a Fedora 23 VM by default. If you wish to use a different
box or a vagrant backend not supported by the default box, the <tt class="docutils literal">Vagrantfile</tt>
can be modified to use a different box as base.</p>
<p>The VM can be reprovisioned at any time:</p>
<pre class="literal-block">
$ vagrant provision
</pre>
<p>OVS out-of-tree compilation environment can be set up with:</p>
<pre class="literal-block">
$ ./boot.sh
$ vagrant provision --provision-with configure_ovs,build_ovs
</pre>
<p>This will set up an out-of-tree build environment inside the VM in
<tt class="docutils literal">/root/build</tt>.  The source code can be found in <tt class="docutils literal">/vagrant</tt>.</p>
<p>To recompile and reinstall OVS in the VM using RPM:</p>
<pre class="literal-block">
$ ./boot.sh
$ vagrant provision --provision-with configure_ovs,install_rpm
</pre>
<p>Two provisioners are included to run system tests with the OVS kernel module or
with a userspace datapath. This tests are different from the self-tests
mentioned above. To run them:</p>
<pre class="literal-block">
$ ./boot.sh
$ vagrant provision --provision-with \
    configure_ovs,test_ovs_kmod,test_ovs_system_userspace
</pre>
<p>The results of the testsuite reside in the VM root user's home directory:</p>
<pre class="literal-block">
$ vagrant ssh
$ sudo -s
$ cd /root/build
$ ls tests/system*
</pre>
</div>
<div class="section" id="native">
<h3>Native</h3>
<p>The datapath testsuite as invoked by Vagrant above may also be run manually on
a Linux system with root privileges. These tests may take several minutes to
complete, and cannot be run in parallel.</p>
<div class="section" id="userspace-datapath">
<h4>Userspace datapath</h4>
<p>To invoke the datapath testsuite with the userspace datapath, run:</p>
<pre class="literal-block">
$ make check-system-userspace
</pre>
<p>The results of the testsuite are in <tt class="docutils literal"><span class="pre">tests/system-userspace-traffic.dir</span></tt>.</p>
</div>
<div class="section" id="kernel-datapath">
<h4>Kernel datapath</h4>
<p>Make targets are also provided for testing the Linux kernel module. Note that
these tests operate by inserting modules into the running Linux kernel, so if
the tests are able to trigger a bug in the OVS kernel module or in the upstream
kernel then the kernel may panic.</p>
<p>To run the testsuite against the kernel module which is currently installed on
your system, run:</p>
<pre class="literal-block">
$ make check-kernel
</pre>
<p>To install the kernel module from the current build directory and run the
testsuite against that kernel module:</p>
<pre class="literal-block">
$ make check-kmod
</pre>
<p>The results of the testsuite are in <tt class="docutils literal"><span class="pre">tests/system-kmod-traffic.dir</span></tt>.</p>
</div>
</div>
</div>
<div class="section" id="continuous-integration-with-travis-ci">
<h2>Continuous Integration with Travis-CI</h2>
<p>A .travis.yml file is provided to automatically build Open vSwitch with various
build configurations and run the testsuite using travis-ci. Builds will be
performed with gcc, sparse and clang with the -Werror compiler flag included,
therefore the build will fail if a new warning has been introduced.</p>
<p>The CI build is triggered via git push (regardless of the specific branch) or
pull request against any Open vSwitch GitHub repository that is linked to
travis-ci.</p>
<p>Instructions to setup travis-ci for your GitHub repository:</p>
<ol class="arabic">
<li><p class="first">Go to <a class="reference external" href="http://travis-ci.org/">http://travis-ci.org/</a> and sign in using your GitHub ID.</p>
</li>
<li><p class="first">Go to the &quot;Repositories&quot; tab and enable the ovs repository. You may disable
builds for pushes or pull requests.</p>
</li>
<li><p class="first">In order to avoid forks sending build failures to the upstream mailing list,
the notification email recipient is encrypted. If you want to receive email
notification for build failures, replace the the encrypted string:</p>
<ol class="arabic">
<li><p class="first">Install the travis-ci CLI (Requires ruby &gt;=2.0): gem install travis</p>
</li>
<li><p class="first">In your Open vSwitch repository: travis encrypt <a class="reference external" href="mailto:mylist&#64;mydomain.org">mylist&#64;mydomain.org</a></p>
</li>
<li><p class="first">Add/replace the notifications section in .travis.yml and fill in the
secure string as returned by travis encrypt:</p>
<pre class="literal-block">
notifications:
  email:
    recipients:
      - secure: &quot;.....&quot;
</pre>
</li>
</ol>
</li>
</ol>
<blockquote>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">You may remove/omit the notifications section to fall back to default
notification behaviour which is to send an email directly to the author and
committer of the failing commit. Note that the email is only sent if the
author/committer have commit rights for the particular GitHub repository.</p>
</div>
</blockquote>
<ol class="arabic simple" start="4">
<li>Pushing a commit to the repository which breaks the build or the
testsuite will now trigger a email sent to <a class="reference external" href="mailto:mylist&#64;mydomain.org">mylist&#64;mydomain.org</a></li>
</ol>
</div>
<div class="section" id="static-code-analysis">
<h2>Static Code Analysis</h2>
<p>Static Analysis is a method of debugging Software by examining code rather than
actually executing it. This can be done through 'scan-build' commandline
utility which internally uses clang (or) gcc to compile the code and also
invokes a static analyzer to do the code analysis. At the end of the build, the
reports are aggregated in to a common folder and can later be analyzed using
'scan-view'.</p>
<p>Open vSwitch includes a Makefile target to trigger static code analysis:</p>
<pre class="literal-block">
$ ./boot.sh
$ ./configure CC=clang  # clang
# or
$ ./configure CC=gcc CFLAGS=&quot;-std=gnu99&quot;  # gcc
$ make clang-analyze
</pre>
<p>You should invoke scan-view to view analysis results. The last line of output
from <tt class="docutils literal"><span class="pre">clang-analyze</span></tt> will list the command (containing results directory)
that you should invoke to view the results on a browser.</p>
</div>
</div>
<div class="section" id="bug-reporting">
<h1>Bug Reporting</h1>
<p>Please report problems to <a class="reference external" href="mailto:bugs&#64;openvswitch.org">bugs&#64;openvswitch.org</a>.</p>
</div>
</div>
</body>
</html>
